if (typeof jQuery === "undefined") {
    throw new Error("Bootstrap's JavaScript requires jQuery");
}

+function($) {
    "use strict";
    var version = $.fn.jquery.split(" ")[0].split(".");
    if (version[0] < 2 && version[1] < 9 || version[0] == 1 && version[1] == 9 && version[2] < 1 || version[0] > 2) {
        throw new Error("Bootstrap's JavaScript requires jQuery version 1.9.1 or higher, but lower than version 3");
    }
}(jQuery);

+function($) {
    "use strict";
    function transitionEnd() {
        var el = document.createElement("bootstrap");
        var transEndEventNames = {
            WebkitTransition: "webkitTransitionEnd",
            MozTransition: "transitionend",
            OTransition: "oTransitionEnd otransitionend",
            transition: "transitionend"
        };
        for (var name in transEndEventNames) {
            if (el.style[name] !== undefined) {
                return {
                    end: transEndEventNames[name]
                };
            }
        }
        return false;
    }
    $.fn.emulateTransitionEnd = function(duration) {
        var called = false;
        var $el = this;
        $(this).one("bsTransitionEnd", function() {
            called = true;
        });
        var callback = function() {
            if (!called) $($el).trigger($.support.transition.end);
        };
        setTimeout(callback, duration);
        return this;
    };
    $(function() {
        $.support.transition = transitionEnd();
        if (!$.support.transition) return;
        $.event.special.bsTransitionEnd = {
            bindType: $.support.transition.end,
            delegateType: $.support.transition.end,
            handle: function(e) {
                if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments);
            }
        };
    });
}(jQuery);

+function($) {
    "use strict";
    var dismiss = '[data-dismiss="alert"]';
    var Alert = function(el) {
        $(el).on("click", dismiss, this.close);
    };
    Alert.VERSION = "3.3.6";
    Alert.TRANSITION_DURATION = 150;
    Alert.prototype.close = function(e) {
        var $this = $(this);
        var selector = $this.attr("data-target");
        if (!selector) {
            selector = $this.attr("href");
            selector = selector && selector.replace(/.*(?=#[^\s]*$)/, "");
        }
        var $parent = $(selector);
        if (e) e.preventDefault();
        if (!$parent.length) {
            $parent = $this.closest(".alert");
        }
        $parent.trigger(e = $.Event("close.bs.alert"));
        if (e.isDefaultPrevented()) return;
        $parent.removeClass("in");
        function removeElement() {
            $parent.detach().trigger("closed.bs.alert").remove();
        }
        $.support.transition && $parent.hasClass("fade") ? $parent.one("bsTransitionEnd", removeElement).emulateTransitionEnd(Alert.TRANSITION_DURATION) : removeElement();
    };
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.alert");
            if (!data) $this.data("bs.alert", data = new Alert(this));
            if (typeof option == "string") data[option].call($this);
        });
    }
    var old = $.fn.alert;
    $.fn.alert = Plugin;
    $.fn.alert.Constructor = Alert;
    $.fn.alert.noConflict = function() {
        $.fn.alert = old;
        return this;
    };
    $(document).on("click.bs.alert.data-api", dismiss, Alert.prototype.close);
}(jQuery);

+function($) {
    "use strict";
    var Button = function(element, options) {
        this.$element = $(element);
        this.options = $.extend({}, Button.DEFAULTS, options);
        this.isLoading = false;
    };
    Button.VERSION = "3.3.6";
    Button.DEFAULTS = {
        loadingText: "loading..."
    };
    Button.prototype.setState = function(state) {
        var d = "disabled";
        var $el = this.$element;
        var val = $el.is("input") ? "val" : "html";
        var data = $el.data();
        state += "Text";
        if (data.resetText == null) $el.data("resetText", $el[val]());
        setTimeout($.proxy(function() {
            $el[val](data[state] == null ? this.options[state] : data[state]);
            if (state == "loadingText") {
                this.isLoading = true;
                $el.addClass(d).attr(d, d);
            } else if (this.isLoading) {
                this.isLoading = false;
                $el.removeClass(d).removeAttr(d);
            }
        }, this), 0);
    };
    Button.prototype.toggle = function() {
        var changed = true;
        var $parent = this.$element.closest('[data-toggle="buttons"]');
        if ($parent.length) {
            var $input = this.$element.find("input");
            if ($input.prop("type") == "radio") {
                if ($input.prop("checked")) changed = false;
                $parent.find(".active").removeClass("active");
                this.$element.addClass("active");
            } else if ($input.prop("type") == "checkbox") {
                if ($input.prop("checked") !== this.$element.hasClass("active")) changed = false;
                this.$element.toggleClass("active");
            }
            $input.prop("checked", this.$element.hasClass("active"));
            if (changed) $input.trigger("change");
        } else {
            this.$element.attr("aria-pressed", !this.$element.hasClass("active"));
            this.$element.toggleClass("active");
        }
    };
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.button");
            var options = typeof option == "object" && option;
            if (!data) $this.data("bs.button", data = new Button(this, options));
            if (option == "toggle") data.toggle(); else if (option) data.setState(option);
        });
    }
    var old = $.fn.button;
    $.fn.button = Plugin;
    $.fn.button.Constructor = Button;
    $.fn.button.noConflict = function() {
        $.fn.button = old;
        return this;
    };
    $(document).on("click.bs.button.data-api", '[data-toggle^="button"]', function(e) {
        var $btn = $(e.target);
        if (!$btn.hasClass("btn")) $btn = $btn.closest(".btn");
        Plugin.call($btn, "toggle");
        if (!($(e.target).is('input[type="radio"]') || $(e.target).is('input[type="checkbox"]'))) e.preventDefault();
    }).on("focus.bs.button.data-api blur.bs.button.data-api", '[data-toggle^="button"]', function(e) {
        $(e.target).closest(".btn").toggleClass("focus", /^focus(in)?$/.test(e.type));
    });
}(jQuery);

+function($) {
    "use strict";
    var Carousel = function(element, options) {
        this.$element = $(element);
        this.$indicators = this.$element.find(".carousel-indicators");
        this.options = options;
        this.paused = null;
        this.sliding = null;
        this.interval = null;
        this.$active = null;
        this.$items = null;
        this.options.keyboard && this.$element.on("keydown.bs.carousel", $.proxy(this.keydown, this));
        this.options.pause == "hover" && !("ontouchstart" in document.documentElement) && this.$element.on("mouseenter.bs.carousel", $.proxy(this.pause, this)).on("mouseleave.bs.carousel", $.proxy(this.cycle, this));
    };
    Carousel.VERSION = "3.3.6";
    Carousel.TRANSITION_DURATION = 600;
    Carousel.DEFAULTS = {
        interval: 5e3,
        pause: "hover",
        wrap: true,
        keyboard: true
    };
    Carousel.prototype.keydown = function(e) {
        if (/input|textarea/i.test(e.target.tagName)) return;
        switch (e.which) {
          case 37:
            this.prev();
            break;

          case 39:
            this.next();
            break;

          default:
            return;
        }
        e.preventDefault();
    };
    Carousel.prototype.cycle = function(e) {
        e || (this.paused = false);
        this.interval && clearInterval(this.interval);
        this.options.interval && !this.paused && (this.interval = setInterval($.proxy(this.next, this), this.options.interval));
        return this;
    };
    Carousel.prototype.getItemIndex = function(item) {
        this.$items = item.parent().children(".item");
        return this.$items.index(item || this.$active);
    };
    Carousel.prototype.getItemForDirection = function(direction, active) {
        var activeIndex = this.getItemIndex(active);
        var willWrap = direction == "prev" && activeIndex === 0 || direction == "next" && activeIndex == this.$items.length - 1;
        if (willWrap && !this.options.wrap) return active;
        var delta = direction == "prev" ? -1 : 1;
        var itemIndex = (activeIndex + delta) % this.$items.length;
        return this.$items.eq(itemIndex);
    };
    Carousel.prototype.to = function(pos) {
        var that = this;
        var activeIndex = this.getItemIndex(this.$active = this.$element.find(".item.active"));
        if (pos > this.$items.length - 1 || pos < 0) return;
        if (this.sliding) return this.$element.one("slid.bs.carousel", function() {
            that.to(pos);
        });
        if (activeIndex == pos) return this.pause().cycle();
        return this.slide(pos > activeIndex ? "next" : "prev", this.$items.eq(pos));
    };
    Carousel.prototype.pause = function(e) {
        e || (this.paused = true);
        if (this.$element.find(".next, .prev").length && $.support.transition) {
            this.$element.trigger($.support.transition.end);
            this.cycle(true);
        }
        this.interval = clearInterval(this.interval);
        return this;
    };
    Carousel.prototype.next = function() {
        if (this.sliding) return;
        return this.slide("next");
    };
    Carousel.prototype.prev = function() {
        if (this.sliding) return;
        return this.slide("prev");
    };
    Carousel.prototype.slide = function(type, next) {
        var $active = this.$element.find(".item.active");
        var $next = next || this.getItemForDirection(type, $active);
        var isCycling = this.interval;
        var direction = type == "next" ? "left" : "right";
        var that = this;
        if ($next.hasClass("active")) return this.sliding = false;
        var relatedTarget = $next[0];
        var slideEvent = $.Event("slide.bs.carousel", {
            relatedTarget: relatedTarget,
            direction: direction
        });
        this.$element.trigger(slideEvent);
        if (slideEvent.isDefaultPrevented()) return;
        this.sliding = true;
        isCycling && this.pause();
        if (this.$indicators.length) {
            this.$indicators.find(".active").removeClass("active");
            var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)]);
            $nextIndicator && $nextIndicator.addClass("active");
        }
        var slidEvent = $.Event("slid.bs.carousel", {
            relatedTarget: relatedTarget,
            direction: direction
        });
        if ($.support.transition && this.$element.hasClass("slide")) {
            $next.addClass(type);
            $next[0].offsetWidth;
            $active.addClass(direction);
            $next.addClass(direction);
            $active.one("bsTransitionEnd", function() {
                $next.removeClass([ type, direction ].join(" ")).addClass("active");
                $active.removeClass([ "active", direction ].join(" "));
                that.sliding = false;
                setTimeout(function() {
                    that.$element.trigger(slidEvent);
                }, 0);
            }).emulateTransitionEnd(Carousel.TRANSITION_DURATION);
        } else {
            $active.removeClass("active");
            $next.addClass("active");
            this.sliding = false;
            this.$element.trigger(slidEvent);
        }
        isCycling && this.cycle();
        return this;
    };
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.carousel");
            var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == "object" && option);
            var action = typeof option == "string" ? option : options.slide;
            if (!data) $this.data("bs.carousel", data = new Carousel(this, options));
            if (typeof option == "number") data.to(option); else if (action) data[action](); else if (options.interval) data.pause().cycle();
        });
    }
    var old = $.fn.carousel;
    $.fn.carousel = Plugin;
    $.fn.carousel.Constructor = Carousel;
    $.fn.carousel.noConflict = function() {
        $.fn.carousel = old;
        return this;
    };
    var clickHandler = function(e) {
        var href;
        var $this = $(this);
        var $target = $($this.attr("data-target") || (href = $this.attr("href")) && href.replace(/.*(?=#[^\s]+$)/, ""));
        if (!$target.hasClass("carousel")) return;
        var options = $.extend({}, $target.data(), $this.data());
        var slideIndex = $this.attr("data-slide-to");
        if (slideIndex) options.interval = false;
        Plugin.call($target, options);
        if (slideIndex) {
            $target.data("bs.carousel").to(slideIndex);
        }
        e.preventDefault();
    };
    $(document).on("click.bs.carousel.data-api", "[data-slide]", clickHandler).on("click.bs.carousel.data-api", "[data-slide-to]", clickHandler);
    $(window).on("load", function() {
        $('[data-ride="carousel"]').each(function() {
            var $carousel = $(this);
            Plugin.call($carousel, $carousel.data());
        });
    });
}(jQuery);

+function($) {
    "use strict";
    var Collapse = function(element, options) {
        this.$element = $(element);
        this.options = $.extend({}, Collapse.DEFAULTS, options);
        this.$trigger = $('[data-toggle="collapse"][href="#' + element.id + '"],' + '[data-toggle="collapse"][data-target="#' + element.id + '"]');
        this.transitioning = null;
        if (this.options.parent) {
            this.$parent = this.getParent();
        } else {
            this.addAriaAndCollapsedClass(this.$element, this.$trigger);
        }
        if (this.options.toggle) this.toggle();
    };
    Collapse.VERSION = "3.3.6";
    Collapse.TRANSITION_DURATION = 350;
    Collapse.DEFAULTS = {
        toggle: true
    };
    Collapse.prototype.dimension = function() {
        var hasWidth = this.$element.hasClass("width");
        return hasWidth ? "width" : "height";
    };
    Collapse.prototype.show = function() {
        if (this.transitioning || this.$element.hasClass("in")) return;
        var activesData;
        var actives = this.$parent && this.$parent.children(".panel").children(".in, .collapsing");
        if (actives && actives.length) {
            activesData = actives.data("bs.collapse");
            if (activesData && activesData.transitioning) return;
        }
        var startEvent = $.Event("show.bs.collapse");
        this.$element.trigger(startEvent);
        if (startEvent.isDefaultPrevented()) return;
        if (actives && actives.length) {
            Plugin.call(actives, "hide");
            activesData || actives.data("bs.collapse", null);
        }
        var dimension = this.dimension();
        this.$element.removeClass("collapse").addClass("collapsing")[dimension](0).attr("aria-expanded", true);
        this.$trigger.removeClass("collapsed").attr("aria-expanded", true);
        this.transitioning = 1;
        var complete = function() {
            this.$element.removeClass("collapsing").addClass("collapse in")[dimension]("");
            this.transitioning = 0;
            this.$element.trigger("shown.bs.collapse");
        };
        if (!$.support.transition) return complete.call(this);
        var scrollSize = $.camelCase([ "scroll", dimension ].join("-"));
        this.$element.one("bsTransitionEnd", $.proxy(complete, this)).emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize]);
    };
    Collapse.prototype.hide = function() {
        if (this.transitioning || !this.$element.hasClass("in")) return;
        var startEvent = $.Event("hide.bs.collapse");
        this.$element.trigger(startEvent);
        if (startEvent.isDefaultPrevented()) return;
        var dimension = this.dimension();
        this.$element[dimension](this.$element[dimension]())[0].offsetHeight;
        this.$element.addClass("collapsing").removeClass("collapse in").attr("aria-expanded", false);
        this.$trigger.addClass("collapsed").attr("aria-expanded", false);
        this.transitioning = 1;
        var complete = function() {
            this.transitioning = 0;
            this.$element.removeClass("collapsing").addClass("collapse").trigger("hidden.bs.collapse");
        };
        if (!$.support.transition) return complete.call(this);
        this.$element[dimension](0).one("bsTransitionEnd", $.proxy(complete, this)).emulateTransitionEnd(Collapse.TRANSITION_DURATION);
    };
    Collapse.prototype.toggle = function() {
        this[this.$element.hasClass("in") ? "hide" : "show"]();
    };
    Collapse.prototype.getParent = function() {
        return $(this.options.parent).find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]').each($.proxy(function(i, element) {
            var $element = $(element);
            this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element);
        }, this)).end();
    };
    Collapse.prototype.addAriaAndCollapsedClass = function($element, $trigger) {
        var isOpen = $element.hasClass("in");
        $element.attr("aria-expanded", isOpen);
        $trigger.toggleClass("collapsed", !isOpen).attr("aria-expanded", isOpen);
    };
    function getTargetFromTrigger($trigger) {
        var href;
        var target = $trigger.attr("data-target") || (href = $trigger.attr("href")) && href.replace(/.*(?=#[^\s]+$)/, "");
        return $(target);
    }
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.collapse");
            var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == "object" && option);
            if (!data && options.toggle && /show|hide/.test(option)) options.toggle = false;
            if (!data) $this.data("bs.collapse", data = new Collapse(this, options));
            if (typeof option == "string") data[option]();
        });
    }
    var old = $.fn.collapse;
    $.fn.collapse = Plugin;
    $.fn.collapse.Constructor = Collapse;
    $.fn.collapse.noConflict = function() {
        $.fn.collapse = old;
        return this;
    };
    $(document).on("click.bs.collapse.data-api", '[data-toggle="collapse"]', function(e) {
        var $this = $(this);
        if (!$this.attr("data-target")) e.preventDefault();
        var $target = getTargetFromTrigger($this);
        var data = $target.data("bs.collapse");
        var option = data ? "toggle" : $this.data();
        Plugin.call($target, option);
    });
}(jQuery);

+function($) {
    "use strict";
    var backdrop = ".dropdown-backdrop";
    var toggle = '[data-toggle="dropdown"]';
    var Dropdown = function(element) {
        $(element).on("click.bs.dropdown", this.toggle);
    };
    Dropdown.VERSION = "3.3.6";
    function getParent($this) {
        var selector = $this.attr("data-target");
        if (!selector) {
            selector = $this.attr("href");
            selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, "");
        }
        var $parent = selector && $(selector);
        return $parent && $parent.length ? $parent : $this.parent();
    }
    function clearMenus(e) {
        if (e && e.which === 3) return;
        $(backdrop).remove();
        $(toggle).each(function() {
            var $this = $(this);
            var $parent = getParent($this);
            var relatedTarget = {
                relatedTarget: this
            };
            if (!$parent.hasClass("open")) return;
            if (e && e.type == "click" && /input|textarea/i.test(e.target.tagName) && $.contains($parent[0], e.target)) return;
            $parent.trigger(e = $.Event("hide.bs.dropdown", relatedTarget));
            if (e.isDefaultPrevented()) return;
            $this.attr("aria-expanded", "false");
            $parent.removeClass("open").trigger($.Event("hidden.bs.dropdown", relatedTarget));
        });
    }
    Dropdown.prototype.toggle = function(e) {
        var $this = $(this);
        if ($this.is(".disabled, :disabled")) return;
        var $parent = getParent($this);
        var isActive = $parent.hasClass("open");
        clearMenus();
        if (!isActive) {
            if ("ontouchstart" in document.documentElement && !$parent.closest(".navbar-nav").length) {
                $(document.createElement("div")).addClass("dropdown-backdrop").insertAfter($(this)).on("click", clearMenus);
            }
            var relatedTarget = {
                relatedTarget: this
            };
            $parent.trigger(e = $.Event("show.bs.dropdown", relatedTarget));
            if (e.isDefaultPrevented()) return;
            $this.trigger("focus").attr("aria-expanded", "true");
            $parent.toggleClass("open").trigger($.Event("shown.bs.dropdown", relatedTarget));
        }
        return false;
    };
    Dropdown.prototype.keydown = function(e) {
        if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return;
        var $this = $(this);
        e.preventDefault();
        e.stopPropagation();
        if ($this.is(".disabled, :disabled")) return;
        var $parent = getParent($this);
        var isActive = $parent.hasClass("open");
        if (!isActive && e.which != 27 || isActive && e.which == 27) {
            if (e.which == 27) $parent.find(toggle).trigger("focus");
            return $this.trigger("click");
        }
        var desc = " li:not(.disabled):visible a";
        var $items = $parent.find(".dropdown-menu" + desc);
        if (!$items.length) return;
        var index = $items.index(e.target);
        if (e.which == 38 && index > 0) index--;
        if (e.which == 40 && index < $items.length - 1) index++;
        if (!~index) index = 0;
        $items.eq(index).trigger("focus");
    };
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.dropdown");
            if (!data) $this.data("bs.dropdown", data = new Dropdown(this));
            if (typeof option == "string") data[option].call($this);
        });
    }
    var old = $.fn.dropdown;
    $.fn.dropdown = Plugin;
    $.fn.dropdown.Constructor = Dropdown;
    $.fn.dropdown.noConflict = function() {
        $.fn.dropdown = old;
        return this;
    };
    $(document).on("click.bs.dropdown.data-api", clearMenus).on("click.bs.dropdown.data-api", ".dropdown form", function(e) {
        e.stopPropagation();
    }).on("click.bs.dropdown.data-api", toggle, Dropdown.prototype.toggle).on("keydown.bs.dropdown.data-api", toggle, Dropdown.prototype.keydown).on("keydown.bs.dropdown.data-api", ".dropdown-menu", Dropdown.prototype.keydown);
}(jQuery);

+function($) {
    "use strict";
    var Modal = function(element, options) {
        this.options = options;
        this.$body = $(document.body);
        this.$element = $(element);
        this.$dialog = this.$element.find(".modal-dialog");
        this.$backdrop = null;
        this.isShown = null;
        this.originalBodyPad = null;
        this.scrollbarWidth = 0;
        this.ignoreBackdropClick = false;
        if (this.options.remote) {
            this.$element.find(".modal-content").load(this.options.remote, $.proxy(function() {
                this.$element.trigger("loaded.bs.modal");
            }, this));
        }
    };
    Modal.VERSION = "3.3.6";
    Modal.TRANSITION_DURATION = 300;
    Modal.BACKDROP_TRANSITION_DURATION = 150;
    Modal.DEFAULTS = {
        backdrop: true,
        keyboard: true,
        show: true
    };
    Modal.prototype.toggle = function(_relatedTarget) {
        return this.isShown ? this.hide() : this.show(_relatedTarget);
    };
    Modal.prototype.show = function(_relatedTarget) {
        var that = this;
        var e = $.Event("show.bs.modal", {
            relatedTarget: _relatedTarget
        });
        this.$element.trigger(e);
        if (this.isShown || e.isDefaultPrevented()) return;
        this.isShown = true;
        this.checkScrollbar();
        this.setScrollbar();
        this.$body.addClass("modal-open");
        this.escape();
        this.resize();
        this.$element.on("click.dismiss.bs.modal", '[data-dismiss="modal"]', $.proxy(this.hide, this));
        this.$dialog.on("mousedown.dismiss.bs.modal", function() {
            that.$element.one("mouseup.dismiss.bs.modal", function(e) {
                if ($(e.target).is(that.$element)) that.ignoreBackdropClick = true;
            });
        });
        this.backdrop(function() {
            var transition = $.support.transition && that.$element.hasClass("fade");
            if (!that.$element.parent().length) {
                that.$element.appendTo(that.$body);
            }
            that.$element.show().scrollTop(0);
            that.adjustDialog();
            if (transition) {
                that.$element[0].offsetWidth;
            }
            that.$element.addClass("in");
            that.enforceFocus();
            var e = $.Event("shown.bs.modal", {
                relatedTarget: _relatedTarget
            });
            transition ? that.$dialog.one("bsTransitionEnd", function() {
                that.$element.trigger("focus").trigger(e);
            }).emulateTransitionEnd(Modal.TRANSITION_DURATION) : that.$element.trigger("focus").trigger(e);
        });
    };
    Modal.prototype.hide = function(e) {
        if (e) e.preventDefault();
        e = $.Event("hide.bs.modal");
        this.$element.trigger(e);
        if (!this.isShown || e.isDefaultPrevented()) return;
        this.isShown = false;
        this.escape();
        this.resize();
        $(document).off("focusin.bs.modal");
        this.$element.removeClass("in").off("click.dismiss.bs.modal").off("mouseup.dismiss.bs.modal");
        this.$dialog.off("mousedown.dismiss.bs.modal");
        $.support.transition && this.$element.hasClass("fade") ? this.$element.one("bsTransitionEnd", $.proxy(this.hideModal, this)).emulateTransitionEnd(Modal.TRANSITION_DURATION) : this.hideModal();
    };
    Modal.prototype.enforceFocus = function() {
        $(document).off("focusin.bs.modal").on("focusin.bs.modal", $.proxy(function(e) {
            if (this.$element[0] !== e.target && !this.$element.has(e.target).length) {
                this.$element.trigger("focus");
            }
        }, this));
    };
    Modal.prototype.escape = function() {
        if (this.isShown && this.options.keyboard) {
            this.$element.on("keydown.dismiss.bs.modal", $.proxy(function(e) {
                e.which == 27 && this.hide();
            }, this));
        } else if (!this.isShown) {
            this.$element.off("keydown.dismiss.bs.modal");
        }
    };
    Modal.prototype.resize = function() {
        if (this.isShown) {
            $(window).on("resize.bs.modal", $.proxy(this.handleUpdate, this));
        } else {
            $(window).off("resize.bs.modal");
        }
    };
    Modal.prototype.hideModal = function() {
        var that = this;
        this.$element.hide();
        this.backdrop(function() {
            that.$body.removeClass("modal-open");
            that.resetAdjustments();
            that.resetScrollbar();
            that.$element.trigger("hidden.bs.modal");
        });
    };
    Modal.prototype.removeBackdrop = function() {
        this.$backdrop && this.$backdrop.remove();
        this.$backdrop = null;
    };
    Modal.prototype.backdrop = function(callback) {
        var that = this;
        var animate = this.$element.hasClass("fade") ? "fade" : "";
        if (this.isShown && this.options.backdrop) {
            var doAnimate = $.support.transition && animate;
            this.$backdrop = $(document.createElement("div")).addClass("modal-backdrop " + animate).appendTo(this.$body);
            this.$element.on("click.dismiss.bs.modal", $.proxy(function(e) {
                if (this.ignoreBackdropClick) {
                    this.ignoreBackdropClick = false;
                    return;
                }
                if (e.target !== e.currentTarget) return;
                this.options.backdrop == "static" ? this.$element[0].focus() : this.hide();
            }, this));
            if (doAnimate) this.$backdrop[0].offsetWidth;
            this.$backdrop.addClass("in");
            if (!callback) return;
            doAnimate ? this.$backdrop.one("bsTransitionEnd", callback).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callback();
        } else if (!this.isShown && this.$backdrop) {
            this.$backdrop.removeClass("in");
            var callbackRemove = function() {
                that.removeBackdrop();
                callback && callback();
            };
            $.support.transition && this.$element.hasClass("fade") ? this.$backdrop.one("bsTransitionEnd", callbackRemove).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callbackRemove();
        } else if (callback) {
            callback();
        }
    };
    Modal.prototype.handleUpdate = function() {
        this.adjustDialog();
    };
    Modal.prototype.adjustDialog = function() {
        var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight;
        this.$element.css({
            paddingLeft: !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : "",
            paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ""
        });
    };
    Modal.prototype.resetAdjustments = function() {
        this.$element.css({
            paddingLeft: "",
            paddingRight: ""
        });
    };
    Modal.prototype.checkScrollbar = function() {
        var fullWindowWidth = window.innerWidth;
        if (!fullWindowWidth) {
            var documentElementRect = document.documentElement.getBoundingClientRect();
            fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left);
        }
        this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth;
        this.scrollbarWidth = this.measureScrollbar();
    };
    Modal.prototype.setScrollbar = function() {
        var bodyPad = parseInt(this.$body.css("padding-right") || 0, 10);
        this.originalBodyPad = document.body.style.paddingRight || "";
        if (this.bodyIsOverflowing) this.$body.css("padding-right", bodyPad + this.scrollbarWidth);
    };
    Modal.prototype.resetScrollbar = function() {
        this.$body.css("padding-right", this.originalBodyPad);
    };
    Modal.prototype.measureScrollbar = function() {
        var scrollDiv = document.createElement("div");
        scrollDiv.className = "modal-scrollbar-measure";
        this.$body.append(scrollDiv);
        var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
        this.$body[0].removeChild(scrollDiv);
        return scrollbarWidth;
    };
    function Plugin(option, _relatedTarget) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.modal");
            var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == "object" && option);
            if (!data) $this.data("bs.modal", data = new Modal(this, options));
            if (typeof option == "string") data[option](_relatedTarget); else if (options.show) data.show(_relatedTarget);
        });
    }
    var old = $.fn.modal;
    $.fn.modal = Plugin;
    $.fn.modal.Constructor = Modal;
    $.fn.modal.noConflict = function() {
        $.fn.modal = old;
        return this;
    };
    $(document).on("click.bs.modal.data-api", '[data-toggle="modal"]', function(e) {
        var $this = $(this);
        var href = $this.attr("href");
        var $target = $($this.attr("data-target") || href && href.replace(/.*(?=#[^\s]+$)/, ""));
        var option = $target.data("bs.modal") ? "toggle" : $.extend({
            remote: !/#/.test(href) && href
        }, $target.data(), $this.data());
        if ($this.is("a")) e.preventDefault();
        $target.one("show.bs.modal", function(showEvent) {
            if (showEvent.isDefaultPrevented()) return;
            $target.one("hidden.bs.modal", function() {
                $this.is(":visible") && $this.trigger("focus");
            });
        });
        Plugin.call($target, option, this);
    });
}(jQuery);

+function($) {
    "use strict";
    var Tooltip = function(element, options) {
        this.type = null;
        this.options = null;
        this.enabled = null;
        this.timeout = null;
        this.hoverState = null;
        this.$element = null;
        this.inState = null;
        this.init("tooltip", element, options);
    };
    Tooltip.VERSION = "3.3.6";
    Tooltip.TRANSITION_DURATION = 150;
    Tooltip.DEFAULTS = {
        animation: true,
        placement: "top",
        selector: false,
        template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
        trigger: "hover focus",
        title: "",
        delay: 0,
        html: false,
        container: false,
        viewport: {
            selector: "body",
            padding: 0
        }
    };
    Tooltip.prototype.init = function(type, element, options) {
        this.enabled = true;
        this.type = type;
        this.$element = $(element);
        this.options = this.getOptions(options);
        this.$viewport = this.options.viewport && $($.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : this.options.viewport.selector || this.options.viewport);
        this.inState = {
            click: false,
            hover: false,
            focus: false
        };
        if (this.$element[0] instanceof document.constructor && !this.options.selector) {
            throw new Error("`selector` option must be specified when initializing " + this.type + " on the window.document object!");
        }
        var triggers = this.options.trigger.split(" ");
        for (var i = triggers.length; i--; ) {
            var trigger = triggers[i];
            if (trigger == "click") {
                this.$element.on("click." + this.type, this.options.selector, $.proxy(this.toggle, this));
            } else if (trigger != "manual") {
                var eventIn = trigger == "hover" ? "mouseenter" : "focusin";
                var eventOut = trigger == "hover" ? "mouseleave" : "focusout";
                this.$element.on(eventIn + "." + this.type, this.options.selector, $.proxy(this.enter, this));
                this.$element.on(eventOut + "." + this.type, this.options.selector, $.proxy(this.leave, this));
            }
        }
        this.options.selector ? this._options = $.extend({}, this.options, {
            trigger: "manual",
            selector: ""
        }) : this.fixTitle();
    };
    Tooltip.prototype.getDefaults = function() {
        return Tooltip.DEFAULTS;
    };
    Tooltip.prototype.getOptions = function(options) {
        options = $.extend({}, this.getDefaults(), this.$element.data(), options);
        if (options.delay && typeof options.delay == "number") {
            options.delay = {
                show: options.delay,
                hide: options.delay
            };
        }
        return options;
    };
    Tooltip.prototype.getDelegateOptions = function() {
        var options = {};
        var defaults = this.getDefaults();
        this._options && $.each(this._options, function(key, value) {
            if (defaults[key] != value) options[key] = value;
        });
        return options;
    };
    Tooltip.prototype.enter = function(obj) {
        var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data("bs." + this.type);
        if (!self) {
            self = new this.constructor(obj.currentTarget, this.getDelegateOptions());
            $(obj.currentTarget).data("bs." + this.type, self);
        }
        if (obj instanceof $.Event) {
            self.inState[obj.type == "focusin" ? "focus" : "hover"] = true;
        }
        if (self.tip().hasClass("in") || self.hoverState == "in") {
            self.hoverState = "in";
            return;
        }
        clearTimeout(self.timeout);
        self.hoverState = "in";
        if (!self.options.delay || !self.options.delay.show) return self.show();
        self.timeout = setTimeout(function() {
            if (self.hoverState == "in") self.show();
        }, self.options.delay.show);
    };
    Tooltip.prototype.isInStateTrue = function() {
        for (var key in this.inState) {
            if (this.inState[key]) return true;
        }
        return false;
    };
    Tooltip.prototype.leave = function(obj) {
        var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data("bs." + this.type);
        if (!self) {
            self = new this.constructor(obj.currentTarget, this.getDelegateOptions());
            $(obj.currentTarget).data("bs." + this.type, self);
        }
        if (obj instanceof $.Event) {
            self.inState[obj.type == "focusout" ? "focus" : "hover"] = false;
        }
        if (self.isInStateTrue()) return;
        clearTimeout(self.timeout);
        self.hoverState = "out";
        if (!self.options.delay || !self.options.delay.hide) return self.hide();
        self.timeout = setTimeout(function() {
            if (self.hoverState == "out") self.hide();
        }, self.options.delay.hide);
    };
    Tooltip.prototype.show = function() {
        var e = $.Event("show.bs." + this.type);
        if (this.hasContent() && this.enabled) {
            this.$element.trigger(e);
            var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0]);
            if (e.isDefaultPrevented() || !inDom) return;
            var that = this;
            var $tip = this.tip();
            var tipId = this.getUID(this.type);
            this.setContent();
            $tip.attr("id", tipId);
            this.$element.attr("aria-describedby", tipId);
            if (this.options.animation) $tip.addClass("fade");
            var placement = typeof this.options.placement == "function" ? this.options.placement.call(this, $tip[0], this.$element[0]) : this.options.placement;
            var autoToken = /\s?auto?\s?/i;
            var autoPlace = autoToken.test(placement);
            if (autoPlace) placement = placement.replace(autoToken, "") || "top";
            $tip.detach().css({
                top: 0,
                left: 0,
                display: "block"
            }).addClass(placement).data("bs." + this.type, this);
            this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element);
            this.$element.trigger("inserted.bs." + this.type);
            var pos = this.getPosition();
            var actualWidth = $tip[0].offsetWidth;
            var actualHeight = $tip[0].offsetHeight;
            if (autoPlace) {
                var orgPlacement = placement;
                var viewportDim = this.getPosition(this.$viewport);
                placement = placement == "bottom" && pos.bottom + actualHeight > viewportDim.bottom ? "top" : placement == "top" && pos.top - actualHeight < viewportDim.top ? "bottom" : placement == "right" && pos.right + actualWidth > viewportDim.width ? "left" : placement == "left" && pos.left - actualWidth < viewportDim.left ? "right" : placement;
                $tip.removeClass(orgPlacement).addClass(placement);
            }
            var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight);
            this.applyPlacement(calculatedOffset, placement);
            var complete = function() {
                var prevHoverState = that.hoverState;
                that.$element.trigger("shown.bs." + that.type);
                that.hoverState = null;
                if (prevHoverState == "out") that.leave(that);
            };
            $.support.transition && this.$tip.hasClass("fade") ? $tip.one("bsTransitionEnd", complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete();
        }
    };
    Tooltip.prototype.applyPlacement = function(offset, placement) {
        var $tip = this.tip();
        var width = $tip[0].offsetWidth;
        var height = $tip[0].offsetHeight;
        var marginTop = parseInt($tip.css("margin-top"), 10);
        var marginLeft = parseInt($tip.css("margin-left"), 10);
        if (isNaN(marginTop)) marginTop = 0;
        if (isNaN(marginLeft)) marginLeft = 0;
        offset.top += marginTop;
        offset.left += marginLeft;
        $.offset.setOffset($tip[0], $.extend({
            using: function(props) {
                $tip.css({
                    top: Math.round(props.top),
                    left: Math.round(props.left)
                });
            }
        }, offset), 0);
        $tip.addClass("in");
        var actualWidth = $tip[0].offsetWidth;
        var actualHeight = $tip[0].offsetHeight;
        if (placement == "top" && actualHeight != height) {
            offset.top = offset.top + height - actualHeight;
        }
        var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);
        if (delta.left) offset.left += delta.left; else offset.top += delta.top;
        var isVertical = /top|bottom/.test(placement);
        var arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight;
        var arrowOffsetPosition = isVertical ? "offsetWidth" : "offsetHeight";
        $tip.offset(offset);
        this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical);
    };
    Tooltip.prototype.replaceArrow = function(delta, dimension, isVertical) {
        this.arrow().css(isVertical ? "left" : "top", 50 * (1 - delta / dimension) + "%").css(isVertical ? "top" : "left", "");
    };
    Tooltip.prototype.setContent = function() {
        var $tip = this.tip();
        var title = this.getTitle();
        $tip.find(".tooltip-inner")[this.options.html ? "html" : "text"](title);
        $tip.removeClass("fade in top bottom left right");
    };
    Tooltip.prototype.hide = function(callback) {
        var that = this;
        var $tip = $(this.$tip);
        var e = $.Event("hide.bs." + this.type);
        function complete() {
            if (that.hoverState != "in") $tip.detach();
            that.$element.removeAttr("aria-describedby").trigger("hidden.bs." + that.type);
            callback && callback();
        }
        this.$element.trigger(e);
        if (e.isDefaultPrevented()) return;
        $tip.removeClass("in");
        $.support.transition && $tip.hasClass("fade") ? $tip.one("bsTransitionEnd", complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete();
        this.hoverState = null;
        return this;
    };
    Tooltip.prototype.fixTitle = function() {
        var $e = this.$element;
        if ($e.attr("title") || typeof $e.attr("data-original-title") != "string") {
            $e.attr("data-original-title", $e.attr("title") || "").attr("title", "");
        }
    };
    Tooltip.prototype.hasContent = function() {
        return this.getTitle();
    };
    Tooltip.prototype.getPosition = function($element) {
        $element = $element || this.$element;
        var el = $element[0];
        var isBody = el.tagName == "BODY";
        var elRect = el.getBoundingClientRect();
        if (elRect.width == null) {
            elRect = $.extend({}, elRect, {
                width: elRect.right - elRect.left,
                height: elRect.bottom - elRect.top
            });
        }
        var elOffset = isBody ? {
            top: 0,
            left: 0
        } : $element.offset();
        var scroll = {
            scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop()
        };
        var outerDims = isBody ? {
            width: $(window).width(),
            height: $(window).height()
        } : null;
        return $.extend({}, elRect, scroll, outerDims, elOffset);
    };
    Tooltip.prototype.getCalculatedOffset = function(placement, pos, actualWidth, actualHeight) {
        return placement == "bottom" ? {
            top: pos.top + pos.height,
            left: pos.left + pos.width / 2 - actualWidth / 2
        } : placement == "top" ? {
            top: pos.top - actualHeight,
            left: pos.left + pos.width / 2 - actualWidth / 2
        } : placement == "left" ? {
            top: pos.top + pos.height / 2 - actualHeight / 2,
            left: pos.left - actualWidth
        } : {
            top: pos.top + pos.height / 2 - actualHeight / 2,
            left: pos.left + pos.width
        };
    };
    Tooltip.prototype.getViewportAdjustedDelta = function(placement, pos, actualWidth, actualHeight) {
        var delta = {
            top: 0,
            left: 0
        };
        if (!this.$viewport) return delta;
        var viewportPadding = this.options.viewport && this.options.viewport.padding || 0;
        var viewportDimensions = this.getPosition(this.$viewport);
        if (/right|left/.test(placement)) {
            var topEdgeOffset = pos.top - viewportPadding - viewportDimensions.scroll;
            var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight;
            if (topEdgeOffset < viewportDimensions.top) {
                delta.top = viewportDimensions.top - topEdgeOffset;
            } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) {
                delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;
            }
        } else {
            var leftEdgeOffset = pos.left - viewportPadding;
            var rightEdgeOffset = pos.left + viewportPadding + actualWidth;
            if (leftEdgeOffset < viewportDimensions.left) {
                delta.left = viewportDimensions.left - leftEdgeOffset;
            } else if (rightEdgeOffset > viewportDimensions.right) {
                delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;
            }
        }
        return delta;
    };
    Tooltip.prototype.getTitle = function() {
        var title;
        var $e = this.$element;
        var o = this.options;
        title = $e.attr("data-original-title") || (typeof o.title == "function" ? o.title.call($e[0]) : o.title);
        return title;
    };
    Tooltip.prototype.getUID = function(prefix) {
        do prefix += ~~(Math.random() * 1e6); while (document.getElementById(prefix));
        return prefix;
    };
    Tooltip.prototype.tip = function() {
        if (!this.$tip) {
            this.$tip = $(this.options.template);
            if (this.$tip.length != 1) {
                throw new Error(this.type + " `template` option must consist of exactly 1 top-level element!");
            }
        }
        return this.$tip;
    };
    Tooltip.prototype.arrow = function() {
        return this.$arrow = this.$arrow || this.tip().find(".tooltip-arrow");
    };
    Tooltip.prototype.enable = function() {
        this.enabled = true;
    };
    Tooltip.prototype.disable = function() {
        this.enabled = false;
    };
    Tooltip.prototype.toggleEnabled = function() {
        this.enabled = !this.enabled;
    };
    Tooltip.prototype.toggle = function(e) {
        var self = this;
        if (e) {
            self = $(e.currentTarget).data("bs." + this.type);
            if (!self) {
                self = new this.constructor(e.currentTarget, this.getDelegateOptions());
                $(e.currentTarget).data("bs." + this.type, self);
            }
        }
        if (e) {
            self.inState.click = !self.inState.click;
            if (self.isInStateTrue()) self.enter(self); else self.leave(self);
        } else {
            self.tip().hasClass("in") ? self.leave(self) : self.enter(self);
        }
    };
    Tooltip.prototype.destroy = function() {
        var that = this;
        clearTimeout(this.timeout);
        this.hide(function() {
            that.$element.off("." + that.type).removeData("bs." + that.type);
            if (that.$tip) {
                that.$tip.detach();
            }
            that.$tip = null;
            that.$arrow = null;
            that.$viewport = null;
        });
    };
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.tooltip");
            var options = typeof option == "object" && option;
            if (!data && /destroy|hide/.test(option)) return;
            if (!data) $this.data("bs.tooltip", data = new Tooltip(this, options));
            if (typeof option == "string") data[option]();
        });
    }
    var old = $.fn.tooltip;
    $.fn.tooltip = Plugin;
    $.fn.tooltip.Constructor = Tooltip;
    $.fn.tooltip.noConflict = function() {
        $.fn.tooltip = old;
        return this;
    };
}(jQuery);

+function($) {
    "use strict";
    var Popover = function(element, options) {
        this.init("popover", element, options);
    };
    if (!$.fn.tooltip) throw new Error("Popover requires tooltip.js");
    Popover.VERSION = "3.3.6";
    Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
        placement: "right",
        trigger: "click",
        content: "",
        template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
    });
    Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype);
    Popover.prototype.constructor = Popover;
    Popover.prototype.getDefaults = function() {
        return Popover.DEFAULTS;
    };
    Popover.prototype.setContent = function() {
        var $tip = this.tip();
        var title = this.getTitle();
        var content = this.getContent();
        $tip.find(".popover-title")[this.options.html ? "html" : "text"](title);
        $tip.find(".popover-content").children().detach().end()[this.options.html ? typeof content == "string" ? "html" : "append" : "text"](content);
        $tip.removeClass("fade top bottom left right in");
        if (!$tip.find(".popover-title").html()) $tip.find(".popover-title").hide();
    };
    Popover.prototype.hasContent = function() {
        return this.getTitle() || this.getContent();
    };
    Popover.prototype.getContent = function() {
        var $e = this.$element;
        var o = this.options;
        return $e.attr("data-content") || (typeof o.content == "function" ? o.content.call($e[0]) : o.content);
    };
    Popover.prototype.arrow = function() {
        return this.$arrow = this.$arrow || this.tip().find(".arrow");
    };
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.popover");
            var options = typeof option == "object" && option;
            if (!data && /destroy|hide/.test(option)) return;
            if (!data) $this.data("bs.popover", data = new Popover(this, options));
            if (typeof option == "string") data[option]();
        });
    }
    var old = $.fn.popover;
    $.fn.popover = Plugin;
    $.fn.popover.Constructor = Popover;
    $.fn.popover.noConflict = function() {
        $.fn.popover = old;
        return this;
    };
}(jQuery);

+function($) {
    "use strict";
    function ScrollSpy(element, options) {
        this.$body = $(document.body);
        this.$scrollElement = $(element).is(document.body) ? $(window) : $(element);
        this.options = $.extend({}, ScrollSpy.DEFAULTS, options);
        this.selector = (this.options.target || "") + " .nav li > a";
        this.offsets = [];
        this.targets = [];
        this.activeTarget = null;
        this.scrollHeight = 0;
        this.$scrollElement.on("scroll.bs.scrollspy", $.proxy(this.process, this));
        this.refresh();
        this.process();
    }
    ScrollSpy.VERSION = "3.3.6";
    ScrollSpy.DEFAULTS = {
        offset: 10
    };
    ScrollSpy.prototype.getScrollHeight = function() {
        return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight);
    };
    ScrollSpy.prototype.refresh = function() {
        var that = this;
        var offsetMethod = "offset";
        var offsetBase = 0;
        this.offsets = [];
        this.targets = [];
        this.scrollHeight = this.getScrollHeight();
        if (!$.isWindow(this.$scrollElement[0])) {
            offsetMethod = "position";
            offsetBase = this.$scrollElement.scrollTop();
        }
        this.$body.find(this.selector).map(function() {
            var $el = $(this);
            var href = $el.data("target") || $el.attr("href");
            var $href = /^#./.test(href) && $(href);
            return $href && $href.length && $href.is(":visible") && [ [ $href[offsetMethod]().top + offsetBase, href ] ] || null;
        }).sort(function(a, b) {
            return a[0] - b[0];
        }).each(function() {
            that.offsets.push(this[0]);
            that.targets.push(this[1]);
        });
    };
    ScrollSpy.prototype.process = function() {
        var scrollTop = this.$scrollElement.scrollTop() + this.options.offset;
        var scrollHeight = this.getScrollHeight();
        var maxScroll = this.options.offset + scrollHeight - this.$scrollElement.height();
        var offsets = this.offsets;
        var targets = this.targets;
        var activeTarget = this.activeTarget;
        var i;
        if (this.scrollHeight != scrollHeight) {
            this.refresh();
        }
        if (scrollTop >= maxScroll) {
            return activeTarget != (i = targets[targets.length - 1]) && this.activate(i);
        }
        if (activeTarget && scrollTop < offsets[0]) {
            this.activeTarget = null;
            return this.clear();
        }
        for (i = offsets.length; i--; ) {
            activeTarget != targets[i] && scrollTop >= offsets[i] && (offsets[i + 1] === undefined || scrollTop < offsets[i + 1]) && this.activate(targets[i]);
        }
    };
    ScrollSpy.prototype.activate = function(target) {
        this.activeTarget = target;
        this.clear();
        var selector = this.selector + '[data-target="' + target + '"],' + this.selector + '[href="' + target + '"]';
        var active = $(selector).parents("li").addClass("active");
        if (active.parent(".dropdown-menu").length) {
            active = active.closest("li.dropdown").addClass("active");
        }
        active.trigger("activate.bs.scrollspy");
    };
    ScrollSpy.prototype.clear = function() {
        $(this.selector).parentsUntil(this.options.target, ".active").removeClass("active");
    };
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.scrollspy");
            var options = typeof option == "object" && option;
            if (!data) $this.data("bs.scrollspy", data = new ScrollSpy(this, options));
            if (typeof option == "string") data[option]();
        });
    }
    var old = $.fn.scrollspy;
    $.fn.scrollspy = Plugin;
    $.fn.scrollspy.Constructor = ScrollSpy;
    $.fn.scrollspy.noConflict = function() {
        $.fn.scrollspy = old;
        return this;
    };
    $(window).on("load.bs.scrollspy.data-api", function() {
        $('[data-spy="scroll"]').each(function() {
            var $spy = $(this);
            Plugin.call($spy, $spy.data());
        });
    });
}(jQuery);

+function($) {
    "use strict";
    var Tab = function(element) {
        this.element = $(element);
    };
    Tab.VERSION = "3.3.6";
    Tab.TRANSITION_DURATION = 150;
    Tab.prototype.show = function() {
        var $this = this.element;
        var $ul = $this.closest("ul:not(.dropdown-menu)");
        var selector = $this.data("target");
        if (!selector) {
            selector = $this.attr("href");
            selector = selector && selector.replace(/.*(?=#[^\s]*$)/, "");
        }
        if ($this.parent("li").hasClass("active")) return;
        var $previous = $ul.find(".active:last a");
        var hideEvent = $.Event("hide.bs.tab", {
            relatedTarget: $this[0]
        });
        var showEvent = $.Event("show.bs.tab", {
            relatedTarget: $previous[0]
        });
        $previous.trigger(hideEvent);
        $this.trigger(showEvent);
        if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return;
        var $target = $(selector);
        this.activate($this.closest("li"), $ul);
        this.activate($target, $target.parent(), function() {
            $previous.trigger({
                type: "hidden.bs.tab",
                relatedTarget: $this[0]
            });
            $this.trigger({
                type: "shown.bs.tab",
                relatedTarget: $previous[0]
            });
        });
    };
    Tab.prototype.activate = function(element, container, callback) {
        var $active = container.find("> .active");
        var transition = callback && $.support.transition && ($active.length && $active.hasClass("fade") || !!container.find("> .fade").length);
        function next() {
            $active.removeClass("active").find("> .dropdown-menu > .active").removeClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", false);
            element.addClass("active").find('[data-toggle="tab"]').attr("aria-expanded", true);
            if (transition) {
                element[0].offsetWidth;
                element.addClass("in");
            } else {
                element.removeClass("fade");
            }
            if (element.parent(".dropdown-menu").length) {
                element.closest("li.dropdown").addClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", true);
            }
            callback && callback();
        }
        $active.length && transition ? $active.one("bsTransitionEnd", next).emulateTransitionEnd(Tab.TRANSITION_DURATION) : next();
        $active.removeClass("in");
    };
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.tab");
            if (!data) $this.data("bs.tab", data = new Tab(this));
            if (typeof option == "string") data[option]();
        });
    }
    var old = $.fn.tab;
    $.fn.tab = Plugin;
    $.fn.tab.Constructor = Tab;
    $.fn.tab.noConflict = function() {
        $.fn.tab = old;
        return this;
    };
    var clickHandler = function(e) {
        e.preventDefault();
        Plugin.call($(this), "show");
    };
    $(document).on("click.bs.tab.data-api", '[data-toggle="tab"]', clickHandler).on("click.bs.tab.data-api", '[data-toggle="pill"]', clickHandler);
}(jQuery);

+function($) {
    "use strict";
    var Affix = function(element, options) {
        this.options = $.extend({}, Affix.DEFAULTS, options);
        this.$target = $(this.options.target).on("scroll.bs.affix.data-api", $.proxy(this.checkPosition, this)).on("click.bs.affix.data-api", $.proxy(this.checkPositionWithEventLoop, this));
        this.$element = $(element);
        this.affixed = null;
        this.unpin = null;
        this.pinnedOffset = null;
        this.checkPosition();
    };
    Affix.VERSION = "3.3.6";
    Affix.RESET = "affix affix-top affix-bottom";
    Affix.DEFAULTS = {
        offset: 0,
        target: window
    };
    Affix.prototype.getState = function(scrollHeight, height, offsetTop, offsetBottom) {
        var scrollTop = this.$target.scrollTop();
        var position = this.$element.offset();
        var targetHeight = this.$target.height();
        if (offsetTop != null && this.affixed == "top") return scrollTop < offsetTop ? "top" : false;
        if (this.affixed == "bottom") {
            if (offsetTop != null) return scrollTop + this.unpin <= position.top ? false : "bottom";
            return scrollTop + targetHeight <= scrollHeight - offsetBottom ? false : "bottom";
        }
        var initializing = this.affixed == null;
        var colliderTop = initializing ? scrollTop : position.top;
        var colliderHeight = initializing ? targetHeight : height;
        if (offsetTop != null && scrollTop <= offsetTop) return "top";
        if (offsetBottom != null && colliderTop + colliderHeight >= scrollHeight - offsetBottom) return "bottom";
        return false;
    };
    Affix.prototype.getPinnedOffset = function() {
        if (this.pinnedOffset) return this.pinnedOffset;
        this.$element.removeClass(Affix.RESET).addClass("affix");
        var scrollTop = this.$target.scrollTop();
        var position = this.$element.offset();
        return this.pinnedOffset = position.top - scrollTop;
    };
    Affix.prototype.checkPositionWithEventLoop = function() {
        setTimeout($.proxy(this.checkPosition, this), 1);
    };
    Affix.prototype.checkPosition = function() {
        if (!this.$element.is(":visible")) return;
        var height = this.$element.height();
        var offset = this.options.offset;
        var offsetTop = offset.top;
        var offsetBottom = offset.bottom;
        var scrollHeight = Math.max($(document).height(), $(document.body).height());
        if (typeof offset != "object") offsetBottom = offsetTop = offset;
        if (typeof offsetTop == "function") offsetTop = offset.top(this.$element);
        if (typeof offsetBottom == "function") offsetBottom = offset.bottom(this.$element);
        var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom);
        if (this.affixed != affix) {
            if (this.unpin != null) this.$element.css("top", "");
            var affixType = "affix" + (affix ? "-" + affix : "");
            var e = $.Event(affixType + ".bs.affix");
            this.$element.trigger(e);
            if (e.isDefaultPrevented()) return;
            this.affixed = affix;
            this.unpin = affix == "bottom" ? this.getPinnedOffset() : null;
            this.$element.removeClass(Affix.RESET).addClass(affixType).trigger(affixType.replace("affix", "affixed") + ".bs.affix");
        }
        if (affix == "bottom") {
            this.$element.offset({
                top: scrollHeight - height - offsetBottom
            });
        }
    };
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.affix");
            var options = typeof option == "object" && option;
            if (!data) $this.data("bs.affix", data = new Affix(this, options));
            if (typeof option == "string") data[option]();
        });
    }
    var old = $.fn.affix;
    $.fn.affix = Plugin;
    $.fn.affix.Constructor = Affix;
    $.fn.affix.noConflict = function() {
        $.fn.affix = old;
        return this;
    };
    $(window).on("load", function() {
        $('[data-spy="affix"]').each(function() {
            var $spy = $(this);
            var data = $spy.data();
            data.offset = data.offset || {};
            if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom;
            if (data.offsetTop != null) data.offset.top = data.offsetTop;
            Plugin.call($spy, data);
        });
    });
}(jQuery);

$(document).ready(function() {
    if (!Cookies.get("popup-submitted")) {
        if (!Cookies.get("popup")) {
            if ($(".popup-container").length > 0) {
                setTimeout(initializePopup, 3e3);
                Cookies.set("popup", "1", null);
                gtag("event", "Popup Shown", {
                    event_category: "Popups",
                    event_label: $(".popup-container").data("event-label")
                });
            }
        }
    }
    var frm = $("#popup-form");
    if (typeof frm !== "undefined") {
        frm.validate();
        frm.submit(function(e) {
            e.stopPropagation();
            e.preventDefault();
            var isValid = $(this).validate().form();
            if (!isValid) return false;
            $(this).find(".popup-button").attr("disabled", true);
            $.ajax({
                type: $(this).attr("method"),
                url: $(this).attr("action"),
                data: $(this).serialize(),
                success: function(data) {
                    if (!data.success) {
                        $(".popup-form").hide();
                        $(".popup-error-container").show();
                    } else if (data.redirect) {
                        $(".popup-redirect-container").html(data.redirect);
                    } else {
                        $(".popup-form").hide();
                        $(".popup-thanks-container").show();
                        Cookies.set("popup-submitted", "1", {
                            expires: 365
                        });
                    }
                },
                error: function(data) {
                    $(".popup-form").hide();
                    $(".popup-error-container").show();
                }
            });
        });
    }
});

function initializePopup() {
    lightboxForm = $.featherlight(".popup-container", {
        variant: "sitewide-popup",
        afterContent: function() {
            $(".featherlight-content").find('a, input[type!="hidden"], select, textarea, iframe, button:not(.featherlight-close), iframe, [contentEditable=true]').each(function(index) {
                if (index === 0) {
                    $(this).prop("autofocus", true);
                }
                $(this).prop("tabindex", 0);
            });
        },
        persist: true
    });
}

$(function() {
    if (window.location.href.indexOf("/action/edit") === -1) {
        if (!Cookies.get("siteupdate_popup")) {
            if ($(".siteupdate .popup").length > 0) {
                setTimeout(function() {
                    $(".siteupdate .popup").css("display", "flex");
                    setTimeout(function() {
                        $(".siteupdate .popup").addClass("open");
                        Cookies.set("siteupdate_popup", "1", {
                            expires: 30
                        });
                    }, 10);
                    setTimeout(function() {
                        hidePopup();
                    }, 1e4);
                }, 3e3);
                $(".siteupdate .popup_overlay, .siteupdate .popup-1_close").on("click", function(e) {
                    e.preventDefault();
                    hidePopup();
                });
            }
        }
    }
    function hidePopup() {
        $(".siteupdate .popup").removeClass("open");
        setTimeout(function() {
            $(".siteupdate .popup").css("display", "none");
        }, 300);
    }
});

jQuery(document).ready(function($) {
    var MqL = 1149;
    moveNavigation();
    $(window).on("resize", function() {
        !window.requestAnimationFrame ? setTimeout(moveNavigation, 300) : window.requestAnimationFrame(moveNavigation);
    });
    $(".cd-nav-trigger, .mobile-navigation-row, .mobile-secondary-navigation-row .close-button").on("click", function(event) {
        event.preventDefault();
        if ($(".cd-search").hasClass("is-visible")) {
            closeSearch(true);
        }
        if ($(".cd-main-content").hasClass("nav-is-visible")) {
            closeNav();
            $(".cd-overlay").removeClass("is-visible");
            $(".cd-overlay").removeClass("search-is-visible");
            $(".cd-nav-trigger").find("i").removeClass("fa-xmark", 100);
            $(".cd-nav-trigger").find("i").addClass("fa-bars", 100);
        } else {
            $(this).addClass("nav-is-visible");
            $(".cd-primary-nav").addClass("nav-is-visible");
            $(".cd-main-header").addClass("nav-is-visible");
            $(".cd-main-content").addClass("nav-is-visible");
            $("body").addClass("overflow-hidden");
            closeWorldwide();
            $(".cd-overlay").addClass("is-visible");
            $(".cd-nav-trigger").find("i").removeClass("fa-bars", 100);
            $(".cd-nav-trigger").find("i").addClass("fa-xmark", 100);
        }
    });
    $(".cd-search-trigger").on("click", function(event) {
        event.preventDefault();
        if (!checkWindowWidth()) {
            if ($(".cd-search").hasClass("is-visible")) {
                closeSearch();
            } else {
                openSearch();
                $("#query").get(0).focus();
            }
        }
    });
    $(".header-container .cd-search-trigger").on("click", function(event) {
        event.preventDefault();
        closeNav();
        if ($(".cd-search").hasClass("is-visible")) {
            closeSearch();
        } else {
            openSearch();
            $("#query").get(0).focus();
        }
    });
    $(".header-container-new .cd-search-trigger").mouseenter(function(event) {
        if (checkWindowWidth() && !$(".cd-search").hasClass("is-visible")) {
            event.preventDefault();
            closeNav();
            if ($(".cd-search").hasClass("is-visible")) {
                closeSearch();
            } else {
                openSearch();
            }
            $("#query").get(0).focus();
        }
    });
    $(".cd-overlay").on("swiperight", function() {
        if ($(".cd-primary-nav").hasClass("nav-is-visible")) {
            closeNav();
            $(".cd-overlay").removeClass("is-visible");
        }
    });
    $(".nav-on-left .cd-overlay").on("swipeleft", function() {
        if ($(".cd-primary-nav").hasClass("nav-is-visible")) {
            closeNav();
            $(".cd-overlay").removeClass("is-visible");
        }
    });
    $(".cd-overlay").on("click", function() {
        closeNav();
        closeSearch();
        $(".cd-overlay").removeClass("is-visible");
        $(".cd-nav-trigger").find("i").removeClass("fa-xmark", 100);
        $(".cd-nav-trigger").find("i").addClass("fa-bars", 100);
    });
    $(".has-children").children("a").on("click", function(event) {
        if (!checkWindowWidth()) event.preventDefault();
        var selected = $(this);
        if (selected.next("ul").hasClass("is-hidden")) {
            selected.addClass("selected").next("ul").removeClass("is-hidden").end().parent(".has-children").parent("ul").addClass("moves-out");
            selected.parent(".has-children").siblings(".has-children").children("ul").addClass("is-hidden").end().children("a").removeClass("selected");
            $(".cd-overlay").addClass("is-visible");
        } else {
            selected.removeClass("selected").next("ul").addClass("is-hidden").end().parent(".has-children").parent("ul").removeClass("moves-out");
            $(".cd-overlay").removeClass("is-visible");
        }
        var selected2 = $(this).next("ul");
        if (selected2.children("li").hasClass("has-children")) {
            var selected3 = selected2.children(".has-children");
            if (selected3.children("ul").hasClass("is-hidden")) {
                selected3.children("ul").removeClass("is-hidden").end().parent(".has-children").parent("ul").addClass("moves-out");
            }
        } else {
            var selected3 = selected2.children(".has-children");
            selected3.children("ul").removeClass("selected").next("ul").addClass("is-hidden").end().parent(".has-children").parent("ul").removeClass("moves-out");
        }
        closeSearch(true);
    });
    $(".cd-primary-nav").children(".has-children").hover(function(event) {
        if (checkWindowWidth()) {
            event.preventDefault();
            closeSearch(true);
            var selected = $(this).children("a");
            if (selected.next("ul").hasClass("is-hidden")) {
                selected.addClass("selected").attr("aria-expanded", true).next("ul").removeClass("is-hidden").end().parent(".has-children").parent("ul").addClass("moves-out");
                selected.parent(".has-children").siblings(".has-children").children("ul").addClass("is-hidden").end().children("a").removeClass("selected");
                $(".cd-overlay").addClass("is-visible");
            } else {
                selected.removeClass("selected").attr("aria-expanded", false).next("ul").addClass("is-hidden").end().parent(".has-children").parent("ul").removeClass("moves-out");
                $(".cd-overlay").removeClass("is-visible");
            }
        }
    });
    $(".cd-worldwide-trigger").hover(function(event) {
        if (checkWindowWidth()) {
            event.preventDefault();
            var selected = $(this).children("ul");
            if (selected.hasClass("is-hidden")) {
                selected.addClass("selected").removeClass("is-hidden").addClass("moves-out");
                selected.parent(".has-children").siblings(".has-children").children("ul").addClass("is-hidden").end().children("a").removeClass("selected");
                $(".cd-overlay").addClass("is-visible");
            } else {
                selected.removeClass("selected").addClass("is-hidden").removeClass("moves-out");
                $(".cd-overlay").removeClass("is-visible");
            }
            closeSearch();
        }
    });
    $(".cd-worldwide-trigger").click(function(event) {
        if (event.target.nodeName == "A") return;
        if (!checkWindowWidth()) {
            var selected = $(this).children("ul");
            if (selected.hasClass("is-hidden")) {
                event.preventDefault();
                selected.addClass("selected").removeClass("is-hidden").addClass("moves-out");
                selected.parent(".has-children").siblings(".has-children").children("ul").addClass("is-hidden").end().children("a").removeClass("selected");
                $(".cd-overlay").addClass("is-visible");
            } else {
                selected.removeClass("selected").addClass("is-hidden").removeClass("moves-out");
                $(".cd-overlay").removeClass("is-visible");
            }
            closeSearch();
        }
    });
    $(".go-back").on("click", function() {
        $(this).parent("ul").addClass("is-hidden").parent(".has-children").parent("ul").removeClass("moves-out");
    });
    $(".mobile-secondary-navigation-row .go-back").on("click", function() {
        $(this).closest("ul").addClass("is-hidden").parent(".has-children").parent("ul").removeClass("moves-out");
    });
    function closeNav() {
        $(".cd-nav-trigger").removeClass("nav-is-visible");
        $(".cd-main-header").removeClass("nav-is-visible");
        $(".cd-primary-nav").removeClass("nav-is-visible");
        $(".has-children ul").addClass("is-hidden");
        $(".has-children a").removeClass("selected");
        $(".moves-out").removeClass("moves-out");
        $(".cd-main-content").removeClass("nav-is-visible");
        $("body").removeClass("overflow-hidden");
        $(".cd-overlay").removeClass("is-visible").removeClass("search-is-visible");
    }
    function toggleSearch(type) {
        if ($(".cd-search").hasClass("is-visible")) {
            type = "close";
        }
        if (type == "close") {
            $(".cd-search").removeClass("is-visible");
            $(".cd-search-trigger").removeClass("search-is-visible");
            $(".cd-overlay").removeClass("search-is-visible");
            var primaryNav = $(".cd-primary-nav");
            primaryNav.find("li ul.cd-secondary-search-nav").addClass("is-hidden");
        } else {
            $(".cd-search").toggleClass("is-visible");
            $(".cd-search-trigger").toggleClass("search-is-visible");
            $(".cd-overlay").toggleClass("search-is-visible");
            if ($(window).width() > MqL && $(".cd-search").hasClass("is-visible")) $(".cd-search").find("#query").focus();
            $(".cd-search").hasClass("is-visible") ? $(".cd-overlay").addClass("is-visible") : $(".cd-overlay").removeClass("is-visible");
            var primaryNav = $(".cd-primary-nav");
            primaryNav.find("li ul.cd-secondary-search-nav").toggleClass("is-hidden");
            if (!checkWindowWidth()) {
                $(".cd-main-header").toggleClass("nav-is-visible");
                $(".cd-primary-nav").toggleClass("nav-is-visible");
                $(".cd-main-content").toggleClass("nav-is-visible");
            }
        }
    }
    function openSearch() {
        $(".cd-search").toggleClass("is-visible");
        $(".cd-search-trigger").toggleClass("search-is-visible");
        $(".cd-overlay").toggleClass("search-is-visible");
        if ($(window).width() > MqL && $(".cd-search").hasClass("is-visible")) $(".cd-search").find("#query").focus();
        $(".cd-search").hasClass("is-visible") ? $(".cd-overlay").addClass("is-visible") : $(".cd-overlay").removeClass("is-visible");
        var primaryNav = $(".cd-primary-nav");
        primaryNav.find("li ul.cd-secondary-search-nav").toggleClass("is-hidden");
        if (!checkWindowWidth()) {
            $(".cd-main-header").addClass("nav-is-visible");
            $(".cd-primary-nav").addClass("nav-is-visible");
            $(".cd-main-content").addClass("nav-is-visible");
            $("body").addClass("overflow-hidden");
        }
    }
    function closeSearch(keepNavOpen) {
        if (!keepNavOpen) {
            closeNav();
        }
        $(".cd-search").removeClass("is-visible");
        $(".cd-search-trigger").removeClass("search-is-visible");
        $(".cd-overlay").removeClass("search-is-visible");
        var primaryNav = $(".cd-primary-nav");
        primaryNav.find("li ul.cd-secondary-search-nav").addClass("is-hidden");
    }
    function closeWorldwide() {
        $(".cd-worldwide-nav").removeClass("selected").addClass("is-hidden").removeClass("moves-out");
    }
    function checkWindowWidth() {
        var e = window, a = "inner";
        if (!("innerWidth" in window)) {
            a = "client";
            e = document.documentElement || document.body;
        }
        if (e[a + "Width"] >= MqL) {
            return true;
        } else {
            return false;
        }
    }
    function moveNavigation() {
        var navigation = $(".header-container .cd-nav");
        var newNavigation = $(".header-container-new .cd-nav");
        var desktop = checkWindowWidth();
        if ($(".header-container-new").length) {
            if (desktop) {
                newNavigation.detach();
                $(".cd-main-header .navbar_menu-items").html(newNavigation);
            } else if (!newNavigation.prev().hasClass("cd-main-content")) {
                newNavigation.detach();
                newNavigation.insertAfter(".cd-main-content");
            }
        } else {
            navigation.detach();
            if (desktop) {
                navigation.insertBefore(".cd-header-buttons");
            } else {
                navigation.insertAfter(".cd-main-content");
            }
        }
    }
    function getCookie(name) {
        var match = document.cookie.match(RegExp("(?:^|;\\s*)" + name + "=([^;]*)"));
        return match ? match[1] : null;
    }
    $(window).on("load", function() {
        var storeCookie = getCookie("mozucartcount");
        var itemCount = $(".cd-header-buttons a.store").find("span.item-count").first();
        if (storeCookie != null) {
            var count;
            var objCookie = jQuery.parseJSON(decodeURIComponent(storeCookie));
            if (objCookie != null) {
                count = objCookie[0];
            }
            if (count != null && count != "") {
                $(itemCount).html(count);
            }
            $(".cd-header-buttons a.store").find("span.item-count").first(function() {
                var count;
                var objCookie = jQuery.parseJSON(decodeURIComponent(storeCookie));
                if (objCookie != null) {
                    count = objCookie[0];
                }
                if (count != null && count != "") {
                    $(this).html(count);
                }
            });
        } else {
            $(itemCount).html("");
        }
    });
});

(function(window) {
    var slice = Array.prototype.slice;
    function noop() {}
    function defineBridget($) {
        if (!$) {
            return;
        }
        function addOptionMethod(PluginClass) {
            if (PluginClass.prototype.option) {
                return;
            }
            PluginClass.prototype.option = function(opts) {
                if (!$.isPlainObject(opts)) {
                    return;
                }
                this.options = $.extend(true, this.options, opts);
            };
        }
        var logError = typeof console === "undefined" ? noop : function(message) {
            console.error(message);
        };
        function bridge(namespace, PluginClass) {
            $.fn[namespace] = function(options) {
                if (typeof options === "string") {
                    var args = slice.call(arguments, 1);
                    for (var i = 0, len = this.length; i < len; i++) {
                        var elem = this[i];
                        var instance = $.data(elem, namespace);
                        if (!instance) {
                            logError("cannot call methods on " + namespace + " prior to initialization; " + "attempted to call '" + options + "'");
                            continue;
                        }
                        if (!$.isFunction(instance[options]) || options.charAt(0) === "_") {
                            logError("no such method '" + options + "' for " + namespace + " instance");
                            continue;
                        }
                        var returnValue = instance[options].apply(instance, args);
                        if (returnValue !== undefined) {
                            return returnValue;
                        }
                    }
                    return this;
                } else {
                    return this.each(function() {
                        var instance = $.data(this, namespace);
                        if (instance) {
                            instance.option(options);
                            instance._init();
                        } else {
                            instance = new PluginClass(this, options);
                            $.data(this, namespace, instance);
                        }
                    });
                }
            };
        }
        $.bridget = function(namespace, PluginClass) {
            addOptionMethod(PluginClass);
            bridge(namespace, PluginClass);
        };
        return $.bridget;
    }
    if (typeof define === "function" && define.amd) {
        define("jquery-bridget/jquery.bridget", [ "jquery" ], defineBridget);
    } else if (typeof exports === "object") {
        defineBridget(require("jquery"));
    } else {
        defineBridget(window.jQuery);
    }
})(window);

(function(window) {
    var docElem = document.documentElement;
    var bind = function() {};
    function getIEEvent(obj) {
        var event = window.event;
        event.target = event.target || event.srcElement || obj;
        return event;
    }
    if (docElem.addEventListener) {
        bind = function(obj, type, fn) {
            obj.addEventListener(type, fn, false);
        };
    } else if (docElem.attachEvent) {
        bind = function(obj, type, fn) {
            obj[type + fn] = fn.handleEvent ? function() {
                var event = getIEEvent(obj);
                fn.handleEvent.call(fn, event);
            } : function() {
                var event = getIEEvent(obj);
                fn.call(obj, event);
            };
            obj.attachEvent("on" + type, obj[type + fn]);
        };
    }
    var unbind = function() {};
    if (docElem.removeEventListener) {
        unbind = function(obj, type, fn) {
            obj.removeEventListener(type, fn, false);
        };
    } else if (docElem.detachEvent) {
        unbind = function(obj, type, fn) {
            obj.detachEvent("on" + type, obj[type + fn]);
            try {
                delete obj[type + fn];
            } catch (err) {
                obj[type + fn] = undefined;
            }
        };
    }
    var eventie = {
        bind: bind,
        unbind: unbind
    };
    if (typeof define === "function" && define.amd) {
        define("eventie/eventie", eventie);
    } else if (typeof exports === "object") {
        module.exports = eventie;
    } else {
        window.eventie = eventie;
    }
})(window);

(function() {
    "use strict";
    function EventEmitter() {}
    var proto = EventEmitter.prototype;
    var exports = this;
    var originalGlobalValue = exports.EventEmitter;
    function indexOfListener(listeners, listener) {
        var i = listeners.length;
        while (i--) {
            if (listeners[i].listener === listener) {
                return i;
            }
        }
        return -1;
    }
    function alias(name) {
        return function aliasClosure() {
            return this[name].apply(this, arguments);
        };
    }
    proto.getListeners = function getListeners(evt) {
        var events = this._getEvents();
        var response;
        var key;
        if (evt instanceof RegExp) {
            response = {};
            for (key in events) {
                if (events.hasOwnProperty(key) && evt.test(key)) {
                    response[key] = events[key];
                }
            }
        } else {
            response = events[evt] || (events[evt] = []);
        }
        return response;
    };
    proto.flattenListeners = function flattenListeners(listeners) {
        var flatListeners = [];
        var i;
        for (i = 0; i < listeners.length; i += 1) {
            flatListeners.push(listeners[i].listener);
        }
        return flatListeners;
    };
    proto.getListenersAsObject = function getListenersAsObject(evt) {
        var listeners = this.getListeners(evt);
        var response;
        if (listeners instanceof Array) {
            response = {};
            response[evt] = listeners;
        }
        return response || listeners;
    };
    proto.addListener = function addListener(evt, listener) {
        var listeners = this.getListenersAsObject(evt);
        var listenerIsWrapped = typeof listener === "object";
        var key;
        for (key in listeners) {
            if (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {
                listeners[key].push(listenerIsWrapped ? listener : {
                    listener: listener,
                    once: false
                });
            }
        }
        return this;
    };
    proto.on = alias("addListener");
    proto.addOnceListener = function addOnceListener(evt, listener) {
        return this.addListener(evt, {
            listener: listener,
            once: true
        });
    };
    proto.once = alias("addOnceListener");
    proto.defineEvent = function defineEvent(evt) {
        this.getListeners(evt);
        return this;
    };
    proto.defineEvents = function defineEvents(evts) {
        for (var i = 0; i < evts.length; i += 1) {
            this.defineEvent(evts[i]);
        }
        return this;
    };
    proto.removeListener = function removeListener(evt, listener) {
        var listeners = this.getListenersAsObject(evt);
        var index;
        var key;
        for (key in listeners) {
            if (listeners.hasOwnProperty(key)) {
                index = indexOfListener(listeners[key], listener);
                if (index !== -1) {
                    listeners[key].splice(index, 1);
                }
            }
        }
        return this;
    };
    proto.off = alias("removeListener");
    proto.addListeners = function addListeners(evt, listeners) {
        return this.manipulateListeners(false, evt, listeners);
    };
    proto.removeListeners = function removeListeners(evt, listeners) {
        return this.manipulateListeners(true, evt, listeners);
    };
    proto.manipulateListeners = function manipulateListeners(remove, evt, listeners) {
        var i;
        var value;
        var single = remove ? this.removeListener : this.addListener;
        var multiple = remove ? this.removeListeners : this.addListeners;
        if (typeof evt === "object" && !(evt instanceof RegExp)) {
            for (i in evt) {
                if (evt.hasOwnProperty(i) && (value = evt[i])) {
                    if (typeof value === "function") {
                        single.call(this, i, value);
                    } else {
                        multiple.call(this, i, value);
                    }
                }
            }
        } else {
            i = listeners.length;
            while (i--) {
                single.call(this, evt, listeners[i]);
            }
        }
        return this;
    };
    proto.removeEvent = function removeEvent(evt) {
        var type = typeof evt;
        var events = this._getEvents();
        var key;
        if (type === "string") {
            delete events[evt];
        } else if (evt instanceof RegExp) {
            for (key in events) {
                if (events.hasOwnProperty(key) && evt.test(key)) {
                    delete events[key];
                }
            }
        } else {
            delete this._events;
        }
        return this;
    };
    proto.removeAllListeners = alias("removeEvent");
    proto.emitEvent = function emitEvent(evt, args) {
        var listeners = this.getListenersAsObject(evt);
        var listener;
        var i;
        var key;
        var response;
        for (key in listeners) {
            if (listeners.hasOwnProperty(key)) {
                i = listeners[key].length;
                while (i--) {
                    listener = listeners[key][i];
                    if (listener.once === true) {
                        this.removeListener(evt, listener.listener);
                    }
                    response = listener.listener.apply(this, args || []);
                    if (response === this._getOnceReturnValue()) {
                        this.removeListener(evt, listener.listener);
                    }
                }
            }
        }
        return this;
    };
    proto.trigger = alias("emitEvent");
    proto.emit = function emit(evt) {
        var args = Array.prototype.slice.call(arguments, 1);
        return this.emitEvent(evt, args);
    };
    proto.setOnceReturnValue = function setOnceReturnValue(value) {
        this._onceReturnValue = value;
        return this;
    };
    proto._getOnceReturnValue = function _getOnceReturnValue() {
        if (this.hasOwnProperty("_onceReturnValue")) {
            return this._onceReturnValue;
        } else {
            return true;
        }
    };
    proto._getEvents = function _getEvents() {
        return this._events || (this._events = {});
    };
    EventEmitter.noConflict = function noConflict() {
        exports.EventEmitter = originalGlobalValue;
        return EventEmitter;
    };
    if (typeof define === "function" && define.amd) {
        define("eventEmitter/EventEmitter", [], function() {
            return EventEmitter;
        });
    } else if (typeof module === "object" && module.exports) {
        module.exports = EventEmitter;
    } else {
        exports.EventEmitter = EventEmitter;
    }
}).call(this);

(function(window) {
    var prefixes = "Webkit Moz ms Ms O".split(" ");
    var docElemStyle = document.documentElement.style;
    function getStyleProperty(propName) {
        if (!propName) {
            return;
        }
        if (typeof docElemStyle[propName] === "string") {
            return propName;
        }
        propName = propName.charAt(0).toUpperCase() + propName.slice(1);
        var prefixed;
        for (var i = 0, len = prefixes.length; i < len; i++) {
            prefixed = prefixes[i] + propName;
            if (typeof docElemStyle[prefixed] === "string") {
                return prefixed;
            }
        }
    }
    if (typeof define === "function" && define.amd) {
        define("get-style-property/get-style-property", [], function() {
            return getStyleProperty;
        });
    } else if (typeof exports === "object") {
        module.exports = getStyleProperty;
    } else {
        window.getStyleProperty = getStyleProperty;
    }
})(window);

(function(window, undefined) {
    function getStyleSize(value) {
        var num = parseFloat(value);
        var isValid = value.indexOf("%") === -1 && !isNaN(num);
        return isValid && num;
    }
    function noop() {}
    var logError = typeof console === "undefined" ? noop : function(message) {
        console.error(message);
    };
    var measurements = [ "paddingLeft", "paddingRight", "paddingTop", "paddingBottom", "marginLeft", "marginRight", "marginTop", "marginBottom", "borderLeftWidth", "borderRightWidth", "borderTopWidth", "borderBottomWidth" ];
    function getZeroSize() {
        var size = {
            width: 0,
            height: 0,
            innerWidth: 0,
            innerHeight: 0,
            outerWidth: 0,
            outerHeight: 0
        };
        for (var i = 0, len = measurements.length; i < len; i++) {
            var measurement = measurements[i];
            size[measurement] = 0;
        }
        return size;
    }
    function defineGetSize(getStyleProperty) {
        var isSetup = false;
        var getStyle, boxSizingProp, isBoxSizeOuter;
        function setup() {
            if (isSetup) {
                return;
            }
            isSetup = true;
            var getComputedStyle = window.getComputedStyle;
            getStyle = function() {
                var getStyleFn = getComputedStyle ? function(elem) {
                    return getComputedStyle(elem, null);
                } : function(elem) {
                    return elem.currentStyle;
                };
                return function getStyle(elem) {
                    var style = getStyleFn(elem);
                    if (!style) {
                        logError("Style returned " + style + ". Are you running this code in a hidden iframe on Firefox? " + "See http://bit.ly/getsizebug1");
                    }
                    return style;
                };
            }();
            boxSizingProp = getStyleProperty("boxSizing");
            if (boxSizingProp) {
                var div = document.createElement("div");
                div.style.width = "200px";
                div.style.padding = "1px 2px 3px 4px";
                div.style.borderStyle = "solid";
                div.style.borderWidth = "1px 2px 3px 4px";
                div.style[boxSizingProp] = "border-box";
                var body = document.body || document.documentElement;
                body.appendChild(div);
                var style = getStyle(div);
                isBoxSizeOuter = getStyleSize(style.width) === 200;
                body.removeChild(div);
            }
        }
        function getSize(elem) {
            setup();
            if (typeof elem === "string") {
                elem = document.querySelector(elem);
            }
            if (!elem || typeof elem !== "object" || !elem.nodeType) {
                return;
            }
            var style = getStyle(elem);
            if (style.display === "none") {
                return getZeroSize();
            }
            var size = {};
            size.width = elem.offsetWidth;
            size.height = elem.offsetHeight;
            var isBorderBox = size.isBorderBox = !!(boxSizingProp && style[boxSizingProp] && style[boxSizingProp] === "border-box");
            for (var i = 0, len = measurements.length; i < len; i++) {
                var measurement = measurements[i];
                var value = style[measurement];
                value = mungeNonPixel(elem, value);
                var num = parseFloat(value);
                size[measurement] = !isNaN(num) ? num : 0;
            }
            var paddingWidth = size.paddingLeft + size.paddingRight;
            var paddingHeight = size.paddingTop + size.paddingBottom;
            var marginWidth = size.marginLeft + size.marginRight;
            var marginHeight = size.marginTop + size.marginBottom;
            var borderWidth = size.borderLeftWidth + size.borderRightWidth;
            var borderHeight = size.borderTopWidth + size.borderBottomWidth;
            var isBorderBoxSizeOuter = isBorderBox && isBoxSizeOuter;
            var styleWidth = getStyleSize(style.width);
            if (styleWidth !== false) {
                size.width = styleWidth + (isBorderBoxSizeOuter ? 0 : paddingWidth + borderWidth);
            }
            var styleHeight = getStyleSize(style.height);
            if (styleHeight !== false) {
                size.height = styleHeight + (isBorderBoxSizeOuter ? 0 : paddingHeight + borderHeight);
            }
            size.innerWidth = size.width - (paddingWidth + borderWidth);
            size.innerHeight = size.height - (paddingHeight + borderHeight);
            size.outerWidth = size.width + marginWidth;
            size.outerHeight = size.height + marginHeight;
            return size;
        }
        function mungeNonPixel(elem, value) {
            if (window.getComputedStyle || value.indexOf("%") === -1) {
                return value;
            }
            var style = elem.style;
            var left = style.left;
            var rs = elem.runtimeStyle;
            var rsLeft = rs && rs.left;
            if (rsLeft) {
                rs.left = elem.currentStyle.left;
            }
            style.left = value;
            value = style.pixelLeft;
            style.left = left;
            if (rsLeft) {
                rs.left = rsLeft;
            }
            return value;
        }
        return getSize;
    }
    if (typeof define === "function" && define.amd) {
        define("get-size/get-size", [ "get-style-property/get-style-property" ], defineGetSize);
    } else if (typeof exports === "object") {
        module.exports = defineGetSize(require("desandro-get-style-property"));
    } else {
        window.getSize = defineGetSize(window.getStyleProperty);
    }
})(window);

(function(window) {
    var document = window.document;
    var queue = [];
    function docReady(fn) {
        if (typeof fn !== "function") {
            return;
        }
        if (docReady.isReady) {
            fn();
        } else {
            queue.push(fn);
        }
    }
    docReady.isReady = false;
    function onReady(event) {
        var isIE8NotReady = event.type === "readystatechange" && document.readyState !== "complete";
        if (docReady.isReady || isIE8NotReady) {
            return;
        }
        trigger();
    }
    function trigger() {
        docReady.isReady = true;
        for (var i = 0, len = queue.length; i < len; i++) {
            var fn = queue[i];
            fn();
        }
    }
    function defineDocReady(eventie) {
        if (document.readyState === "complete") {
            trigger();
        } else {
            eventie.bind(document, "DOMContentLoaded", onReady);
            eventie.bind(document, "readystatechange", onReady);
            eventie.bind(window, "load", onReady);
        }
        return docReady;
    }
    if (typeof define === "function" && define.amd) {
        define("doc-ready/doc-ready", [ "eventie/eventie" ], defineDocReady);
    } else if (typeof exports === "object") {
        module.exports = defineDocReady(require("eventie"));
    } else {
        window.docReady = defineDocReady(window.eventie);
    }
})(window);

(function(ElemProto) {
    "use strict";
    var matchesMethod = function() {
        if (ElemProto.matches) {
            return "matches";
        }
        if (ElemProto.matchesSelector) {
            return "matchesSelector";
        }
        var prefixes = [ "webkit", "moz", "ms", "o" ];
        for (var i = 0, len = prefixes.length; i < len; i++) {
            var prefix = prefixes[i];
            var method = prefix + "MatchesSelector";
            if (ElemProto[method]) {
                return method;
            }
        }
    }();
    function match(elem, selector) {
        return elem[matchesMethod](selector);
    }
    function checkParent(elem) {
        if (elem.parentNode) {
            return;
        }
        var fragment = document.createDocumentFragment();
        fragment.appendChild(elem);
    }
    function query(elem, selector) {
        checkParent(elem);
        var elems = elem.parentNode.querySelectorAll(selector);
        for (var i = 0, len = elems.length; i < len; i++) {
            if (elems[i] === elem) {
                return true;
            }
        }
        return false;
    }
    function matchChild(elem, selector) {
        checkParent(elem);
        return match(elem, selector);
    }
    var matchesSelector;
    if (matchesMethod) {
        var div = document.createElement("div");
        var supportsOrphans = match(div, "div");
        matchesSelector = supportsOrphans ? match : matchChild;
    } else {
        matchesSelector = query;
    }
    if (typeof define === "function" && define.amd) {
        define("matches-selector/matches-selector", [], function() {
            return matchesSelector;
        });
    } else if (typeof exports === "object") {
        module.exports = matchesSelector;
    } else {
        window.matchesSelector = matchesSelector;
    }
})(Element.prototype);

(function(window, factory) {
    "use strict";
    if (typeof define == "function" && define.amd) {
        define("fizzy-ui-utils/utils", [ "doc-ready/doc-ready", "matches-selector/matches-selector" ], function(docReady, matchesSelector) {
            return factory(window, docReady, matchesSelector);
        });
    } else if (typeof exports == "object") {
        module.exports = factory(window, require("doc-ready"), require("desandro-matches-selector"));
    } else {
        window.fizzyUIUtils = factory(window, window.docReady, window.matchesSelector);
    }
})(window, function factory(window, docReady, matchesSelector) {
    var utils = {};
    utils.extend = function(a, b) {
        for (var prop in b) {
            a[prop] = b[prop];
        }
        return a;
    };
    utils.modulo = function(num, div) {
        return (num % div + div) % div;
    };
    var objToString = Object.prototype.toString;
    utils.isArray = function(obj) {
        return objToString.call(obj) == "[object Array]";
    };
    utils.makeArray = function(obj) {
        var ary = [];
        if (utils.isArray(obj)) {
            ary = obj;
        } else if (obj && typeof obj.length == "number") {
            for (var i = 0, len = obj.length; i < len; i++) {
                ary.push(obj[i]);
            }
        } else {
            ary.push(obj);
        }
        return ary;
    };
    utils.indexOf = Array.prototype.indexOf ? function(ary, obj) {
        return ary.indexOf(obj);
    } : function(ary, obj) {
        for (var i = 0, len = ary.length; i < len; i++) {
            if (ary[i] === obj) {
                return i;
            }
        }
        return -1;
    };
    utils.removeFrom = function(ary, obj) {
        var index = utils.indexOf(ary, obj);
        if (index != -1) {
            ary.splice(index, 1);
        }
    };
    utils.isElement = typeof HTMLElement == "function" || typeof HTMLElement == "object" ? function isElementDOM2(obj) {
        return obj instanceof HTMLElement;
    } : function isElementQuirky(obj) {
        return obj && typeof obj == "object" && obj.nodeType == 1 && typeof obj.nodeName == "string";
    };
    utils.setText = function() {
        var setTextProperty;
        function setText(elem, text) {
            setTextProperty = setTextProperty || (document.documentElement.textContent !== undefined ? "textContent" : "innerText");
            elem[setTextProperty] = text;
        }
        return setText;
    }();
    utils.getParent = function(elem, selector) {
        while (elem != document.body) {
            elem = elem.parentNode;
            if (matchesSelector(elem, selector)) {
                return elem;
            }
        }
    };
    utils.getQueryElement = function(elem) {
        if (typeof elem == "string") {
            return document.querySelector(elem);
        }
        return elem;
    };
    utils.handleEvent = function(event) {
        var method = "on" + event.type;
        if (this[method]) {
            this[method](event);
        }
    };
    utils.filterFindElements = function(elems, selector) {
        elems = utils.makeArray(elems);
        var ffElems = [];
        for (var i = 0, len = elems.length; i < len; i++) {
            var elem = elems[i];
            if (!utils.isElement(elem)) {
                continue;
            }
            if (selector) {
                if (matchesSelector(elem, selector)) {
                    ffElems.push(elem);
                }
                var childElems = elem.querySelectorAll(selector);
                for (var j = 0, jLen = childElems.length; j < jLen; j++) {
                    ffElems.push(childElems[j]);
                }
            } else {
                ffElems.push(elem);
            }
        }
        return ffElems;
    };
    utils.debounceMethod = function(_class, methodName, threshold) {
        var method = _class.prototype[methodName];
        var timeoutName = methodName + "Timeout";
        _class.prototype[methodName] = function() {
            var timeout = this[timeoutName];
            if (timeout) {
                clearTimeout(timeout);
            }
            var args = arguments;
            var _this = this;
            this[timeoutName] = setTimeout(function() {
                method.apply(_this, args);
                delete _this[timeoutName];
            }, threshold || 100);
        };
    };
    utils.toDashed = function(str) {
        return str.replace(/(.)([A-Z])/g, function(match, $1, $2) {
            return $1 + "-" + $2;
        }).toLowerCase();
    };
    var console = window.console;
    utils.htmlInit = function(WidgetClass, namespace) {
        docReady(function() {
            var dashedNamespace = utils.toDashed(namespace);
            var elems = document.querySelectorAll(".js-" + dashedNamespace);
            var dataAttr = "data-" + dashedNamespace + "-options";
            for (var i = 0, len = elems.length; i < len; i++) {
                var elem = elems[i];
                var attr = elem.getAttribute(dataAttr);
                var options;
                try {
                    options = attr && JSON.parse(attr);
                } catch (error) {
                    if (console) {
                        console.error("Error parsing " + dataAttr + " on " + elem.nodeName.toLowerCase() + (elem.id ? "#" + elem.id : "") + ": " + error);
                    }
                    continue;
                }
                var instance = new WidgetClass(elem, options);
                var jQuery = window.jQuery;
                if (jQuery) {
                    jQuery.data(elem, namespace, instance);
                }
            }
        });
    };
    return utils;
});

(function(window, factory) {
    "use strict";
    if (typeof define === "function" && define.amd) {
        define("outlayer/item", [ "eventEmitter/EventEmitter", "get-size/get-size", "get-style-property/get-style-property", "fizzy-ui-utils/utils" ], function(EventEmitter, getSize, getStyleProperty, utils) {
            return factory(window, EventEmitter, getSize, getStyleProperty, utils);
        });
    } else if (typeof exports === "object") {
        module.exports = factory(window, require("wolfy87-eventemitter"), require("get-size"), require("desandro-get-style-property"), require("fizzy-ui-utils"));
    } else {
        window.Outlayer = {};
        window.Outlayer.Item = factory(window, window.EventEmitter, window.getSize, window.getStyleProperty, window.fizzyUIUtils);
    }
})(window, function factory(window, EventEmitter, getSize, getStyleProperty, utils) {
    "use strict";
    var getComputedStyle = window.getComputedStyle;
    var getStyle = getComputedStyle ? function(elem) {
        return getComputedStyle(elem, null);
    } : function(elem) {
        return elem.currentStyle;
    };
    function isEmptyObj(obj) {
        for (var prop in obj) {
            return false;
        }
        prop = null;
        return true;
    }
    var transitionProperty = getStyleProperty("transition");
    var transformProperty = getStyleProperty("transform");
    var supportsCSS3 = transitionProperty && transformProperty;
    var is3d = !!getStyleProperty("perspective");
    var transitionEndEvent = {
        WebkitTransition: "webkitTransitionEnd",
        MozTransition: "transitionend",
        OTransition: "otransitionend",
        transition: "transitionend"
    }[transitionProperty];
    var prefixableProperties = [ "transform", "transition", "transitionDuration", "transitionProperty" ];
    var vendorProperties = function() {
        var cache = {};
        for (var i = 0, len = prefixableProperties.length; i < len; i++) {
            var prop = prefixableProperties[i];
            var supportedProp = getStyleProperty(prop);
            if (supportedProp && supportedProp !== prop) {
                cache[prop] = supportedProp;
            }
        }
        return cache;
    }();
    function Item(element, layout) {
        if (!element) {
            return;
        }
        this.element = element;
        this.layout = layout;
        this.position = {
            x: 0,
            y: 0
        };
        this._create();
    }
    utils.extend(Item.prototype, EventEmitter.prototype);
    Item.prototype._create = function() {
        this._transn = {
            ingProperties: {},
            clean: {},
            onEnd: {}
        };
        this.css({
            position: "absolute"
        });
    };
    Item.prototype.handleEvent = function(event) {
        var method = "on" + event.type;
        if (this[method]) {
            this[method](event);
        }
    };
    Item.prototype.getSize = function() {
        this.size = getSize(this.element);
    };
    Item.prototype.css = function(style) {
        var elemStyle = this.element.style;
        for (var prop in style) {
            var supportedProp = vendorProperties[prop] || prop;
            elemStyle[supportedProp] = style[prop];
        }
    };
    Item.prototype.getPosition = function() {
        var style = getStyle(this.element);
        var layoutOptions = this.layout.options;
        var isOriginLeft = layoutOptions.isOriginLeft;
        var isOriginTop = layoutOptions.isOriginTop;
        var xValue = style[isOriginLeft ? "left" : "right"];
        var yValue = style[isOriginTop ? "top" : "bottom"];
        var x = parseInt(xValue, 10);
        var y = parseInt(yValue, 10);
        var layoutSize = this.layout.size;
        x = xValue.indexOf("%") != -1 ? x / 100 * layoutSize.width : x;
        y = yValue.indexOf("%") != -1 ? y / 100 * layoutSize.height : y;
        x = isNaN(x) ? 0 : x;
        y = isNaN(y) ? 0 : y;
        x -= isOriginLeft ? layoutSize.paddingLeft : layoutSize.paddingRight;
        y -= isOriginTop ? layoutSize.paddingTop : layoutSize.paddingBottom;
        this.position.x = x;
        this.position.y = y;
    };
    Item.prototype.layoutPosition = function() {
        var layoutSize = this.layout.size;
        var layoutOptions = this.layout.options;
        var style = {};
        var xPadding = layoutOptions.isOriginLeft ? "paddingLeft" : "paddingRight";
        var xProperty = layoutOptions.isOriginLeft ? "left" : "right";
        var xResetProperty = layoutOptions.isOriginLeft ? "right" : "left";
        var x = this.position.x + layoutSize[xPadding];
        style[xProperty] = this.getXValue(x);
        style[xResetProperty] = "";
        var yPadding = layoutOptions.isOriginTop ? "paddingTop" : "paddingBottom";
        var yProperty = layoutOptions.isOriginTop ? "top" : "bottom";
        var yResetProperty = layoutOptions.isOriginTop ? "bottom" : "top";
        var y = this.position.y + layoutSize[yPadding];
        style[yProperty] = this.getYValue(y);
        style[yResetProperty] = "";
        this.css(style);
        this.emitEvent("layout", [ this ]);
    };
    Item.prototype.getXValue = function(x) {
        var layoutOptions = this.layout.options;
        return layoutOptions.percentPosition && !layoutOptions.isHorizontal ? x / this.layout.size.width * 100 + "%" : x + "px";
    };
    Item.prototype.getYValue = function(y) {
        var layoutOptions = this.layout.options;
        return layoutOptions.percentPosition && layoutOptions.isHorizontal ? y / this.layout.size.height * 100 + "%" : y + "px";
    };
    Item.prototype._transitionTo = function(x, y) {
        this.getPosition();
        var curX = this.position.x;
        var curY = this.position.y;
        var compareX = parseInt(x, 10);
        var compareY = parseInt(y, 10);
        var didNotMove = compareX === this.position.x && compareY === this.position.y;
        this.setPosition(x, y);
        if (didNotMove && !this.isTransitioning) {
            this.layoutPosition();
            return;
        }
        var transX = x - curX;
        var transY = y - curY;
        var transitionStyle = {};
        transitionStyle.transform = this.getTranslate(transX, transY);
        this.transition({
            to: transitionStyle,
            onTransitionEnd: {
                transform: this.layoutPosition
            },
            isCleaning: true
        });
    };
    Item.prototype.getTranslate = function(x, y) {
        var layoutOptions = this.layout.options;
        x = layoutOptions.isOriginLeft ? x : -x;
        y = layoutOptions.isOriginTop ? y : -y;
        x = this.getXValue(x);
        y = this.getYValue(y);
        if (is3d) {
            return "translate3d(" + x + ", " + y + ", 0)";
        }
        return "translate(" + x + ", " + y + ")";
    };
    Item.prototype.goTo = function(x, y) {
        this.setPosition(x, y);
        this.layoutPosition();
    };
    Item.prototype.moveTo = supportsCSS3 ? Item.prototype._transitionTo : Item.prototype.goTo;
    Item.prototype.setPosition = function(x, y) {
        this.position.x = parseInt(x, 10);
        this.position.y = parseInt(y, 10);
    };
    Item.prototype._nonTransition = function(args) {
        this.css(args.to);
        if (args.isCleaning) {
            this._removeStyles(args.to);
        }
        for (var prop in args.onTransitionEnd) {
            args.onTransitionEnd[prop].call(this);
        }
    };
    Item.prototype._transition = function(args) {
        if (!parseFloat(this.layout.options.transitionDuration)) {
            this._nonTransition(args);
            return;
        }
        var _transition = this._transn;
        for (var prop in args.onTransitionEnd) {
            _transition.onEnd[prop] = args.onTransitionEnd[prop];
        }
        for (prop in args.to) {
            _transition.ingProperties[prop] = true;
            if (args.isCleaning) {
                _transition.clean[prop] = true;
            }
        }
        if (args.from) {
            this.css(args.from);
            var h = this.element.offsetHeight;
            h = null;
        }
        this.enableTransition(args.to);
        this.css(args.to);
        this.isTransitioning = true;
    };
    function toDashedAll(str) {
        return str.replace(/([A-Z])/g, function($1) {
            return "-" + $1.toLowerCase();
        });
    }
    var transitionProps = "opacity," + toDashedAll(vendorProperties.transform || "transform");
    Item.prototype.enableTransition = function() {
        if (this.isTransitioning) {
            return;
        }
        this.css({
            transitionProperty: transitionProps,
            transitionDuration: this.layout.options.transitionDuration
        });
        this.element.addEventListener(transitionEndEvent, this, false);
    };
    Item.prototype.transition = Item.prototype[transitionProperty ? "_transition" : "_nonTransition"];
    Item.prototype.onwebkitTransitionEnd = function(event) {
        this.ontransitionend(event);
    };
    Item.prototype.onotransitionend = function(event) {
        this.ontransitionend(event);
    };
    var dashedVendorProperties = {
        "-webkit-transform": "transform",
        "-moz-transform": "transform",
        "-o-transform": "transform"
    };
    Item.prototype.ontransitionend = function(event) {
        if (event.target !== this.element) {
            return;
        }
        var _transition = this._transn;
        var propertyName = dashedVendorProperties[event.propertyName] || event.propertyName;
        delete _transition.ingProperties[propertyName];
        if (isEmptyObj(_transition.ingProperties)) {
            this.disableTransition();
        }
        if (propertyName in _transition.clean) {
            this.element.style[event.propertyName] = "";
            delete _transition.clean[propertyName];
        }
        if (propertyName in _transition.onEnd) {
            var onTransitionEnd = _transition.onEnd[propertyName];
            onTransitionEnd.call(this);
            delete _transition.onEnd[propertyName];
        }
        this.emitEvent("transitionEnd", [ this ]);
    };
    Item.prototype.disableTransition = function() {
        this.removeTransitionStyles();
        this.element.removeEventListener(transitionEndEvent, this, false);
        this.isTransitioning = false;
    };
    Item.prototype._removeStyles = function(style) {
        var cleanStyle = {};
        for (var prop in style) {
            cleanStyle[prop] = "";
        }
        this.css(cleanStyle);
    };
    var cleanTransitionStyle = {
        transitionProperty: "",
        transitionDuration: ""
    };
    Item.prototype.removeTransitionStyles = function() {
        this.css(cleanTransitionStyle);
    };
    Item.prototype.removeElem = function() {
        this.element.parentNode.removeChild(this.element);
        this.css({
            display: ""
        });
        this.emitEvent("remove", [ this ]);
    };
    Item.prototype.remove = function() {
        if (!transitionProperty || !parseFloat(this.layout.options.transitionDuration)) {
            this.removeElem();
            return;
        }
        var _this = this;
        this.once("transitionEnd", function() {
            _this.removeElem();
        });
        this.hide();
    };
    Item.prototype.reveal = function() {
        delete this.isHidden;
        this.css({
            display: ""
        });
        var options = this.layout.options;
        var onTransitionEnd = {};
        var transitionEndProperty = this.getHideRevealTransitionEndProperty("visibleStyle");
        onTransitionEnd[transitionEndProperty] = this.onRevealTransitionEnd;
        this.transition({
            from: options.hiddenStyle,
            to: options.visibleStyle,
            isCleaning: true,
            onTransitionEnd: onTransitionEnd
        });
    };
    Item.prototype.onRevealTransitionEnd = function() {
        if (!this.isHidden) {
            this.emitEvent("reveal");
        }
    };
    Item.prototype.getHideRevealTransitionEndProperty = function(styleProperty) {
        var optionStyle = this.layout.options[styleProperty];
        if (optionStyle.opacity) {
            return "opacity";
        }
        for (var prop in optionStyle) {
            return prop;
        }
    };
    Item.prototype.hide = function() {
        this.isHidden = true;
        this.css({
            display: ""
        });
        var options = this.layout.options;
        var onTransitionEnd = {};
        var transitionEndProperty = this.getHideRevealTransitionEndProperty("hiddenStyle");
        onTransitionEnd[transitionEndProperty] = this.onHideTransitionEnd;
        this.transition({
            from: options.visibleStyle,
            to: options.hiddenStyle,
            isCleaning: true,
            onTransitionEnd: onTransitionEnd
        });
    };
    Item.prototype.onHideTransitionEnd = function() {
        if (this.isHidden) {
            this.css({
                display: "none"
            });
            this.emitEvent("hide");
        }
    };
    Item.prototype.destroy = function() {
        this.css({
            position: "",
            left: "",
            right: "",
            top: "",
            bottom: "",
            transition: "",
            transform: ""
        });
    };
    return Item;
});

(function(window, factory) {
    "use strict";
    if (typeof define == "function" && define.amd) {
        define("outlayer/outlayer", [ "eventie/eventie", "eventEmitter/EventEmitter", "get-size/get-size", "fizzy-ui-utils/utils", "./item" ], function(eventie, EventEmitter, getSize, utils, Item) {
            return factory(window, eventie, EventEmitter, getSize, utils, Item);
        });
    } else if (typeof exports == "object") {
        module.exports = factory(window, require("eventie"), require("wolfy87-eventemitter"), require("get-size"), require("fizzy-ui-utils"), require("./item"));
    } else {
        window.Outlayer = factory(window, window.eventie, window.EventEmitter, window.getSize, window.fizzyUIUtils, window.Outlayer.Item);
    }
})(window, function factory(window, eventie, EventEmitter, getSize, utils, Item) {
    "use strict";
    var console = window.console;
    var jQuery = window.jQuery;
    var noop = function() {};
    var GUID = 0;
    var instances = {};
    function Outlayer(element, options) {
        var queryElement = utils.getQueryElement(element);
        if (!queryElement) {
            if (console) {
                console.error("Bad element for " + this.constructor.namespace + ": " + (queryElement || element));
            }
            return;
        }
        this.element = queryElement;
        if (jQuery) {
            this.$element = jQuery(this.element);
        }
        this.options = utils.extend({}, this.constructor.defaults);
        this.option(options);
        var id = ++GUID;
        this.element.outlayerGUID = id;
        instances[id] = this;
        this._create();
        if (this.options.isInitLayout) {
            this.layout();
        }
    }
    Outlayer.namespace = "outlayer";
    Outlayer.Item = Item;
    Outlayer.defaults = {
        containerStyle: {
            position: "relative"
        },
        isInitLayout: true,
        isOriginLeft: true,
        isOriginTop: true,
        isResizeBound: true,
        isResizingContainer: true,
        transitionDuration: "0.4s",
        hiddenStyle: {
            opacity: 0,
            transform: "scale(0.001)"
        },
        visibleStyle: {
            opacity: 1,
            transform: "scale(1)"
        }
    };
    utils.extend(Outlayer.prototype, EventEmitter.prototype);
    Outlayer.prototype.option = function(opts) {
        utils.extend(this.options, opts);
    };
    Outlayer.prototype._create = function() {
        this.reloadItems();
        this.stamps = [];
        this.stamp(this.options.stamp);
        utils.extend(this.element.style, this.options.containerStyle);
        if (this.options.isResizeBound) {
            this.bindResize();
        }
    };
    Outlayer.prototype.reloadItems = function() {
        this.items = this._itemize(this.element.children);
    };
    Outlayer.prototype._itemize = function(elems) {
        var itemElems = this._filterFindItemElements(elems);
        var Item = this.constructor.Item;
        var items = [];
        for (var i = 0, len = itemElems.length; i < len; i++) {
            var elem = itemElems[i];
            var item = new Item(elem, this);
            items.push(item);
        }
        return items;
    };
    Outlayer.prototype._filterFindItemElements = function(elems) {
        return utils.filterFindElements(elems, this.options.itemSelector);
    };
    Outlayer.prototype.getItemElements = function() {
        var elems = [];
        for (var i = 0, len = this.items.length; i < len; i++) {
            elems.push(this.items[i].element);
        }
        return elems;
    };
    Outlayer.prototype.layout = function() {
        this._resetLayout();
        this._manageStamps();
        var isInstant = this.options.isLayoutInstant !== undefined ? this.options.isLayoutInstant : !this._isLayoutInited;
        this.layoutItems(this.items, isInstant);
        this._isLayoutInited = true;
    };
    Outlayer.prototype._init = Outlayer.prototype.layout;
    Outlayer.prototype._resetLayout = function() {
        this.getSize();
    };
    Outlayer.prototype.getSize = function() {
        this.size = getSize(this.element);
    };
    Outlayer.prototype._getMeasurement = function(measurement, size) {
        var option = this.options[measurement];
        var elem;
        if (!option) {
            this[measurement] = 0;
        } else {
            if (typeof option === "string") {
                elem = this.element.querySelector(option);
            } else if (utils.isElement(option)) {
                elem = option;
            }
            this[measurement] = elem ? getSize(elem)[size] : option;
        }
    };
    Outlayer.prototype.layoutItems = function(items, isInstant) {
        items = this._getItemsForLayout(items);
        this._layoutItems(items, isInstant);
        this._postLayout();
    };
    Outlayer.prototype._getItemsForLayout = function(items) {
        var layoutItems = [];
        for (var i = 0, len = items.length; i < len; i++) {
            var item = items[i];
            if (!item.isIgnored) {
                layoutItems.push(item);
            }
        }
        return layoutItems;
    };
    Outlayer.prototype._layoutItems = function(items, isInstant) {
        this._emitCompleteOnItems("layout", items);
        if (!items || !items.length) {
            return;
        }
        var queue = [];
        for (var i = 0, len = items.length; i < len; i++) {
            var item = items[i];
            var position = this._getItemLayoutPosition(item);
            position.item = item;
            position.isInstant = isInstant || item.isLayoutInstant;
            queue.push(position);
        }
        this._processLayoutQueue(queue);
    };
    Outlayer.prototype._getItemLayoutPosition = function() {
        return {
            x: 0,
            y: 0
        };
    };
    Outlayer.prototype._processLayoutQueue = function(queue) {
        for (var i = 0, len = queue.length; i < len; i++) {
            var obj = queue[i];
            this._positionItem(obj.item, obj.x, obj.y, obj.isInstant);
        }
    };
    Outlayer.prototype._positionItem = function(item, x, y, isInstant) {
        if (isInstant) {
            item.goTo(x, y);
        } else {
            item.moveTo(x, y);
        }
    };
    Outlayer.prototype._postLayout = function() {
        this.resizeContainer();
    };
    Outlayer.prototype.resizeContainer = function() {
        if (!this.options.isResizingContainer) {
            return;
        }
        var size = this._getContainerSize();
        if (size) {
            this._setContainerMeasure(size.width, true);
            this._setContainerMeasure(size.height, false);
        }
    };
    Outlayer.prototype._getContainerSize = noop;
    Outlayer.prototype._setContainerMeasure = function(measure, isWidth) {
        if (measure === undefined) {
            return;
        }
        var elemSize = this.size;
        if (elemSize.isBorderBox) {
            measure += isWidth ? elemSize.paddingLeft + elemSize.paddingRight + elemSize.borderLeftWidth + elemSize.borderRightWidth : elemSize.paddingBottom + elemSize.paddingTop + elemSize.borderTopWidth + elemSize.borderBottomWidth;
        }
        measure = Math.max(measure, 0);
        this.element.style[isWidth ? "width" : "height"] = measure + "px";
    };
    Outlayer.prototype._emitCompleteOnItems = function(eventName, items) {
        var _this = this;
        function onComplete() {
            _this.dispatchEvent(eventName + "Complete", null, [ items ]);
        }
        var count = items.length;
        if (!items || !count) {
            onComplete();
            return;
        }
        var doneCount = 0;
        function tick() {
            doneCount++;
            if (doneCount === count) {
                onComplete();
            }
        }
        for (var i = 0, len = items.length; i < len; i++) {
            var item = items[i];
            item.once(eventName, tick);
        }
    };
    Outlayer.prototype.dispatchEvent = function(type, event, args) {
        var emitArgs = event ? [ event ].concat(args) : args;
        this.emitEvent(type, emitArgs);
        if (jQuery) {
            this.$element = this.$element || jQuery(this.element);
            if (event) {
                var $event = jQuery.Event(event);
                $event.type = type;
                this.$element.trigger($event, args);
            } else {
                this.$element.trigger(type, args);
            }
        }
    };
    Outlayer.prototype.ignore = function(elem) {
        var item = this.getItem(elem);
        if (item) {
            item.isIgnored = true;
        }
    };
    Outlayer.prototype.unignore = function(elem) {
        var item = this.getItem(elem);
        if (item) {
            delete item.isIgnored;
        }
    };
    Outlayer.prototype.stamp = function(elems) {
        elems = this._find(elems);
        if (!elems) {
            return;
        }
        this.stamps = this.stamps.concat(elems);
        for (var i = 0, len = elems.length; i < len; i++) {
            var elem = elems[i];
            this.ignore(elem);
        }
    };
    Outlayer.prototype.unstamp = function(elems) {
        elems = this._find(elems);
        if (!elems) {
            return;
        }
        for (var i = 0, len = elems.length; i < len; i++) {
            var elem = elems[i];
            utils.removeFrom(this.stamps, elem);
            this.unignore(elem);
        }
    };
    Outlayer.prototype._find = function(elems) {
        if (!elems) {
            return;
        }
        if (typeof elems === "string") {
            elems = this.element.querySelectorAll(elems);
        }
        elems = utils.makeArray(elems);
        return elems;
    };
    Outlayer.prototype._manageStamps = function() {
        if (!this.stamps || !this.stamps.length) {
            return;
        }
        this._getBoundingRect();
        for (var i = 0, len = this.stamps.length; i < len; i++) {
            var stamp = this.stamps[i];
            this._manageStamp(stamp);
        }
    };
    Outlayer.prototype._getBoundingRect = function() {
        var boundingRect = this.element.getBoundingClientRect();
        var size = this.size;
        this._boundingRect = {
            left: boundingRect.left + size.paddingLeft + size.borderLeftWidth,
            top: boundingRect.top + size.paddingTop + size.borderTopWidth,
            right: boundingRect.right - (size.paddingRight + size.borderRightWidth),
            bottom: boundingRect.bottom - (size.paddingBottom + size.borderBottomWidth)
        };
    };
    Outlayer.prototype._manageStamp = noop;
    Outlayer.prototype._getElementOffset = function(elem) {
        var boundingRect = elem.getBoundingClientRect();
        var thisRect = this._boundingRect;
        var size = getSize(elem);
        var offset = {
            left: boundingRect.left - thisRect.left - size.marginLeft,
            top: boundingRect.top - thisRect.top - size.marginTop,
            right: thisRect.right - boundingRect.right - size.marginRight,
            bottom: thisRect.bottom - boundingRect.bottom - size.marginBottom
        };
        return offset;
    };
    Outlayer.prototype.handleEvent = function(event) {
        var method = "on" + event.type;
        if (this[method]) {
            this[method](event);
        }
    };
    Outlayer.prototype.bindResize = function() {
        if (this.isResizeBound) {
            return;
        }
        eventie.bind(window, "resize", this);
        this.isResizeBound = true;
    };
    Outlayer.prototype.unbindResize = function() {
        if (this.isResizeBound) {
            eventie.unbind(window, "resize", this);
        }
        this.isResizeBound = false;
    };
    Outlayer.prototype.onresize = function() {
        if (this.resizeTimeout) {
            clearTimeout(this.resizeTimeout);
        }
        var _this = this;
        function delayed() {
            _this.resize();
            delete _this.resizeTimeout;
        }
        this.resizeTimeout = setTimeout(delayed, 100);
    };
    Outlayer.prototype.resize = function() {
        if (!this.isResizeBound || !this.needsResizeLayout()) {
            return;
        }
        this.layout();
    };
    Outlayer.prototype.needsResizeLayout = function() {
        var size = getSize(this.element);
        var hasSizes = this.size && size;
        return hasSizes && size.innerWidth !== this.size.innerWidth;
    };
    Outlayer.prototype.addItems = function(elems) {
        var items = this._itemize(elems);
        if (items.length) {
            this.items = this.items.concat(items);
        }
        return items;
    };
    Outlayer.prototype.appended = function(elems) {
        var items = this.addItems(elems);
        if (!items.length) {
            return;
        }
        this.layoutItems(items, true);
        this.reveal(items);
    };
    Outlayer.prototype.prepended = function(elems) {
        var items = this._itemize(elems);
        if (!items.length) {
            return;
        }
        var previousItems = this.items.slice(0);
        this.items = items.concat(previousItems);
        this._resetLayout();
        this._manageStamps();
        this.layoutItems(items, true);
        this.reveal(items);
        this.layoutItems(previousItems);
    };
    Outlayer.prototype.reveal = function(items) {
        this._emitCompleteOnItems("reveal", items);
        var len = items && items.length;
        for (var i = 0; len && i < len; i++) {
            var item = items[i];
            item.reveal();
        }
    };
    Outlayer.prototype.hide = function(items) {
        this._emitCompleteOnItems("hide", items);
        var len = items && items.length;
        for (var i = 0; len && i < len; i++) {
            var item = items[i];
            item.hide();
        }
    };
    Outlayer.prototype.revealItemElements = function(elems) {
        var items = this.getItems(elems);
        this.reveal(items);
    };
    Outlayer.prototype.hideItemElements = function(elems) {
        var items = this.getItems(elems);
        this.hide(items);
    };
    Outlayer.prototype.getItem = function(elem) {
        for (var i = 0, len = this.items.length; i < len; i++) {
            var item = this.items[i];
            if (item.element === elem) {
                return item;
            }
        }
    };
    Outlayer.prototype.getItems = function(elems) {
        elems = utils.makeArray(elems);
        var items = [];
        for (var i = 0, len = elems.length; i < len; i++) {
            var elem = elems[i];
            var item = this.getItem(elem);
            if (item) {
                items.push(item);
            }
        }
        return items;
    };
    Outlayer.prototype.remove = function(elems) {
        var removeItems = this.getItems(elems);
        this._emitCompleteOnItems("remove", removeItems);
        if (!removeItems || !removeItems.length) {
            return;
        }
        for (var i = 0, len = removeItems.length; i < len; i++) {
            var item = removeItems[i];
            item.remove();
            utils.removeFrom(this.items, item);
        }
    };
    Outlayer.prototype.destroy = function() {
        var style = this.element.style;
        style.height = "";
        style.position = "";
        style.width = "";
        for (var i = 0, len = this.items.length; i < len; i++) {
            var item = this.items[i];
            item.destroy();
        }
        this.unbindResize();
        var id = this.element.outlayerGUID;
        delete instances[id];
        delete this.element.outlayerGUID;
        if (jQuery) {
            jQuery.removeData(this.element, this.constructor.namespace);
        }
    };
    Outlayer.data = function(elem) {
        elem = utils.getQueryElement(elem);
        var id = elem && elem.outlayerGUID;
        return id && instances[id];
    };
    Outlayer.create = function(namespace, options) {
        function Layout() {
            Outlayer.apply(this, arguments);
        }
        if (Object.create) {
            Layout.prototype = Object.create(Outlayer.prototype);
        } else {
            utils.extend(Layout.prototype, Outlayer.prototype);
        }
        Layout.prototype.constructor = Layout;
        Layout.defaults = utils.extend({}, Outlayer.defaults);
        utils.extend(Layout.defaults, options);
        Layout.prototype.settings = {};
        Layout.namespace = namespace;
        Layout.data = Outlayer.data;
        Layout.Item = function LayoutItem() {
            Item.apply(this, arguments);
        };
        Layout.Item.prototype = new Item();
        utils.htmlInit(Layout, namespace);
        if (jQuery && jQuery.bridget) {
            jQuery.bridget(namespace, Layout);
        }
        return Layout;
    };
    Outlayer.Item = Item;
    return Outlayer;
});

(function(window, factory) {
    "use strict";
    if (typeof define == "function" && define.amd) {
        define("isotope/js/item", [ "outlayer/outlayer" ], factory);
    } else if (typeof exports == "object") {
        module.exports = factory(require("outlayer"));
    } else {
        window.Isotope = window.Isotope || {};
        window.Isotope.Item = factory(window.Outlayer);
    }
})(window, function factory(Outlayer) {
    "use strict";
    function Item() {
        Outlayer.Item.apply(this, arguments);
    }
    Item.prototype = new Outlayer.Item();
    Item.prototype._create = function() {
        this.id = this.layout.itemGUID++;
        Outlayer.Item.prototype._create.call(this);
        this.sortData = {};
    };
    Item.prototype.updateSortData = function() {
        if (this.isIgnored) {
            return;
        }
        this.sortData.id = this.id;
        this.sortData["original-order"] = this.id;
        this.sortData.random = Math.random();
        var getSortData = this.layout.options.getSortData;
        var sorters = this.layout._sorters;
        for (var key in getSortData) {
            var sorter = sorters[key];
            this.sortData[key] = sorter(this.element, this);
        }
    };
    var _destroy = Item.prototype.destroy;
    Item.prototype.destroy = function() {
        _destroy.apply(this, arguments);
        this.css({
            display: ""
        });
    };
    return Item;
});

(function(window, factory) {
    "use strict";
    if (typeof define == "function" && define.amd) {
        define("isotope/js/layout-mode", [ "get-size/get-size", "outlayer/outlayer" ], factory);
    } else if (typeof exports == "object") {
        module.exports = factory(require("get-size"), require("outlayer"));
    } else {
        window.Isotope = window.Isotope || {};
        window.Isotope.LayoutMode = factory(window.getSize, window.Outlayer);
    }
})(window, function factory(getSize, Outlayer) {
    "use strict";
    function LayoutMode(isotope) {
        this.isotope = isotope;
        if (isotope) {
            this.options = isotope.options[this.namespace];
            this.element = isotope.element;
            this.items = isotope.filteredItems;
            this.size = isotope.size;
        }
    }
    (function() {
        var facadeMethods = [ "_resetLayout", "_getItemLayoutPosition", "_manageStamp", "_getContainerSize", "_getElementOffset", "needsResizeLayout" ];
        for (var i = 0, len = facadeMethods.length; i < len; i++) {
            var methodName = facadeMethods[i];
            LayoutMode.prototype[methodName] = getOutlayerMethod(methodName);
        }
        function getOutlayerMethod(methodName) {
            return function() {
                return Outlayer.prototype[methodName].apply(this.isotope, arguments);
            };
        }
    })();
    LayoutMode.prototype.needsVerticalResizeLayout = function() {
        var size = getSize(this.isotope.element);
        var hasSizes = this.isotope.size && size;
        return hasSizes && size.innerHeight != this.isotope.size.innerHeight;
    };
    LayoutMode.prototype._getMeasurement = function() {
        this.isotope._getMeasurement.apply(this, arguments);
    };
    LayoutMode.prototype.getColumnWidth = function() {
        this.getSegmentSize("column", "Width");
    };
    LayoutMode.prototype.getRowHeight = function() {
        this.getSegmentSize("row", "Height");
    };
    LayoutMode.prototype.getSegmentSize = function(segment, size) {
        var segmentName = segment + size;
        var outerSize = "outer" + size;
        this._getMeasurement(segmentName, outerSize);
        if (this[segmentName]) {
            return;
        }
        var firstItemSize = this.getFirstItemSize();
        this[segmentName] = firstItemSize && firstItemSize[outerSize] || this.isotope.size["inner" + size];
    };
    LayoutMode.prototype.getFirstItemSize = function() {
        var firstItem = this.isotope.filteredItems[0];
        return firstItem && firstItem.element && getSize(firstItem.element);
    };
    LayoutMode.prototype.layout = function() {
        this.isotope.layout.apply(this.isotope, arguments);
    };
    LayoutMode.prototype.getSize = function() {
        this.isotope.getSize();
        this.size = this.isotope.size;
    };
    LayoutMode.modes = {};
    LayoutMode.create = function(namespace, options) {
        function Mode() {
            LayoutMode.apply(this, arguments);
        }
        Mode.prototype = new LayoutMode();
        if (options) {
            Mode.options = options;
        }
        Mode.prototype.namespace = namespace;
        LayoutMode.modes[namespace] = Mode;
        return Mode;
    };
    return LayoutMode;
});

(function(window, factory) {
    "use strict";
    if (typeof define === "function" && define.amd) {
        define("masonry/masonry", [ "outlayer/outlayer", "get-size/get-size", "fizzy-ui-utils/utils" ], factory);
    } else if (typeof exports === "object") {
        module.exports = factory(require("outlayer"), require("get-size"), require("fizzy-ui-utils"));
    } else {
        window.Masonry = factory(window.Outlayer, window.getSize, window.fizzyUIUtils);
    }
})(window, function factory(Outlayer, getSize, utils) {
    var Masonry = Outlayer.create("masonry");
    Masonry.prototype._resetLayout = function() {
        this.getSize();
        this._getMeasurement("columnWidth", "outerWidth");
        this._getMeasurement("gutter", "outerWidth");
        this.measureColumns();
        var i = this.cols;
        this.colYs = [];
        while (i--) {
            this.colYs.push(0);
        }
        this.maxY = 0;
    };
    Masonry.prototype.measureColumns = function() {
        this.getContainerWidth();
        if (!this.columnWidth) {
            var firstItem = this.items[0];
            var firstItemElem = firstItem && firstItem.element;
            this.columnWidth = firstItemElem && getSize(firstItemElem).outerWidth || this.containerWidth;
        }
        var columnWidth = this.columnWidth += this.gutter;
        var containerWidth = this.containerWidth + this.gutter;
        var cols = containerWidth / columnWidth;
        var excess = columnWidth - containerWidth % columnWidth;
        var mathMethod = excess && excess < 1 ? "round" : "floor";
        cols = Math[mathMethod](cols);
        this.cols = Math.max(cols, 1);
    };
    Masonry.prototype.getContainerWidth = function() {
        var container = this.options.isFitWidth ? this.element.parentNode : this.element;
        var size = getSize(container);
        this.containerWidth = size && size.innerWidth;
    };
    Masonry.prototype._getItemLayoutPosition = function(item) {
        item.getSize();
        var remainder = item.size.outerWidth % this.columnWidth;
        var mathMethod = remainder && remainder < 1 ? "round" : "ceil";
        var colSpan = Math[mathMethod](item.size.outerWidth / this.columnWidth);
        colSpan = Math.min(colSpan, this.cols);
        var colGroup = this._getColGroup(colSpan);
        var minimumY = Math.min.apply(Math, colGroup);
        var shortColIndex = utils.indexOf(colGroup, minimumY);
        var position = {
            x: this.columnWidth * shortColIndex,
            y: minimumY
        };
        var setHeight = minimumY + item.size.outerHeight;
        var setSpan = this.cols + 1 - colGroup.length;
        for (var i = 0; i < setSpan; i++) {
            this.colYs[shortColIndex + i] = setHeight;
        }
        return position;
    };
    Masonry.prototype._getColGroup = function(colSpan) {
        if (colSpan < 2) {
            return this.colYs;
        }
        var colGroup = [];
        var groupCount = this.cols + 1 - colSpan;
        for (var i = 0; i < groupCount; i++) {
            var groupColYs = this.colYs.slice(i, i + colSpan);
            colGroup[i] = Math.max.apply(Math, groupColYs);
        }
        return colGroup;
    };
    Masonry.prototype._manageStamp = function(stamp) {
        var stampSize = getSize(stamp);
        var offset = this._getElementOffset(stamp);
        var firstX = this.options.isOriginLeft ? offset.left : offset.right;
        var lastX = firstX + stampSize.outerWidth;
        var firstCol = Math.floor(firstX / this.columnWidth);
        firstCol = Math.max(0, firstCol);
        var lastCol = Math.floor(lastX / this.columnWidth);
        lastCol -= lastX % this.columnWidth ? 0 : 1;
        lastCol = Math.min(this.cols - 1, lastCol);
        var stampMaxY = (this.options.isOriginTop ? offset.top : offset.bottom) + stampSize.outerHeight;
        for (var i = firstCol; i <= lastCol; i++) {
            this.colYs[i] = Math.max(stampMaxY, this.colYs[i]);
        }
    };
    Masonry.prototype._getContainerSize = function() {
        this.maxY = Math.max.apply(Math, this.colYs);
        var size = {
            height: this.maxY
        };
        if (this.options.isFitWidth) {
            size.width = this._getContainerFitWidth();
        }
        return size;
    };
    Masonry.prototype._getContainerFitWidth = function() {
        var unusedCols = 0;
        var i = this.cols;
        while (--i) {
            if (this.colYs[i] !== 0) {
                break;
            }
            unusedCols++;
        }
        return (this.cols - unusedCols) * this.columnWidth - this.gutter;
    };
    Masonry.prototype.needsResizeLayout = function() {
        var previousWidth = this.containerWidth;
        this.getContainerWidth();
        return previousWidth !== this.containerWidth;
    };
    return Masonry;
});

(function(window, factory) {
    "use strict";
    if (typeof define == "function" && define.amd) {
        define("isotope/js/layout-modes/masonry", [ "../layout-mode", "masonry/masonry" ], factory);
    } else if (typeof exports == "object") {
        module.exports = factory(require("../layout-mode"), require("masonry-layout"));
    } else {
        factory(window.Isotope.LayoutMode, window.Masonry);
    }
})(window, function factory(LayoutMode, Masonry) {
    "use strict";
    function extend(a, b) {
        for (var prop in b) {
            a[prop] = b[prop];
        }
        return a;
    }
    var MasonryMode = LayoutMode.create("masonry");
    var _getElementOffset = MasonryMode.prototype._getElementOffset;
    var layout = MasonryMode.prototype.layout;
    var _getMeasurement = MasonryMode.prototype._getMeasurement;
    extend(MasonryMode.prototype, Masonry.prototype);
    MasonryMode.prototype._getElementOffset = _getElementOffset;
    MasonryMode.prototype.layout = layout;
    MasonryMode.prototype._getMeasurement = _getMeasurement;
    var measureColumns = MasonryMode.prototype.measureColumns;
    MasonryMode.prototype.measureColumns = function() {
        this.items = this.isotope.filteredItems;
        measureColumns.call(this);
    };
    var _manageStamp = MasonryMode.prototype._manageStamp;
    MasonryMode.prototype._manageStamp = function() {
        this.options.isOriginLeft = this.isotope.options.isOriginLeft;
        this.options.isOriginTop = this.isotope.options.isOriginTop;
        _manageStamp.apply(this, arguments);
    };
    return MasonryMode;
});

(function(window, factory) {
    "use strict";
    if (typeof define == "function" && define.amd) {
        define("isotope/js/layout-modes/fit-rows", [ "../layout-mode" ], factory);
    } else if (typeof exports == "object") {
        module.exports = factory(require("../layout-mode"));
    } else {
        factory(window.Isotope.LayoutMode);
    }
})(window, function factory(LayoutMode) {
    "use strict";
    var FitRows = LayoutMode.create("fitRows");
    FitRows.prototype._resetLayout = function() {
        this.x = 0;
        this.y = 0;
        this.maxY = 0;
        this._getMeasurement("gutter", "outerWidth");
    };
    FitRows.prototype._getItemLayoutPosition = function(item) {
        item.getSize();
        var itemWidth = item.size.outerWidth + this.gutter;
        var containerWidth = this.isotope.size.innerWidth + this.gutter;
        if (this.x !== 0 && itemWidth + this.x > containerWidth) {
            this.x = 0;
            this.y = this.maxY;
        }
        var position = {
            x: this.x,
            y: this.y
        };
        this.maxY = Math.max(this.maxY, this.y + item.size.outerHeight);
        this.x += itemWidth;
        return position;
    };
    FitRows.prototype._getContainerSize = function() {
        return {
            height: this.maxY
        };
    };
    return FitRows;
});

(function(window, factory) {
    "use strict";
    if (typeof define == "function" && define.amd) {
        define("isotope/js/layout-modes/vertical", [ "../layout-mode" ], factory);
    } else if (typeof exports == "object") {
        module.exports = factory(require("../layout-mode"));
    } else {
        factory(window.Isotope.LayoutMode);
    }
})(window, function factory(LayoutMode) {
    "use strict";
    var Vertical = LayoutMode.create("vertical", {
        horizontalAlignment: 0
    });
    Vertical.prototype._resetLayout = function() {
        this.y = 0;
    };
    Vertical.prototype._getItemLayoutPosition = function(item) {
        item.getSize();
        var x = (this.isotope.size.innerWidth - item.size.outerWidth) * this.options.horizontalAlignment;
        var y = this.y;
        this.y += item.size.outerHeight;
        return {
            x: x,
            y: y
        };
    };
    Vertical.prototype._getContainerSize = function() {
        return {
            height: this.y
        };
    };
    return Vertical;
});

(function(window, factory) {
    "use strict";
    if (typeof define == "function" && define.amd) {
        define([ "outlayer/outlayer", "get-size/get-size", "matches-selector/matches-selector", "fizzy-ui-utils/utils", "isotope/js/item", "isotope/js/layout-mode", "isotope/js/layout-modes/masonry", "isotope/js/layout-modes/fit-rows", "isotope/js/layout-modes/vertical" ], function(Outlayer, getSize, matchesSelector, utils, Item, LayoutMode) {
            return factory(window, Outlayer, getSize, matchesSelector, utils, Item, LayoutMode);
        });
    } else if (typeof exports == "object") {
        module.exports = factory(window, require("outlayer"), require("get-size"), require("desandro-matches-selector"), require("fizzy-ui-utils"), require("./item"), require("./layout-mode"), require("./layout-modes/masonry"), require("./layout-modes/fit-rows"), require("./layout-modes/vertical"));
    } else {
        window.Isotope = factory(window, window.Outlayer, window.getSize, window.matchesSelector, window.fizzyUIUtils, window.Isotope.Item, window.Isotope.LayoutMode);
    }
})(window, function factory(window, Outlayer, getSize, matchesSelector, utils, Item, LayoutMode) {
    var jQuery = window.jQuery;
    var trim = String.prototype.trim ? function(str) {
        return str.trim();
    } : function(str) {
        return str.replace(/^\s+|\s+$/g, "");
    };
    var docElem = document.documentElement;
    var getText = docElem.textContent ? function(elem) {
        return elem.textContent;
    } : function(elem) {
        return elem.innerText;
    };
    var Isotope = Outlayer.create("isotope", {
        layoutMode: "masonry",
        isJQueryFiltering: true,
        sortAscending: true
    });
    Isotope.Item = Item;
    Isotope.LayoutMode = LayoutMode;
    Isotope.prototype._create = function() {
        this.itemGUID = 0;
        this._sorters = {};
        this._getSorters();
        Outlayer.prototype._create.call(this);
        this.modes = {};
        this.filteredItems = this.items;
        this.sortHistory = [ "original-order" ];
        for (var name in LayoutMode.modes) {
            this._initLayoutMode(name);
        }
    };
    Isotope.prototype.reloadItems = function() {
        this.itemGUID = 0;
        Outlayer.prototype.reloadItems.call(this);
    };
    Isotope.prototype._itemize = function() {
        var items = Outlayer.prototype._itemize.apply(this, arguments);
        for (var i = 0, len = items.length; i < len; i++) {
            var item = items[i];
            item.id = this.itemGUID++;
        }
        this._updateItemsSortData(items);
        return items;
    };
    Isotope.prototype._initLayoutMode = function(name) {
        var Mode = LayoutMode.modes[name];
        var initialOpts = this.options[name] || {};
        this.options[name] = Mode.options ? utils.extend(Mode.options, initialOpts) : initialOpts;
        this.modes[name] = new Mode(this);
    };
    Isotope.prototype.layout = function() {
        if (!this._isLayoutInited && this.options.isInitLayout) {
            this.arrange();
            return;
        }
        this._layout();
    };
    Isotope.prototype._layout = function() {
        var isInstant = this._getIsInstant();
        this._resetLayout();
        this._manageStamps();
        this.layoutItems(this.filteredItems, isInstant);
        this._isLayoutInited = true;
    };
    Isotope.prototype.arrange = function(opts) {
        this.option(opts);
        this._getIsInstant();
        var filtered = this._filter(this.items);
        this.filteredItems = filtered.matches;
        var _this = this;
        function hideReveal() {
            _this.reveal(filtered.needReveal);
            _this.hide(filtered.needHide);
        }
        this._bindArrangeComplete();
        if (this._isInstant) {
            this._noTransition(hideReveal);
        } else {
            hideReveal();
        }
        this._sort();
        this._layout();
    };
    Isotope.prototype._init = Isotope.prototype.arrange;
    Isotope.prototype._getIsInstant = function() {
        var isInstant = this.options.isLayoutInstant !== undefined ? this.options.isLayoutInstant : !this._isLayoutInited;
        this._isInstant = isInstant;
        return isInstant;
    };
    Isotope.prototype._bindArrangeComplete = function() {
        var isLayoutComplete, isHideComplete, isRevealComplete;
        var _this = this;
        function arrangeParallelCallback() {
            if (isLayoutComplete && isHideComplete && isRevealComplete) {
                _this.dispatchEvent("arrangeComplete", null, [ _this.filteredItems ]);
            }
        }
        this.once("layoutComplete", function() {
            isLayoutComplete = true;
            arrangeParallelCallback();
        });
        this.once("hideComplete", function() {
            isHideComplete = true;
            arrangeParallelCallback();
        });
        this.once("revealComplete", function() {
            isRevealComplete = true;
            arrangeParallelCallback();
        });
    };
    Isotope.prototype._filter = function(items) {
        var filter = this.options.filter;
        filter = filter || "*";
        var matches = [];
        var hiddenMatched = [];
        var visibleUnmatched = [];
        var test = this._getFilterTest(filter);
        for (var i = 0, len = items.length; i < len; i++) {
            var item = items[i];
            if (item.isIgnored) {
                continue;
            }
            var isMatched = test(item);
            if (isMatched) {
                matches.push(item);
            }
            if (isMatched && item.isHidden) {
                hiddenMatched.push(item);
            } else if (!isMatched && !item.isHidden) {
                visibleUnmatched.push(item);
            }
        }
        return {
            matches: matches,
            needReveal: hiddenMatched,
            needHide: visibleUnmatched
        };
    };
    Isotope.prototype._getFilterTest = function(filter) {
        if (jQuery && this.options.isJQueryFiltering) {
            return function(item) {
                return jQuery(item.element).is(filter);
            };
        }
        if (typeof filter == "function") {
            return function(item) {
                return filter(item.element);
            };
        }
        return function(item) {
            return matchesSelector(item.element, filter);
        };
    };
    Isotope.prototype.updateSortData = function(elems) {
        var items;
        if (elems) {
            elems = utils.makeArray(elems);
            items = this.getItems(elems);
        } else {
            items = this.items;
        }
        this._getSorters();
        this._updateItemsSortData(items);
    };
    Isotope.prototype._getSorters = function() {
        var getSortData = this.options.getSortData;
        for (var key in getSortData) {
            var sorter = getSortData[key];
            this._sorters[key] = mungeSorter(sorter);
        }
    };
    Isotope.prototype._updateItemsSortData = function(items) {
        var len = items && items.length;
        for (var i = 0; len && i < len; i++) {
            var item = items[i];
            item.updateSortData();
        }
    };
    var mungeSorter = function() {
        function mungeSorter(sorter) {
            if (typeof sorter != "string") {
                return sorter;
            }
            var args = trim(sorter).split(" ");
            var query = args[0];
            var attrMatch = query.match(/^\[(.+)\]$/);
            var attr = attrMatch && attrMatch[1];
            var getValue = getValueGetter(attr, query);
            var parser = Isotope.sortDataParsers[args[1]];
            sorter = parser ? function(elem) {
                return elem && parser(getValue(elem));
            } : function(elem) {
                return elem && getValue(elem);
            };
            return sorter;
        }
        function getValueGetter(attr, query) {
            var getValue;
            if (attr) {
                getValue = function(elem) {
                    return elem.getAttribute(attr);
                };
            } else {
                getValue = function(elem) {
                    var child = elem.querySelector(query);
                    return child && getText(child);
                };
            }
            return getValue;
        }
        return mungeSorter;
    }();
    Isotope.sortDataParsers = {
        parseInt: function(val) {
            return parseInt(val, 10);
        },
        parseFloat: function(val) {
            return parseFloat(val);
        }
    };
    Isotope.prototype._sort = function() {
        var sortByOpt = this.options.sortBy;
        if (!sortByOpt) {
            return;
        }
        var sortBys = [].concat.apply(sortByOpt, this.sortHistory);
        var itemSorter = getItemSorter(sortBys, this.options.sortAscending);
        this.filteredItems.sort(itemSorter);
        if (sortByOpt != this.sortHistory[0]) {
            this.sortHistory.unshift(sortByOpt);
        }
    };
    function getItemSorter(sortBys, sortAsc) {
        return function sorter(itemA, itemB) {
            for (var i = 0, len = sortBys.length; i < len; i++) {
                var sortBy = sortBys[i];
                var a = itemA.sortData[sortBy];
                var b = itemB.sortData[sortBy];
                if (a > b || a < b) {
                    var isAscending = sortAsc[sortBy] !== undefined ? sortAsc[sortBy] : sortAsc;
                    var direction = isAscending ? 1 : -1;
                    return (a > b ? 1 : -1) * direction;
                }
            }
            return 0;
        };
    }
    Isotope.prototype._mode = function() {
        var layoutMode = this.options.layoutMode;
        var mode = this.modes[layoutMode];
        if (!mode) {
            throw new Error("No layout mode: " + layoutMode);
        }
        mode.options = this.options[layoutMode];
        return mode;
    };
    Isotope.prototype._resetLayout = function() {
        Outlayer.prototype._resetLayout.call(this);
        this._mode()._resetLayout();
    };
    Isotope.prototype._getItemLayoutPosition = function(item) {
        return this._mode()._getItemLayoutPosition(item);
    };
    Isotope.prototype._manageStamp = function(stamp) {
        this._mode()._manageStamp(stamp);
    };
    Isotope.prototype._getContainerSize = function() {
        return this._mode()._getContainerSize();
    };
    Isotope.prototype.needsResizeLayout = function() {
        return this._mode().needsResizeLayout();
    };
    Isotope.prototype.appended = function(elems) {
        var items = this.addItems(elems);
        if (!items.length) {
            return;
        }
        var filteredItems = this._filterRevealAdded(items);
        this.filteredItems = this.filteredItems.concat(filteredItems);
    };
    Isotope.prototype.prepended = function(elems) {
        var items = this._itemize(elems);
        if (!items.length) {
            return;
        }
        this._resetLayout();
        this._manageStamps();
        var filteredItems = this._filterRevealAdded(items);
        this.layoutItems(this.filteredItems);
        this.filteredItems = filteredItems.concat(this.filteredItems);
        this.items = items.concat(this.items);
    };
    Isotope.prototype._filterRevealAdded = function(items) {
        var filtered = this._filter(items);
        this.hide(filtered.needHide);
        this.reveal(filtered.matches);
        this.layoutItems(filtered.matches, true);
        return filtered.matches;
    };
    Isotope.prototype.insert = function(elems) {
        var items = this.addItems(elems);
        if (!items.length) {
            return;
        }
        var i, item;
        var len = items.length;
        for (i = 0; i < len; i++) {
            item = items[i];
            this.element.appendChild(item.element);
        }
        var filteredInsertItems = this._filter(items).matches;
        for (i = 0; i < len; i++) {
            items[i].isLayoutInstant = true;
        }
        this.arrange();
        for (i = 0; i < len; i++) {
            delete items[i].isLayoutInstant;
        }
        this.reveal(filteredInsertItems);
    };
    var _remove = Isotope.prototype.remove;
    Isotope.prototype.remove = function(elems) {
        elems = utils.makeArray(elems);
        var removeItems = this.getItems(elems);
        _remove.call(this, elems);
        var len = removeItems && removeItems.length;
        if (!len) {
            return;
        }
        for (var i = 0; i < len; i++) {
            var item = removeItems[i];
            utils.removeFrom(this.filteredItems, item);
        }
    };
    Isotope.prototype.shuffle = function() {
        for (var i = 0, len = this.items.length; i < len; i++) {
            var item = this.items[i];
            item.sortData.random = Math.random();
        }
        this.options.sortBy = "random";
        this._sort();
        this._layout();
    };
    Isotope.prototype._noTransition = function(fn) {
        var transitionDuration = this.options.transitionDuration;
        this.options.transitionDuration = 0;
        var returnValue = fn.call(this);
        this.options.transitionDuration = transitionDuration;
        return returnValue;
    };
    Isotope.prototype.getFilteredItemElements = function() {
        var elems = [];
        for (var i = 0, len = this.filteredItems.length; i < len; i++) {
            elems.push(this.filteredItems[i].element);
        }
        return elems;
    };
    return Isotope;
});

$(document).ready(function() {
    $(".certTile").click(function(e) {
        if ($(window).innerWidth() > 500) {
            if ($(e.target).is("a")) {
                return;
            }
            if ($(this).hasClass("readMore")) {
                $(this).removeClass("readMore");
            } else {
                $(this).addClass("readMore");
            }
        }
    });
    if ($(window).innerWidth() < 500) {
        $(".certificationTilesGrid .content a").text("View");
    }
    $(window).resize(function() {
        if ($(window).innerWidth() < 500) {
            $(".certificationTilesGrid .content a").text("View");
            setTimeout(function() {
                $container.isotope();
            }, 2e3);
        } else {
            $(".certificationTilesGrid .content a").text("Click For Details");
        }
    });
    var $container = $(".certificationTilesGrid").isotope({
        itemSelector: ".certTile, .splide__slide",
        layoutMode: "fitRows"
    });
    $("#careers").val("*");
    $("#levels").val("*");
    function GetQueryStringParams(sParam) {
        var sPageURL = window.location.search.substring(1);
        var sURLVariables = sPageURL.split("&");
        for (var i = 0; i < sURLVariables.length; i++) {
            var sParameterName = sURLVariables[i].split("=");
            if (sParameterName[0] == sParam) {
                return sParameterName[1];
            }
        }
    }
    var level = GetQueryStringParams("level");
    if (level != null) {
        level = "." + level;
        $container.isotope({
            filter: level
        });
        $("#levels").val(level);
    }
    $("#ViewAll").click(function() {
        $("#careers").val("*");
        $("#levels").val("*");
        $container.isotope({
            filter: "*"
        });
    });
    var selects = $(".filters select");
    selects.on("change", function() {
        var filters = "";
        if ($("#levels option:selected").val() == "*" && $("#careers option:selected").val() == "*") {
            filters = "*";
        } else {
            filters = filters + $("#levels option:selected").val();
            filters = filters + $("#careers option:selected").val();
        }
        $container.isotope({
            filter: filters
        });
    });
});

$(document).ready(function() {
    if ($(window).innerWidth() < 500) {
        $(".blogJobsTilesGrid .content a").text("View");
    }
    $(window).resize(function() {
        if ($(window).innerWidth() < 500) {
            $(".blogJobsTilesGrid .content a").text("View");
            setTimeout(function() {
                $jobBlogContainer.isotope();
            }, 2e3);
        } else {
            $(".blogJobsTilesGrid .content a").text("Click For Details");
        }
    });
    var $jobBlogContainer = $(".blogJobsTilesGrid").isotope({
        itemSelector: ".jobBoxTile",
        layoutMode: "fitRows"
    });
    $("#jobBlogsCareers").val("*");
    function GetQueryStringParams(sParam) {
        var sPageURL = window.location.search.substring(1);
        var sURLVariables = sPageURL.split("&");
        for (var i = 0; i < sURLVariables.length; i++) {
            var sParameterName = sURLVariables[i].split("=");
            if (sParameterName[0] == sParam) {
                return sParameterName[1];
            }
        }
    }
    var level = GetQueryStringParams("level");
    if (level != null) {
        level = "." + level;
        $jobBlogContainer.isotope({
            filter: level
        });
        $("#jobBlogsCareers").val(level);
    }
    $("#ViewAll").click(function() {
        $("#jobBlogsCareers").val("*");
        $jobBlogContainer.isotope({
            filter: "*"
        });
    });
    var selects = $(".filters select");
    selects.on("change", function() {
        var filters = "";
        if ($("#jobBlogsCareers option:selected").val() == "*") {
            filters = "*";
        } else {
            filters = filters + $("#jobBlogsCareers option:selected").val();
        }
        $jobBlogContainer.isotope({
            filter: filters
        });
    });
});

(function(root, factory) {
    if (typeof define === "function" && define.amd) {
        define([], factory(root));
    } else if (typeof exports === "object") {
        module.exports = factory(root);
    } else {
        root.smoothScroll = factory(root);
    }
})(typeof global !== "undefined" ? global : this.window || this.global, function(root) {
    "use strict";
    var smoothScroll = {};
    var supports = !!root.document.querySelector && !!root.addEventListener;
    var settings, eventTimeout, fixedHeader, headerHeight;
    var defaults = {
        speed: 500,
        easing: "easeInOutCubic",
        offset: 0,
        updateURL: true,
        callbackBefore: function() {},
        callbackAfter: function() {}
    };
    var forEach = function(collection, callback, scope) {
        if (Object.prototype.toString.call(collection) === "[object Object]") {
            for (var prop in collection) {
                if (Object.prototype.hasOwnProperty.call(collection, prop)) {
                    callback.call(scope, collection[prop], prop, collection);
                }
            }
        } else {
            for (var i = 0, len = collection.length; i < len; i++) {
                callback.call(scope, collection[i], i, collection);
            }
        }
    };
    var extend = function(defaults, options) {
        var extended = {};
        forEach(defaults, function(value, prop) {
            extended[prop] = defaults[prop];
        });
        forEach(options, function(value, prop) {
            extended[prop] = options[prop];
        });
        return extended;
    };
    var getClosest = function(elem, selector) {
        var firstChar = selector.charAt(0);
        for (;elem && elem !== root.document; elem = elem.parentNode) {
            if (firstChar === ".") {
                if (elem.classList.contains(selector.substr(1))) {
                    return elem;
                }
            } else if (firstChar === "#") {
                if (elem.id === selector.substr(1)) {
                    return elem;
                }
            } else if (firstChar === "[") {
                if (elem.hasAttribute(selector.substr(1, selector.length - 2))) {
                    return elem;
                }
            }
        }
        return false;
    };
    var getHeight = function(elem) {
        return Math.max(elem.scrollHeight, elem.offsetHeight, elem.clientHeight);
    };
    var escapeCharacters = function(id) {
        var string = String(id);
        var length = string.length;
        var index = -1;
        var codeUnit;
        var result = "";
        var firstCodeUnit = string.charCodeAt(0);
        while (++index < length) {
            codeUnit = string.charCodeAt(index);
            if (codeUnit === 0) {
                throw new InvalidCharacterError("Invalid character: the input contains U+0000.");
            }
            if (codeUnit >= 1 && codeUnit <= 31 || codeUnit == 127 || index === 0 && codeUnit >= 48 && codeUnit <= 57 || index === 1 && codeUnit >= 48 && codeUnit <= 57 && firstCodeUnit === 45) {
                result += "\\" + codeUnit.toString(16) + " ";
                continue;
            }
            if (codeUnit >= 128 || codeUnit === 45 || codeUnit === 95 || codeUnit >= 48 && codeUnit <= 57 || codeUnit >= 65 && codeUnit <= 90 || codeUnit >= 97 && codeUnit <= 122) {
                result += string.charAt(index);
                continue;
            }
            result += "\\" + string.charAt(index);
        }
        return result;
    };
    var easingPattern = function(type, time) {
        var pattern;
        if (type === "easeInQuad") pattern = time * time;
        if (type === "easeOutQuad") pattern = time * (2 - time);
        if (type === "easeInOutQuad") pattern = time < .5 ? 2 * time * time : -1 + (4 - 2 * time) * time;
        if (type === "easeInCubic") pattern = time * time * time;
        if (type === "easeOutCubic") pattern = --time * time * time + 1;
        if (type === "easeInOutCubic") pattern = time < .5 ? 4 * time * time * time : (time - 1) * (2 * time - 2) * (2 * time - 2) + 1;
        if (type === "easeInQuart") pattern = time * time * time * time;
        if (type === "easeOutQuart") pattern = 1 - --time * time * time * time;
        if (type === "easeInOutQuart") pattern = time < .5 ? 8 * time * time * time * time : 1 - 8 * --time * time * time * time;
        if (type === "easeInQuint") pattern = time * time * time * time * time;
        if (type === "easeOutQuint") pattern = 1 + --time * time * time * time * time;
        if (type === "easeInOutQuint") pattern = time < .5 ? 16 * time * time * time * time * time : 1 + 16 * --time * time * time * time * time;
        return pattern || time;
    };
    var getEndLocation = function(anchor, headerHeight, offset) {
        var navbar = $(".navigation-container");
        if ($(navbar).length) {
            if (navbar.is(".locknavigation")) {
                offset = 130;
            } else {
                offset = 200;
            }
        }
        var navbar2 = $(".training-navigation-container");
        if ($(navbar2).length) {
            if (navbar2.is(".locknavigation")) {
                offset += -30;
            } else {
                offset += 30;
            }
        }
        var location = 0;
        if (anchor.offsetParent) {
            do {
                location += anchor.offsetTop;
                anchor = anchor.offsetParent;
            } while (anchor);
        }
        location = location - headerHeight - offset;
        return location >= 0 ? location : 0;
    };
    var getDocumentHeight = function() {
        return Math.max(root.document.body.scrollHeight, root.document.documentElement.scrollHeight, root.document.body.offsetHeight, root.document.documentElement.offsetHeight, root.document.body.clientHeight, root.document.documentElement.clientHeight);
    };
    var getDataOptions = function(options) {
        return !options || !(typeof JSON === "object" && typeof JSON.parse === "function") ? {} : JSON.parse(options);
    };
    var updateUrl = function(anchor, url) {
        if (root.history.pushState && (url || url === "true")) {
            root.history.pushState(null, null, [ root.location.protocol, "//", root.location.host, root.location.pathname, root.location.search, anchor ].join(""));
        }
    };
    var getHeaderHeight = function(header) {
        return header === null ? 0 : getHeight(header) + header.offsetTop;
    };
    smoothScroll.animateScroll = function(toggle, anchor, options) {
        var settings = extend(settings || defaults, options || {});
        var overrides = getDataOptions(toggle ? toggle.getAttribute("data-options") : null);
        settings = extend(settings, overrides);
        anchor = "#" + escapeCharacters(anchor.substr(1));
        var anchorElem = anchor === "#" ? root.document.documentElement : root.document.querySelector(anchor);
        var startLocation = root.pageYOffset;
        if (!fixedHeader) {
            fixedHeader = root.document.querySelector("[data-scroll-header]");
        }
        if (!headerHeight) {
            headerHeight = getHeaderHeight(fixedHeader);
        }
        var endLocation = getEndLocation(anchorElem, headerHeight, parseInt(settings.offset, 10));
        var animationInterval;
        var distance = endLocation - startLocation;
        var documentHeight = getDocumentHeight();
        var timeLapsed = 0;
        var percentage, position;
        updateUrl(anchor, settings.updateURL);
        var stopAnimateScroll = function(position, endLocation, animationInterval) {
            var currentLocation = root.pageYOffset;
            if (position == endLocation || currentLocation == endLocation || root.innerHeight + currentLocation >= documentHeight) {
                clearInterval(animationInterval);
                anchorElem.focus();
                settings.callbackAfter(toggle, anchor);
            }
        };
        var loopAnimateScroll = function() {
            timeLapsed += 16;
            percentage = timeLapsed / parseInt(settings.speed, 10);
            percentage = percentage > 1 ? 1 : percentage;
            position = startLocation + distance * easingPattern(settings.easing, percentage);
            root.scrollTo(0, Math.floor(position));
            stopAnimateScroll(position, endLocation, animationInterval);
        };
        var startAnimateScroll = function() {
            settings.callbackBefore(toggle, anchor);
            animationInterval = setInterval(loopAnimateScroll, 16);
        };
        if (root.pageYOffset === 0) {
            root.scrollTo(0, 0);
        }
        startAnimateScroll();
    };
    var eventHandler = function(event) {
        var toggle = getClosest(event.target, "[data-scroll]");
        if (toggle && toggle.tagName.toLowerCase() === "a") {
            event.preventDefault();
            smoothScroll.animateScroll(toggle, toggle.hash, settings);
        }
    };
    var eventThrottler = function(event) {
        if (!eventTimeout) {
            eventTimeout = setTimeout(function() {
                eventTimeout = null;
                headerHeight = getHeaderHeight(fixedHeader);
            }, 66);
        }
    };
    smoothScroll.destroy = function() {
        if (!settings) return;
        root.document.removeEventListener("click", eventHandler, false);
        root.removeEventListener("resize", eventThrottler, false);
        settings = null;
        eventTimeout = null;
        fixedHeader = null;
        headerHeight = null;
    };
    smoothScroll.init = function(options) {
        if (!supports) return;
        smoothScroll.destroy();
        settings = extend(defaults, options || {});
        fixedHeader = root.document.querySelector("[data-scroll-header]");
        headerHeight = getHeaderHeight(fixedHeader);
        root.document.addEventListener("click", eventHandler, false);
        if (fixedHeader) {
            root.addEventListener("resize", eventThrottler, false);
        }
    };
    return smoothScroll;
});

(function() {
    "use strict";
    var keyCounter = 0;
    var allWaypoints = {};
    function Waypoint(options) {
        if (!options) {
            throw new Error("No options passed to Waypoint constructor");
        }
        if (!options.element) {
            throw new Error("No element option passed to Waypoint constructor");
        }
        if (!options.handler) {
            throw new Error("No handler option passed to Waypoint constructor");
        }
        this.key = "waypoint-" + keyCounter;
        this.options = Waypoint.Adapter.extend({}, Waypoint.defaults, options);
        this.element = this.options.element;
        this.adapter = new Waypoint.Adapter(this.element);
        this.callback = options.handler;
        this.axis = this.options.horizontal ? "horizontal" : "vertical";
        this.enabled = this.options.enabled;
        this.triggerPoint = null;
        this.group = Waypoint.Group.findOrCreate({
            name: this.options.group,
            axis: this.axis
        });
        this.context = Waypoint.Context.findOrCreateByElement(this.options.context);
        if (Waypoint.offsetAliases[this.options.offset]) {
            this.options.offset = Waypoint.offsetAliases[this.options.offset];
        }
        this.group.add(this);
        this.context.add(this);
        allWaypoints[this.key] = this;
        keyCounter += 1;
    }
    Waypoint.prototype.queueTrigger = function(direction) {
        this.group.queueTrigger(this, direction);
    };
    Waypoint.prototype.trigger = function(args) {
        if (!this.enabled) {
            return;
        }
        if (this.callback) {
            this.callback.apply(this, args);
        }
    };
    Waypoint.prototype.destroy = function() {
        this.context.remove(this);
        this.group.remove(this);
        delete allWaypoints[this.key];
    };
    Waypoint.prototype.disable = function() {
        this.enabled = false;
        return this;
    };
    Waypoint.prototype.enable = function() {
        this.context.refresh();
        this.enabled = true;
        return this;
    };
    Waypoint.prototype.next = function() {
        return this.group.next(this);
    };
    Waypoint.prototype.previous = function() {
        return this.group.previous(this);
    };
    Waypoint.invokeAll = function(method) {
        var allWaypointsArray = [];
        for (var waypointKey in allWaypoints) {
            allWaypointsArray.push(allWaypoints[waypointKey]);
        }
        for (var i = 0, end = allWaypointsArray.length; i < end; i++) {
            allWaypointsArray[i][method]();
        }
    };
    Waypoint.destroyAll = function() {
        Waypoint.invokeAll("destroy");
    };
    Waypoint.disableAll = function() {
        Waypoint.invokeAll("disable");
    };
    Waypoint.enableAll = function() {
        Waypoint.invokeAll("enable");
    };
    Waypoint.refreshAll = function() {
        Waypoint.Context.refreshAll();
    };
    Waypoint.viewportHeight = function() {
        return window.innerHeight || document.documentElement.clientHeight;
    };
    Waypoint.viewportWidth = function() {
        return document.documentElement.clientWidth;
    };
    Waypoint.adapters = [];
    Waypoint.defaults = {
        context: window,
        continuous: true,
        enabled: true,
        group: "default",
        horizontal: false,
        offset: 0
    };
    Waypoint.offsetAliases = {
        "bottom-in-view": function() {
            return this.context.innerHeight() - this.adapter.outerHeight();
        },
        "right-in-view": function() {
            return this.context.innerWidth() - this.adapter.outerWidth();
        }
    };
    window.Waypoint = Waypoint;
})();

(function() {
    "use strict";
    function requestAnimationFrameShim(callback) {
        window.setTimeout(callback, 1e3 / 60);
    }
    var keyCounter = 0;
    var contexts = {};
    var Waypoint = window.Waypoint;
    var oldWindowLoad = window.onload;
    function Context(element) {
        this.element = element;
        this.Adapter = Waypoint.Adapter;
        this.adapter = new this.Adapter(element);
        this.key = "waypoint-context-" + keyCounter;
        this.didScroll = false;
        this.didResize = false;
        this.oldScroll = {
            x: this.adapter.scrollLeft(),
            y: this.adapter.scrollTop()
        };
        this.waypoints = {
            vertical: {},
            horizontal: {}
        };
        element.waypointContextKey = this.key;
        contexts[element.waypointContextKey] = this;
        keyCounter += 1;
        this.createThrottledScrollHandler();
        this.createThrottledResizeHandler();
    }
    Context.prototype.add = function(waypoint) {
        var axis = waypoint.options.horizontal ? "horizontal" : "vertical";
        this.waypoints[axis][waypoint.key] = waypoint;
        this.refresh();
    };
    Context.prototype.checkEmpty = function() {
        var horizontalEmpty = this.Adapter.isEmptyObject(this.waypoints.horizontal);
        var verticalEmpty = this.Adapter.isEmptyObject(this.waypoints.vertical);
        if (horizontalEmpty && verticalEmpty) {
            this.adapter.off(".waypoints");
            delete contexts[this.key];
        }
    };
    Context.prototype.createThrottledResizeHandler = function() {
        var self = this;
        function resizeHandler() {
            self.handleResize();
            self.didResize = false;
        }
        this.adapter.on("resize.waypoints", function() {
            if (!self.didResize) {
                self.didResize = true;
                Waypoint.requestAnimationFrame(resizeHandler);
            }
        });
    };
    Context.prototype.createThrottledScrollHandler = function() {
        var self = this;
        function scrollHandler() {
            self.handleScroll();
            self.didScroll = false;
        }
        this.adapter.on("scroll.waypoints", function() {
            if (!self.didScroll || Waypoint.isTouch) {
                self.didScroll = true;
                Waypoint.requestAnimationFrame(scrollHandler);
            }
        });
    };
    Context.prototype.handleResize = function() {
        Waypoint.Context.refreshAll();
    };
    Context.prototype.handleScroll = function() {
        var triggeredGroups = {};
        var axes = {
            horizontal: {
                newScroll: this.adapter.scrollLeft(),
                oldScroll: this.oldScroll.x,
                forward: "right",
                backward: "left"
            },
            vertical: {
                newScroll: this.adapter.scrollTop(),
                oldScroll: this.oldScroll.y,
                forward: "down",
                backward: "up"
            }
        };
        for (var axisKey in axes) {
            var axis = axes[axisKey];
            var isForward = axis.newScroll > axis.oldScroll;
            var direction = isForward ? axis.forward : axis.backward;
            for (var waypointKey in this.waypoints[axisKey]) {
                var waypoint = this.waypoints[axisKey][waypointKey];
                var wasBeforeTriggerPoint = axis.oldScroll < waypoint.triggerPoint;
                var nowAfterTriggerPoint = axis.newScroll >= waypoint.triggerPoint;
                var crossedForward = wasBeforeTriggerPoint && nowAfterTriggerPoint;
                var crossedBackward = !wasBeforeTriggerPoint && !nowAfterTriggerPoint;
                if (crossedForward || crossedBackward) {
                    waypoint.queueTrigger(direction);
                    triggeredGroups[waypoint.group.id] = waypoint.group;
                }
            }
        }
        for (var groupKey in triggeredGroups) {
            triggeredGroups[groupKey].flushTriggers();
        }
        this.oldScroll = {
            x: axes.horizontal.newScroll,
            y: axes.vertical.newScroll
        };
    };
    Context.prototype.innerHeight = function() {
        if (this.element == this.element.window) {
            return Waypoint.viewportHeight();
        }
        return this.adapter.innerHeight();
    };
    Context.prototype.remove = function(waypoint) {
        delete this.waypoints[waypoint.axis][waypoint.key];
        this.checkEmpty();
    };
    Context.prototype.innerWidth = function() {
        if (this.element == this.element.window) {
            return Waypoint.viewportWidth();
        }
        return this.adapter.innerWidth();
    };
    Context.prototype.destroy = function() {
        var allWaypoints = [];
        for (var axis in this.waypoints) {
            for (var waypointKey in this.waypoints[axis]) {
                allWaypoints.push(this.waypoints[axis][waypointKey]);
            }
        }
        for (var i = 0, end = allWaypoints.length; i < end; i++) {
            allWaypoints[i].destroy();
        }
    };
    Context.prototype.refresh = function() {
        var isWindow = this.element == this.element.window;
        var contextOffset = this.adapter.offset();
        var triggeredGroups = {};
        var axes;
        this.handleScroll();
        axes = {
            horizontal: {
                contextOffset: isWindow ? 0 : contextOffset.left,
                contextScroll: isWindow ? 0 : this.oldScroll.x,
                contextDimension: this.innerWidth(),
                oldScroll: this.oldScroll.x,
                forward: "right",
                backward: "left",
                offsetProp: "left"
            },
            vertical: {
                contextOffset: isWindow ? 0 : contextOffset.top,
                contextScroll: isWindow ? 0 : this.oldScroll.y,
                contextDimension: this.innerHeight(),
                oldScroll: this.oldScroll.y,
                forward: "down",
                backward: "up",
                offsetProp: "top"
            }
        };
        for (var axisKey in axes) {
            var axis = axes[axisKey];
            for (var waypointKey in this.waypoints[axisKey]) {
                var waypoint = this.waypoints[axisKey][waypointKey];
                var adjustment = waypoint.options.offset;
                var oldTriggerPoint = waypoint.triggerPoint;
                var elementOffset = 0;
                var freshWaypoint = oldTriggerPoint == null;
                var contextModifier, wasBeforeScroll, nowAfterScroll;
                var triggeredBackward, triggeredForward;
                if (waypoint.element !== waypoint.element.window) {
                    elementOffset = waypoint.adapter.offset()[axis.offsetProp];
                }
                if (typeof adjustment === "function") {
                    adjustment = adjustment.apply(waypoint);
                } else if (typeof adjustment === "string") {
                    adjustment = parseFloat(adjustment);
                    if (waypoint.options.offset.indexOf("%") > -1) {
                        adjustment = Math.ceil(axis.contextDimension * adjustment / 100);
                    }
                }
                contextModifier = axis.contextScroll - axis.contextOffset;
                waypoint.triggerPoint = elementOffset + contextModifier - adjustment;
                wasBeforeScroll = oldTriggerPoint < axis.oldScroll;
                nowAfterScroll = waypoint.triggerPoint >= axis.oldScroll;
                triggeredBackward = wasBeforeScroll && nowAfterScroll;
                triggeredForward = !wasBeforeScroll && !nowAfterScroll;
                if (!freshWaypoint && triggeredBackward) {
                    waypoint.queueTrigger(axis.backward);
                    triggeredGroups[waypoint.group.id] = waypoint.group;
                } else if (!freshWaypoint && triggeredForward) {
                    waypoint.queueTrigger(axis.forward);
                    triggeredGroups[waypoint.group.id] = waypoint.group;
                } else if (freshWaypoint && axis.oldScroll >= waypoint.triggerPoint) {
                    waypoint.queueTrigger(axis.forward);
                    triggeredGroups[waypoint.group.id] = waypoint.group;
                }
            }
        }
        for (var groupKey in triggeredGroups) {
            triggeredGroups[groupKey].flushTriggers();
        }
        return this;
    };
    Context.findOrCreateByElement = function(element) {
        return Context.findByElement(element) || new Context(element);
    };
    Context.refreshAll = function() {
        for (var contextId in contexts) {
            contexts[contextId].refresh();
        }
    };
    Context.findByElement = function(element) {
        return contexts[element.waypointContextKey];
    };
    window.onload = function() {
        if (oldWindowLoad) {
            oldWindowLoad();
        }
        Context.refreshAll();
    };
    Waypoint.requestAnimationFrame = function(callback) {
        var requestFn = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || requestAnimationFrameShim;
        requestFn.call(window, callback);
    };
    Waypoint.Context = Context;
})();

(function() {
    "use strict";
    function byTriggerPoint(a, b) {
        return a.triggerPoint - b.triggerPoint;
    }
    function byReverseTriggerPoint(a, b) {
        return b.triggerPoint - a.triggerPoint;
    }
    var groups = {
        vertical: {},
        horizontal: {}
    };
    var Waypoint = window.Waypoint;
    function Group(options) {
        this.name = options.name;
        this.axis = options.axis;
        this.id = this.name + "-" + this.axis;
        this.waypoints = [];
        this.clearTriggerQueues();
        groups[this.axis][this.name] = this;
    }
    Group.prototype.add = function(waypoint) {
        this.waypoints.push(waypoint);
    };
    Group.prototype.clearTriggerQueues = function() {
        this.triggerQueues = {
            up: [],
            down: [],
            left: [],
            right: []
        };
    };
    Group.prototype.flushTriggers = function() {
        for (var direction in this.triggerQueues) {
            var waypoints = this.triggerQueues[direction];
            var reverse = direction === "up" || direction === "left";
            waypoints.sort(reverse ? byReverseTriggerPoint : byTriggerPoint);
            for (var i = 0, end = waypoints.length; i < end; i += 1) {
                var waypoint = waypoints[i];
                if (waypoint.options.continuous || i === waypoints.length - 1) {
                    waypoint.trigger([ direction ]);
                }
            }
        }
        this.clearTriggerQueues();
    };
    Group.prototype.next = function(waypoint) {
        this.waypoints.sort(byTriggerPoint);
        var index = Waypoint.Adapter.inArray(waypoint, this.waypoints);
        var isLast = index === this.waypoints.length - 1;
        return isLast ? null : this.waypoints[index + 1];
    };
    Group.prototype.previous = function(waypoint) {
        this.waypoints.sort(byTriggerPoint);
        var index = Waypoint.Adapter.inArray(waypoint, this.waypoints);
        return index ? this.waypoints[index - 1] : null;
    };
    Group.prototype.queueTrigger = function(waypoint, direction) {
        this.triggerQueues[direction].push(waypoint);
    };
    Group.prototype.remove = function(waypoint) {
        var index = Waypoint.Adapter.inArray(waypoint, this.waypoints);
        if (index > -1) {
            this.waypoints.splice(index, 1);
        }
    };
    Group.prototype.first = function() {
        return this.waypoints[0];
    };
    Group.prototype.last = function() {
        return this.waypoints[this.waypoints.length - 1];
    };
    Group.findOrCreate = function(options) {
        return groups[options.axis][options.name] || new Group(options);
    };
    Waypoint.Group = Group;
})();

(function() {
    "use strict";
    var $ = window.jQuery;
    var Waypoint = window.Waypoint;
    function JQueryAdapter(element) {
        this.$element = $(element);
    }
    $.each([ "innerHeight", "innerWidth", "off", "offset", "on", "outerHeight", "outerWidth", "scrollLeft", "scrollTop" ], function(i, method) {
        JQueryAdapter.prototype[method] = function() {
            var args = Array.prototype.slice.call(arguments);
            return this.$element[method].apply(this.$element, args);
        };
    });
    $.each([ "extend", "inArray", "isEmptyObject" ], function(i, method) {
        JQueryAdapter[method] = $[method];
    });
    Waypoint.adapters.push({
        name: "jquery",
        Adapter: JQueryAdapter
    });
    Waypoint.Adapter = JQueryAdapter;
})();

(function() {
    "use strict";
    var Waypoint = window.Waypoint;
    function createExtension(framework) {
        return function() {
            var waypoints = [];
            var overrides = arguments[0];
            if (framework.isFunction(arguments[0])) {
                overrides = framework.extend({}, arguments[1]);
                overrides.handler = arguments[0];
            }
            this.each(function() {
                var options = framework.extend({}, overrides, {
                    element: this
                });
                if (typeof options.context === "string") {
                    options.context = framework(this).closest(options.context)[0];
                }
                waypoints.push(new Waypoint(options));
            });
            return waypoints;
        };
    }
    if (window.jQuery) {
        window.jQuery.fn.waypoint = createExtension(window.jQuery);
    }
    if (window.Zepto) {
        window.Zepto.fn.waypoint = createExtension(window.Zepto);
    }
})();

(function($) {
    $(window).scroll(function() {
        var max_scroll = 300;
        var navbar = $(".navigation-container");
        if ($(".training-navigation").length) {
            navbar = $(".training-navigation");
            max_scroll = 300;
        }
        var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
        if (scrollTop > max_scroll && !navbar.is(".locknavigation")) {
            navbar.addClass("locknavigation");
        } else if (scrollTop < max_scroll && navbar.is(".locknavigation")) {
            navbar.removeClass("locknavigation");
        }
    });
})(jQuery);

$(function() {
    $("#wpOverviewStart").waypoint(function(direction) {
        if (direction == "down") {
            $("#lnOverview").addClass("selected");
            $("#lnExamDetails").removeClass("selected");
            $("#lnPreparation").removeClass("selected");
            $("#lnRenewal").removeClass("selected");
        }
    }, {
        offset: 195
    });
    $("#wpOverview").waypoint(function(direction) {
        if (direction == "up") {
            $("#lnOverview").addClass("selected");
            $("#lnExamDetails").removeClass("selected");
            $("#lnPreparation").removeClass("selected");
            $("#lnRenewal").removeClass("selected");
        }
    }, {
        offset: 195
    });
    $("#wpExamDetailsStart").waypoint(function(direction) {
        if (direction == "down") {
            $("#lnOverview").removeClass("selected");
            $("#lnExamDetails").addClass("selected");
            $("#lnPreparation").removeClass("selected");
            $("#lnRenewal").removeClass("selected");
        }
    }, {
        offset: 202
    });
    $("#wpExamDetails").waypoint(function(direction) {
        if (direction == "up") {
            $("#lnOverview").removeClass("selected");
            $("#lnExamDetails").addClass("selected");
            $("#lnPreparation").removeClass("selected");
            $("#lnRenewal").removeClass("selected");
        }
    }, {
        offset: 202
    });
    $("#wpExamPreparationStart").waypoint(function(direction) {
        if (direction == "down") {
            $("#lnOverview").removeClass("selected");
            $("#lnExamDetails").removeClass("selected");
            $("#lnPreparation").addClass("selected");
            $("#lnRenewal").removeClass("selected");
        }
    }, {
        offset: 202
    });
    $("#wpExamPreparation").waypoint(function(direction) {
        if (direction == "up") {
            $("#lnOverview").removeClass("selected");
            $("#lnExamDetails").removeClass("selected");
            $("#lnPreparation").addClass("selected");
            $("#lnRenewal").removeClass("selected");
        }
    }, {
        offset: 202
    });
    $("#wpRenewalStart").waypoint(function(direction) {
        if (direction == "down") {
            $("#lnOverview").removeClass("selected");
            $("#lnExamDetails").removeClass("selected");
            $("#lnPreparation").removeClass("selected");
            $("#lnRenewal").addClass("selected");
        }
    }, {
        offset: 202
    });
    $("#wpRenewal").waypoint(function(direction) {
        if (direction == "up") {
            $("#lnOverview").removeClass("selected");
            $("#lnExamDetails").removeClass("selected");
            $("#lnPreparation").removeClass("selected");
            $("#lnRenewal").addClass("selected");
        }
    }, {
        offset: 202
    });
    $("#wpBuyExamStart").waypoint(function(direction) {
        if (direction == "down") {
            $("#lnOverview").removeClass("selected");
            $("#lnExamDetails").removeClass("selected");
            $("#lnPreparation").removeClass("selected");
            $("#lnRenewal").removeClass("selected");
        }
    }, {
        offset: 200
    });
    $("#wpBuyExam").waypoint(function(direction) {
        if (direction == "up") {
            $("#lnOverview").removeClass("selected");
            $("#lnExamDetails").removeClass("selected");
            $("#lnPreparation").removeClass("selected");
            $("#lnRenewal").removeClass("selected");
        }
    }, {
        offset: 200
    });
    $('span[id^="section"]').each(function() {
        var sectionLink = this.id;
        sectionLink = sectionLink.replace(" start", "");
        sectionLink = sectionLink.replace(" end", "");
        var offset = 0;
        var navbar = $(".navigation-container");
        if (navbar.is(".locknavigation")) {
            offset = 130;
        } else {
            offset = 200;
        }
        if ($(".training-navigation").length) {
            navbar = $(".training-navigation");
            if (navbar.is(".locknavigation")) {
                offset += -30;
            } else {
                offset += 30;
            }
        }
        $(this).waypoint(function(direction) {
            if (direction === "down") {
                $(".productnavigation").find("a.links").removeClass("selected");
                $('a[href="#' + sectionLink + '"]').addClass("selected");
            }
        }, {
            offset: offset
        });
        $(this).waypoint(function(direction) {
            if (direction === "up") {
                if (!$('a.links[href="#' + sectionLink + '"]').hasClass("selected")) {
                    $(".productnavigation").find("a.links").removeClass("selected");
                    $('a.links[href="#' + sectionLink + '"]').addClass("selected");
                }
            }
        }, {
            offset: offset
        });
    });
    $("#top").waypoint(function() {
        $(".productnavigation").find("a.links").removeClass("selected");
    }, {
        offset: -100
    });
});

window.averta = {};

(function($) {
    window.package = function(name) {
        if (!window[name]) window[name] = {};
    };
    var extend = function(target, object) {
        for (var key in object) target[key] = object[key];
    };
    Function.prototype.extend = function(superclass) {
        if (typeof superclass.prototype.constructor === "function") {
            extend(this.prototype, superclass.prototype);
            this.prototype.constructor = this;
        } else {
            this.prototype.extend(superclass);
            this.prototype.constructor = this;
        }
    };
    var trans = {
        Moz: "-moz-",
        Webkit: "-webkit-",
        Khtml: "-khtml-",
        O: "-o-",
        ms: "-ms-",
        Icab: "-icab-"
    };
    window._mobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    window._touch = "ontouchstart" in document;
    $(document).ready(function() {
        window._jcsspfx = getVendorPrefix();
        window._csspfx = trans[window._jcsspfx];
        window._cssanim = supportsTransitions();
        window._css3d = supports3DTransforms();
        window._css2d = supportsTransforms();
    });
    function getVendorPrefix() {
        if ("result" in arguments.callee) return arguments.callee.result;
        var regex = /^(Moz|Webkit|Khtml|O|ms|Icab)(?=[A-Z])/;
        var someScript = document.getElementsByTagName("script")[0];
        for (var prop in someScript.style) {
            if (regex.test(prop)) {
                return arguments.callee.result = prop.match(regex)[0];
            }
        }
        if ("WebkitOpacity" in someScript.style) return arguments.callee.result = "Webkit";
        if ("KhtmlOpacity" in someScript.style) return arguments.callee.result = "Khtml";
        return arguments.callee.result = "";
    }
    window.parseQueryString = function(url) {
        var queryString = {};
        url.replace(new RegExp("([^?=&]+)(=([^&]*))?", "g"), function($0, $1, $2, $3) {
            queryString[$1] = $3;
        });
        return queryString;
    };
    function checkStyleValue(prop) {
        var b = document.body || document.documentElement;
        var s = b.style;
        var p = prop;
        if (typeof s[p] == "string") {
            return true;
        }
        v = [ "Moz", "Webkit", "Khtml", "O", "ms" ], p = p.charAt(0).toUpperCase() + p.substr(1);
        for (var i = 0; i < v.length; i++) {
            if (typeof s[v[i] + p] == "string") {
                return true;
            }
        }
        return false;
    }
    function supportsTransitions() {
        return checkStyleValue("transition");
    }
    function supportsTransforms() {
        return checkStyleValue("transform");
    }
    function supports3DTransforms() {
        if (!supportsTransforms()) return false;
        var el = document.createElement("i"), has3d, transforms = {
            WebkitTransform: "-webkit-transform",
            OTransform: "-o-transform",
            MSTransform: "-ms-transform",
            msTransform: "-ms-transform",
            MozTransform: "-moz-transform",
            Transform: "transform",
            transform: "transform"
        };
        el.style.display = "block";
        document.body.insertBefore(el, null);
        for (var t in transforms) {
            if (el.style[t] !== undefined) {
                el.style[t] = "translate3d(1px,1px,1px)";
                has3d = window.getComputedStyle(el).getPropertyValue(transforms[t]);
            }
        }
        document.body.removeChild(el);
        return has3d != null && has3d.length > 0 && has3d !== "none";
    }
    var fps60 = 50 / 3;
    if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = function() {
            return window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback, element) {
                window.setTimeout(callback, fps60);
            };
        }();
    }
    if (!window.getComputedStyle) {
        window.getComputedStyle = function(el, pseudo) {
            this.el = el;
            this.getPropertyValue = function(prop) {
                var re = /(\-([a-z]){1})/g;
                if (prop == "float") prop = "styleFloat";
                if (re.test(prop)) {
                    prop = prop.replace(re, function() {
                        return arguments[2].toUpperCase();
                    });
                }
                return el.currentStyle[prop] ? el.currentStyle[prop] : null;
            };
            return el.currentStyle;
        };
    }
    if (!Array.prototype.indexOf) {
        Array.prototype.indexOf = function(elt) {
            var len = this.length >>> 0;
            var from = Number(arguments[1]) || 0;
            from = from < 0 ? Math.ceil(from) : Math.floor(from);
            if (from < 0) from += len;
            for (;from < len; from++) {
                if (from in this && this[from] === elt) return from;
            }
            return -1;
        };
    }
    window.isMSIE = function(version) {
        if (!$.browser.msie) {
            return false;
        } else if (!version) {
            return true;
        }
        var ieVer = $.browser.version.slice(0, $.browser.version.indexOf("."));
        if (typeof version === "string") {
            if (version.indexOf("<") !== -1 || version.indexOf(">") !== -1) {
                return eval(ieVer + version);
            } else {
                return eval(version + "==" + ieVer);
            }
        } else {
            return version == ieVer;
        }
    };
    $.removeDataAttrs = function($target, exclude) {
        var i, attrName, dataAttrsToDelete = [], dataAttrs = $target[0].attributes, dataAttrsLen = dataAttrs.length;
        exclude = exclude || [];
        for (i = 0; i < dataAttrsLen; i++) {
            attrName = dataAttrs[i].name;
            if ("data-" === attrName.substring(0, 5) && exclude.indexOf(attrName) === -1) {
                dataAttrsToDelete.push(dataAttrs[i].name);
            }
        }
        $.each(dataAttrsToDelete, function(index, attrName) {
            $target.removeAttr(attrName);
        });
    };
    if (jQuery) {
        $.jqLoadFix = function() {
            if (this.complete) {
                var that = this;
                setTimeout(function() {
                    $(that).load();
                }, 1);
            }
        };
        jQuery.uaMatch = jQuery.uaMatch || function(ua) {
            ua = ua.toLowerCase();
            var match = /(chrome)[ \/]([\w.]+)/.exec(ua) || /(webkit)[ \/]([\w.]+)/.exec(ua) || /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(ua) || /(msie) ([\w.]+)/.exec(ua) || ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) || [];
            return {
                browser: match[1] || "",
                version: match[2] || "0"
            };
        };
        matched = jQuery.uaMatch(navigator.userAgent);
        browser = {};
        if (matched.browser) {
            browser[matched.browser] = true;
            browser.version = matched.version;
        }
        if (browser.chrome) {
            browser.webkit = true;
        } else if (browser.webkit) {
            browser.safari = true;
        }
        var isIE11 = !!navigator.userAgent.match(/Trident\/7\./);
        if (isIE11) {
            browser.msie = "true";
            delete browser.mozilla;
        }
        jQuery.browser = browser;
        $.fn.preloadImg = function(src, _event) {
            this.each(function() {
                var $this = $(this);
                var self = this;
                var img = new Image();
                img.onload = function(event) {
                    if (event == null) event = {};
                    $this.attr("src", src);
                    event.width = img.width;
                    event.height = img.height;
                    $this.data("width", img.width);
                    $this.data("height", img.height);
                    setTimeout(function() {
                        _event.call(self, event);
                    }, 50);
                    img = null;
                };
                img.src = src;
            });
            return this;
        };
    }
})(jQuery);

(function() {
    "use strict";
    averta.EventDispatcher = function() {
        this.listeners = {};
    };
    averta.EventDispatcher.extend = function(_proto) {
        var instance = new averta.EventDispatcher();
        for (var key in instance) if (key != "constructor") _proto[key] = averta.EventDispatcher.prototype[key];
    };
    averta.EventDispatcher.prototype = {
        constructor: averta.EventDispatcher,
        addEventListener: function(event, listener, ref) {
            if (!this.listeners[event]) this.listeners[event] = [];
            this.listeners[event].push({
                listener: listener,
                ref: ref
            });
        },
        removeEventListener: function(event, listener, ref) {
            if (this.listeners[event]) {
                for (var i = 0; i < this.listeners[event].length; ++i) {
                    if (listener === this.listeners[event][i].listener && ref === this.listeners[event][i].ref) {
                        this.listeners[event].splice(i--, 1);
                    }
                }
                if (this.listeners[event].length === 0) {
                    this.listeners[event] = null;
                }
            }
        },
        dispatchEvent: function(event) {
            event.target = this;
            if (this.listeners[event.type]) {
                for (var i = 0, l = this.listeners[event.type].length; i < l; ++i) {
                    this.listeners[event.type][i].listener.call(this.listeners[event.type][i].ref, event);
                }
            }
        }
    };
})();

(function($) {
    "use strict";
    var isTouch = "ontouchstart" in document, isPointer = window.navigator.pointerEnabled, isMSPoiner = !isPointer && window.navigator.msPointerEnabled, usePointer = isPointer || isMSPoiner, ev_start = (isPointer ? "pointerdown " : "") + (isMSPoiner ? "MSPointerDown " : "") + (isTouch ? "touchstart " : "") + "mousedown", ev_move = (isPointer ? "pointermove " : "") + (isMSPoiner ? "MSPointerMove " : "") + (isTouch ? "touchmove " : "") + "mousemove", ev_end = (isPointer ? "pointerup " : "") + (isMSPoiner ? "MSPointerUp " : "") + (isTouch ? "touchend " : "") + "mouseup", ev_cancel = (isPointer ? "pointercancel " : "") + (isMSPoiner ? "MSPointerCancel " : "") + "touchcancel";
    averta.TouchSwipe = function($element) {
        this.$element = $element;
        this.enabled = true;
        $element.bind(ev_start, {
            target: this
        }, this.__touchStart);
        $element[0].swipe = this;
        this.onSwipe = null;
        this.swipeType = "horizontal";
        this.noSwipeSelector = "input, textarea, button, .no-swipe, .ms-no-swipe";
        this.lastStatus = {};
    };
    var p = averta.TouchSwipe.prototype;
    p.getDirection = function(new_x, new_y) {
        switch (this.swipeType) {
          case "horizontal":
            return new_x <= this.start_x ? "left" : "right";
            break;

          case "vertical":
            return new_y <= this.start_y ? "up" : "down";
            break;

          case "all":
            if (Math.abs(new_x - this.start_x) > Math.abs(new_y - this.start_y)) return new_x <= this.start_x ? "left" : "right"; else return new_y <= this.start_y ? "up" : "down";
            break;
        }
    };
    p.priventDefultEvent = function(new_x, new_y) {
        var dx = Math.abs(new_x - this.start_x);
        var dy = Math.abs(new_y - this.start_y);
        var horiz = dx > dy;
        return this.swipeType === "horizontal" && horiz || this.swipeType === "vertical" && !horiz;
    };
    p.createStatusObject = function(evt) {
        var status_data = {}, temp_x, temp_y;
        temp_x = this.lastStatus.distanceX || 0;
        temp_y = this.lastStatus.distanceY || 0;
        status_data.distanceX = evt.pageX - this.start_x;
        status_data.distanceY = evt.pageY - this.start_y;
        status_data.moveX = status_data.distanceX - temp_x;
        status_data.moveY = status_data.distanceY - temp_y;
        status_data.distance = parseInt(Math.sqrt(Math.pow(status_data.distanceX, 2) + Math.pow(status_data.distanceY, 2)));
        status_data.duration = new Date().getTime() - this.start_time;
        status_data.direction = this.getDirection(evt.pageX, evt.pageY);
        return status_data;
    };
    p.__reset = function(event, jqevt) {
        this.reset = false;
        this.lastStatus = {};
        this.start_time = new Date().getTime();
        this.start_x = isTouch ? event.touches[0].pageX : usePointer ? event.pageX : jqevt.pageX;
        this.start_y = isTouch ? event.touches[0].pageY : usePointer ? event.pageY : jqevt.pageY;
    };
    p.__touchStart = function(event) {
        var swipe = event.data.target;
        var jqevt = event;
        if (!swipe.enabled) return;
        if ($(event.target).closest(swipe.noSwipeSelector, swipe.$element).length > 0) {
            return;
        }
        event = event.originalEvent;
        if (usePointer) {
            $(this).css("-ms-touch-action", swipe.swipeType === "horizontal" ? "pan-y" : "pan-x");
        }
        if (!swipe.onSwipe) {
            $.error("Swipe listener is undefined");
            return;
        }
        if (swipe.touchStarted) return;
        swipe.start_x = isTouch ? event.touches[0].pageX : usePointer ? event.pageX : jqevt.pageX;
        swipe.start_y = isTouch ? event.touches[0].pageY : usePointer ? event.pageY : jqevt.pageY;
        swipe.start_time = new Date().getTime();
        $(document).bind(ev_end, {
            target: swipe
        }, swipe.__touchEnd).bind(ev_move, {
            target: swipe
        }, swipe.__touchMove).bind(ev_cancel, {
            target: swipe
        }, swipe.__touchCancel);
        var evt = isTouch ? event.touches[0] : usePointer ? event : jqevt;
        var status = swipe.createStatusObject(evt);
        status.phase = "start";
        swipe.onSwipe.call(null, status);
        if (!isTouch) jqevt.preventDefault();
        swipe.lastStatus = status;
        swipe.touchStarted = true;
    };
    p.__touchMove = function(event) {
        var swipe = event.data.target;
        var jqevt = event;
        event = event.originalEvent;
        if (!swipe.touchStarted) return;
        clearTimeout(swipe.timo);
        swipe.timo = setTimeout(function() {
            swipe.__reset(event, jqevt);
        }, 60);
        var evt = isTouch ? event.touches[0] : usePointer ? event : jqevt;
        var status = swipe.createStatusObject(evt);
        if (swipe.priventDefultEvent(evt.pageX, evt.pageY)) jqevt.preventDefault();
        status.phase = "move";
        swipe.lastStatus = status;
        swipe.onSwipe.call(null, status);
    };
    p.__touchEnd = function(event) {
        var swipe = event.data.target;
        var jqevt = event;
        event = event.originalEvent;
        clearTimeout(swipe.timo);
        var evt = isTouch ? event.touches[0] : usePointer ? event : jqevt;
        var status = swipe.lastStatus;
        if (!isTouch) jqevt.preventDefault();
        status.phase = "end";
        swipe.touchStarted = false;
        swipe.priventEvt = null;
        $(document).unbind(ev_end, swipe.__touchEnd).unbind(ev_move, swipe.__touchMove).unbind(ev_cancel, swipe.__touchCancel);
        status.speed = status.distance / status.duration;
        swipe.onSwipe.call(null, status);
    };
    p.__touchCancel = function(event) {
        var swipe = event.data.target;
        swipe.__touchEnd(event);
    };
    p.enable = function() {
        if (this.enabled) return;
        this.enabled = true;
    };
    p.disable = function() {
        if (!this.enabled) return;
        this.enabled = false;
    };
})(jQuery);

(function() {
    "use strict";
    averta.Ticker = function() {};
    var st = averta.Ticker, list = [], len = 0, __stopped = true;
    st.add = function(listener, ref) {
        list.push([ listener, ref ]);
        if (list.length === 1) st.start();
        len = list.length;
        return len;
    };
    st.remove = function(listener, ref) {
        for (var i = 0, l = list.length; i < l; ++i) {
            if (list[i] && list[i][0] === listener && list[i][1] === ref) {
                list.splice(i, 1);
            }
        }
        len = list.length;
        if (len === 0) {
            st.stop();
        }
    };
    st.start = function() {
        if (!__stopped) return;
        __stopped = false;
        __tick();
    };
    st.stop = function() {
        __stopped = true;
    };
    var __tick = function() {
        if (st.__stopped) return;
        var item;
        for (var i = 0; i !== len; i++) {
            item = list[i];
            item[0].call(item[1]);
        }
        requestAnimationFrame(__tick);
    };
})();

(function() {
    "use strict";
    if (!Date.now) {
        Date.now = function() {
            return new Date().getTime();
        };
    }
    averta.Timer = function(delay, autoStart) {
        this.delay = delay;
        this.currentCount = 0;
        this.paused = false;
        this.onTimer = null;
        this.refrence = null;
        if (autoStart) this.start();
    };
    averta.Timer.prototype = {
        constructor: averta.Timer,
        start: function() {
            this.paused = false;
            this.lastTime = Date.now();
            averta.Ticker.add(this.update, this);
        },
        stop: function() {
            this.paused = true;
            averta.Ticker.remove(this.update, this);
        },
        reset: function() {
            this.currentCount = 0;
            this.paused = true;
            this.lastTime = Date.now();
        },
        update: function() {
            if (this.paused || Date.now() - this.lastTime < this.delay) return;
            this.currentCount++;
            this.lastTime = Date.now();
            if (this.onTimer) this.onTimer.call(this.refrence, this.getTime());
        },
        getTime: function() {
            return this.delay * this.currentCount;
        }
    };
})();

(function() {
    "use strict";
    var evt = null;
    window.CSSTween = function(element, duration, delay, ease) {
        this.$element = element;
        this.duration = duration || 1e3;
        this.delay = delay || 0;
        this.ease = ease || "linear";
    };
    var p = CSSTween.prototype;
    p.to = function(callback, target) {
        this.to_cb = callback;
        this.to_cb_target = target;
        return this;
    };
    p.from = function(callback, target) {
        this.fr_cb = callback;
        this.fr_cb_target = target;
        return this;
    };
    p.onComplete = function(callback, target) {
        this.oc_fb = callback;
        this.oc_fb_target = target;
        return this;
    };
    p.chain = function(csstween) {
        this.chained_tween = csstween;
        return this;
    };
    p.reset = function() {
        clearTimeout(this.start_to);
        clearTimeout(this.end_to);
    };
    p.start = function() {
        var element = this.$element[0];
        clearTimeout(this.start_to);
        clearTimeout(this.end_to);
        this.fresh = true;
        if (this.fr_cb) {
            element.style[window._jcsspfx + "TransitionDuration"] = "0ms";
            this.fr_cb.call(this.fr_cb_target);
        }
        var that = this;
        this.onTransComplete = function(event) {
            if (!that.fresh) return;
            that.reset();
            element.style[window._jcsspfx + "TransitionDuration"] = "";
            element.style[window._jcsspfx + "TransitionProperty"] = "";
            element.style[window._jcsspfx + "TransitionTimingFunction"] = "";
            element.style[window._jcsspfx + "TransitionDelay"] = "";
            that.fresh = false;
            if (that.chained_tween) that.chained_tween.start();
            if (that.oc_fb) that.oc_fb.call(that.oc_fb_target);
        };
        this.start_to = setTimeout(function() {
            if (!that.$element) return;
            element.style[window._jcsspfx + "TransitionDuration"] = that.duration + "ms";
            element.style[window._jcsspfx + "TransitionProperty"] = that.transProperty || "all";
            if (that.delay > 0) element.style[window._jcsspfx + "TransitionDelay"] = that.delay + "ms"; else element.style[window._jcsspfx + "TransitionDelay"] = "";
            element.style[window._jcsspfx + "TransitionTimingFunction"] = that.ease;
            if (that.to_cb) that.to_cb.call(that.to_cb_target);
            that.end_to = setTimeout(function() {
                that.onTransComplete();
            }, that.duration + (that.delay || 0));
        }, 100);
        return this;
    };
})();

(function() {
    "use strict";
    var _cssanim = null;
    window.CTween = {};
    function transPos(element, properties) {
        if (properties.x !== undefined || properties.y !== undefined) {
            if (_cssanim) {
                var trans = window._jcsspfx + "Transform";
                if (properties.x !== undefined) {
                    properties[trans] = (properties[trans] || "") + " translateX(" + properties.x + "px)";
                    delete properties.x;
                }
                if (properties.y !== undefined) {
                    properties[trans] = (properties[trans] || "") + " translateY(" + properties.y + "px)";
                    delete properties.y;
                }
            } else {
                if (properties.x !== undefined) {
                    var posx = element.css("right") !== "auto" ? "right" : "left";
                    properties[posx] = properties.x + "px";
                    delete properties.x;
                }
                if (properties.y !== undefined) {
                    var posy = element.css("bottom") !== "auto" ? "bottom" : "top";
                    properties[posy] = properties.y + "px";
                    delete properties.y;
                }
            }
        }
        return properties;
    }
    CTween.setPos = function(element, pos) {
        element.css(transPos(element, pos));
    };
    CTween.animate = function(element, duration, properties, options) {
        if (_cssanim == null) _cssanim = window._cssanim;
        options = options || {};
        transPos(element, properties);
        if (_cssanim) {
            var tween = new CSSTween(element, duration, options.delay, EaseDic[options.ease]);
            if (options.transProperty) {
                tween.transProperty = options.transProperty;
            }
            tween.to(function() {
                element.css(properties);
            });
            if (options.complete) tween.onComplete(options.complete, options.target);
            tween.start();
            tween.stop = tween.reset;
            return tween;
        }
        var onCl;
        if (options.delay) element.delay(options.delay);
        if (options.complete) onCl = function() {
            options.complete.call(options.target);
        };
        element.stop(true).animate(properties, duration, options.ease || "linear", onCl);
        return element;
    };
    CTween.fadeOut = function(target, duration, remove) {
        var options = {};
        if (remove === true) {
            options.complete = function() {
                target.remove();
            };
        } else if (remove === 2) {
            options.complete = function() {
                target.css("display", "none");
            };
        }
        CTween.animate(target, duration || 1e3, {
            opacity: 0
        }, options);
    };
    CTween.fadeIn = function(target, duration, reset) {
        if (reset !== false) {
            target.css("opacity", 0).css("display", "");
        }
        CTween.animate(target, duration || 1e3, {
            opacity: 1
        });
    };
})();

(function() {
    window.EaseDic = {
        linear: "linear",
        ease: "ease",
        easeIn: "ease-in",
        easeOut: "ease-out",
        easeInOut: "ease-in-out",
        easeInCubic: "cubic-bezier(.55,.055,.675,.19)",
        easeOutCubic: "cubic-bezier(.215,.61,.355,1)",
        easeInOutCubic: "cubic-bezier(.645,.045,.355,1)",
        easeInCirc: "cubic-bezier(.6,.04,.98,.335)",
        easeOutCirc: "cubic-bezier(.075,.82,.165,1)",
        easeInOutCirc: "cubic-bezier(.785,.135,.15,.86)",
        easeInExpo: "cubic-bezier(.95,.05,.795,.035)",
        easeOutExpo: "cubic-bezier(.19,1,.22,1)",
        easeInOutExpo: "cubic-bezier(1,0,0,1)",
        easeInQuad: "cubic-bezier(.55,.085,.68,.53)",
        easeOutQuad: "cubic-bezier(.25,.46,.45,.94)",
        easeInOutQuad: "cubic-bezier(.455,.03,.515,.955)",
        easeInQuart: "cubic-bezier(.895,.03,.685,.22)",
        easeOutQuart: "cubic-bezier(.165,.84,.44,1)",
        easeInOutQuart: "cubic-bezier(.77,0,.175,1)",
        easeInQuint: "cubic-bezier(.755,.05,.855,.06)",
        easeOutQuint: "cubic-bezier(.23,1,.32,1)",
        easeInOutQuint: "cubic-bezier(.86,0,.07,1)",
        easeInSine: "cubic-bezier(.47,0,.745,.715)",
        easeOutSine: "cubic-bezier(.39,.575,.565,1)",
        easeInOutSine: "cubic-bezier(.445,.05,.55,.95)",
        easeInBack: "cubic-bezier(.6,-.28,.735,.045)",
        easeOutBack: "cubic-bezier(.175, .885,.32,1.275)",
        easeInOutBack: "cubic-bezier(.68,-.55,.265,1.55)"
    };
})();

(function() {
    "use strict";
    window.MSAligner = function(type, $container, $img) {
        this.$container = $container;
        this.$img = $img;
        this.type = type || "stretch";
        this.widthOnly = false;
        this.heightOnly = false;
    };
    var p = MSAligner.prototype;
    p.init = function(w, h) {
        this.baseWidth = w;
        this.baseHeight = h;
        this.imgRatio = w / h;
        this.imgRatio2 = h / w;
        switch (this.type) {
          case "tile":
            this.$container.css("background-image", "url(" + this.$img.attr("src") + ")");
            this.$img.remove();
            break;

          case "center":
            this.$container.css("background-image", "url(" + this.$img.attr("src") + ")");
            this.$container.css({
                backgroundPosition: "center center",
                backgroundRepeat: "no-repeat"
            });
            this.$img.remove();
            break;

          case "stretch":
            this.$img.css({
                width: "100%",
                height: "100%"
            });
            break;

          case "fill":
          case "fit":
            this.needAlign = true;
            this.align();
            break;
        }
    };
    p.align = function() {
        if (!this.needAlign) return;
        var cont_w = this.$container.width();
        var cont_h = this.$container.height();
        var contRatio = cont_w / cont_h;
        if (this.type == "fill") {
            if (this.imgRatio < contRatio) {
                this.$img.width(cont_w);
                this.$img.height(cont_w * this.imgRatio2);
            } else {
                this.$img.height(cont_h);
                this.$img.width(cont_h * this.imgRatio);
            }
        } else if (this.type == "fit") {
            if (this.imgRatio < contRatio) {
                this.$img.height(cont_h);
                this.$img.width(cont_h * this.imgRatio);
            } else {
                this.$img.width(cont_w);
                this.$img.height(cont_w * this.imgRatio2);
            }
        }
        this.setMargin();
    };
    p.setMargin = function() {
        var cont_w = this.$container.width();
        var cont_h = this.$container.height();
        this.$img.css("margin-top", (cont_h - this.$img[0].offsetHeight) / 2 + "px");
        this.$img.css("margin-left", (cont_w - this.$img[0].offsetWidth) / 2 + "px");
    };
})();

(function() {
    "use strict";
    var _options = {
        bouncing: true,
        snapping: false,
        snapsize: null,
        friction: .05,
        outFriction: .05,
        outAcceleration: .09,
        minValidDist: .3,
        snappingMinSpeed: 2,
        paging: false,
        endless: false,
        maxSpeed: 160
    };
    var Controller = function(min, max, options) {
        if (max === null || min === null) {
            throw new Error("Max and Min values are required.");
        }
        this.options = options || {};
        for (var key in _options) {
            if (!(key in this.options)) this.options[key] = _options[key];
        }
        this._max_value = max;
        this._min_value = min;
        this.value = min;
        this.end_loc = min;
        this.current_snap = this.getSnapNum(min);
        this.__extrStep = 0;
        this.__extraMove = 0;
        this.__animID = -1;
    };
    var p = Controller.prototype;
    p.changeTo = function(value, animate, speed, snap_num, dispatch) {
        this.stopped = false;
        this._internalStop();
        value = this._checkLimits(value);
        speed = Math.abs(speed || 0);
        if (this.options.snapping) {
            snap_num = snap_num || this.getSnapNum(value);
            if (dispatch !== false) this._callsnapChange(snap_num);
            this.current_snap = snap_num;
        }
        if (animate) {
            this.animating = true;
            var self = this, active_id = ++self.__animID, amplitude = value - self.value, timeStep = 0, targetPosition = value, animFrict = 1 - self.options.friction, timeconst = animFrict + (speed - 20) * animFrict * 1.3 / self.options.maxSpeed;
            var tick = function() {
                if (active_id !== self.__animID) return;
                var dis = value - self.value;
                if (Math.abs(dis) > self.options.minValidDist && self.animating) {
                    window.requestAnimationFrame(tick);
                } else {
                    if (self.animating) {
                        self.value = value;
                        self._callrenderer();
                    }
                    self.animating = false;
                    if (active_id !== self.__animID) {
                        self.__animID = -1;
                    }
                    self._callonComplete("anim");
                    return;
                }
                self.value = targetPosition - amplitude * Math.exp(- ++timeStep * timeconst);
                self._callrenderer();
            };
            tick();
            return;
        }
        this.value = value;
        this._callrenderer();
    };
    p.drag = function(move) {
        if (this.start_drag) {
            this.drag_start_loc = this.value;
            this.start_drag = false;
        }
        this.animating = false;
        this._deceleration = false;
        this.value -= move;
        if (!this.options.endless && (this.value > this._max_value || this.value < 0)) {
            if (this.options.bouncing) {
                this.__isout = true;
                this.value += move * .6;
            } else if (this.value > this._max_value) {
                this.value = this._max_value;
            } else {
                this.value = 0;
            }
        } else if (!this.options.endless && this.options.bouncing) {
            this.__isout = false;
        }
        this._callrenderer();
    };
    p.push = function(speed) {
        this.stopped = false;
        if (this.options.snapping && Math.abs(speed) <= this.options.snappingMinSpeed) {
            this.cancel();
            return;
        }
        this.__speed = speed;
        this.__startSpeed = speed;
        this.end_loc = this._calculateEnd();
        if (this.options.snapping) {
            var snap_loc = this.getSnapNum(this.value), end_snap = this.getSnapNum(this.end_loc);
            if (this.options.paging) {
                snap_loc = this.getSnapNum(this.drag_start_loc);
                this.__isout = false;
                if (speed > 0) {
                    this.gotoSnap(snap_loc + 1, true, speed);
                } else {
                    this.gotoSnap(snap_loc - 1, true, speed);
                }
                return;
            } else if (snap_loc === end_snap) {
                this.cancel();
                return;
            }
            this._callsnapChange(end_snap);
            this.current_snap = end_snap;
        }
        this.animating = false;
        this.__needsSnap = this.options.endless || this.end_loc > this._min_value && this.end_loc < this._max_value;
        if (this.options.snapping && this.__needsSnap) this.__extraMove = this._calculateExtraMove(this.end_loc);
        this._startDecelaration();
    };
    p.bounce = function(speed) {
        if (this.animating) return;
        this.stopped = false;
        this.animating = false;
        this.__speed = speed;
        this.__startSpeed = speed;
        this.end_loc = this._calculateEnd();
        this._startDecelaration();
    };
    p.stop = function() {
        this.stopped = true;
        this._internalStop();
    };
    p.cancel = function() {
        this.start_drag = true;
        if (this.__isout) {
            this.__speed = 4e-4;
            this._startDecelaration();
        } else if (this.options.snapping) {
            this.gotoSnap(this.getSnapNum(this.value), true);
        }
    };
    p.renderCallback = function(listener, ref) {
        this.__renderHook = {
            fun: listener,
            ref: ref
        };
    };
    p.snappingCallback = function(listener, ref) {
        this.__snapHook = {
            fun: listener,
            ref: ref
        };
    };
    p.snapCompleteCallback = function(listener, ref) {
        this.__compHook = {
            fun: listener,
            ref: ref
        };
    };
    p.getSnapNum = function(value) {
        return Math.floor((value + this.options.snapsize / 2) / this.options.snapsize);
    };
    p.nextSnap = function() {
        this._internalStop();
        var curr_snap = this.getSnapNum(this.value);
        if (!this.options.endless && (curr_snap + 1) * this.options.snapsize > this._max_value) {
            this.__speed = 8;
            this.__needsSnap = false;
            this._startDecelaration();
        } else {
            this.gotoSnap(curr_snap + 1, true);
        }
    };
    p.prevSnap = function() {
        this._internalStop();
        var curr_snap = this.getSnapNum(this.value);
        if (!this.options.endless && (curr_snap - 1) * this.options.snapsize < this._min_value) {
            this.__speed = -8;
            this.__needsSnap = false;
            this._startDecelaration();
        } else {
            this.gotoSnap(curr_snap - 1, true);
        }
    };
    p.gotoSnap = function(snap_num, animate, speed) {
        this.changeTo(snap_num * this.options.snapsize, animate, speed, snap_num);
    };
    p.destroy = function() {
        this._internalStop();
        this.__renderHook = null;
        this.__snapHook = null;
        this.__compHook = null;
    };
    p._internalStop = function() {
        this.start_drag = true;
        this.animating = false;
        this._deceleration = false;
        this.__extrStep = 0;
    };
    p._calculateExtraMove = function(value) {
        var m = value % this.options.snapsize;
        return m < this.options.snapsize / 2 ? -m : this.options.snapsize - m;
    };
    p._calculateEnd = function(step) {
        var temp_speed = this.__speed;
        var temp_value = this.value;
        var i = 0;
        while (Math.abs(temp_speed) > this.options.minValidDist) {
            temp_value += temp_speed;
            temp_speed *= this.options.friction;
            i++;
        }
        if (step) return i;
        return temp_value;
    };
    p._checkLimits = function(value) {
        if (this.options.endless) return value;
        if (value < this._min_value) return this._min_value;
        if (value > this._max_value) return this._max_value;
        return value;
    };
    p._callrenderer = function() {
        if (this.__renderHook) this.__renderHook.fun.call(this.__renderHook.ref, this, this.value);
    };
    p._callsnapChange = function(targetSnap) {
        if (!this.__snapHook || targetSnap === this.current_snap) return;
        this.__snapHook.fun.call(this.__snapHook.ref, this, targetSnap, targetSnap - this.current_snap);
    };
    p._callonComplete = function(type) {
        if (this.__compHook && !this.stopped) {
            this.__compHook.fun.call(this.__compHook.ref, this, this.current_snap, type);
        }
    };
    p._computeDeceleration = function() {
        if (this.options.snapping && this.__needsSnap) {
            var xtr_move = (this.__startSpeed - this.__speed) / this.__startSpeed * this.__extraMove;
            this.value += this.__speed + xtr_move - this.__extrStep;
            this.__extrStep = xtr_move;
        } else {
            this.value += this.__speed;
        }
        this.__speed *= this.options.friction;
        if (!this.options.endless && !this.options.bouncing) {
            if (this.value <= this._min_value) {
                this.value = this._min_value;
                this.__speed = 0;
            } else if (this.value >= this._max_value) {
                this.value = this._max_value;
                this.__speed = 0;
            }
        }
        this._callrenderer();
        if (!this.options.endless && this.options.bouncing) {
            var out_value = 0;
            if (this.value < this._min_value) {
                out_value = this._min_value - this.value;
            } else if (this.value > this._max_value) {
                out_value = this._max_value - this.value;
            }
            this.__isout = Math.abs(out_value) >= this.options.minValidDist;
            if (this.__isout) {
                if (this.__speed * out_value <= 0) {
                    this.__speed += out_value * this.options.outFriction;
                } else {
                    this.__speed = out_value * this.options.outAcceleration;
                }
            }
        }
    };
    p._startDecelaration = function() {
        if (this._deceleration) return;
        this._deceleration = true;
        var self = this;
        var tick = function() {
            if (!self._deceleration) return;
            self._computeDeceleration();
            if (Math.abs(self.__speed) > self.options.minValidDist || self.__isout) {
                window.requestAnimationFrame(tick);
            } else {
                self._deceleration = false;
                self.__isout = false;
                if (self.__needsSnap && self.options.snapping && !self.options.paging) {
                    self.value = self._checkLimits(self.end_loc + self.__extraMove);
                } else {
                    self.value = Math.round(self.value);
                }
                self._callrenderer();
                self._callonComplete("decel");
            }
        };
        tick();
    };
    window.Controller = Controller;
})();

(function(window, document, $) {
    window.MSLayerController = function(slide) {
        this.slide = slide;
        this.slider = slide.slider;
        this.layers = [];
        this.layersCount = 0;
        this.preloadCount = 0;
        this.$layers = $("<div></div>").addClass("ms-slide-layers");
        this.$staticLayers = $("<div></div>").addClass("ms-static-layers");
        this.$fixedLayers = $("<div></div>").addClass("ms-fixed-layers");
        this.$animLayers = $("<div></div>").addClass("ms-anim-layers");
    };
    var p = MSLayerController.prototype;
    p.addLayer = function(layer) {
        layer.slide = this.slide;
        layer.controller = this;
        switch (layer.$element.data("position")) {
          case "static":
            this.hasStaticLayer = true;
            layer.$element.appendTo(this.$staticLayers);
            break;

          case "fixed":
            this.hasFixedLayer = true;
            layer.$element.appendTo(this.$fixedLayers);
            break;

          default:
            layer.$element.appendTo(this.$animLayers);
            break;
        }
        layer.create();
        this.layers.push(layer);
        this.layersCount++;
        if (layer.parallax) {
            this.hasParallaxLayer = true;
        }
        if (layer.needPreload) {
            this.preloadCount++;
        }
    };
    p.create = function() {
        this.slide.$element.append(this.$layers);
        this.$layers.append(this.$animLayers);
        if (this.hasStaticLayer) {
            this.$layers.append(this.$staticLayers);
        }
        if (this.slider.options.layersMode == "center") {
            this.$layers.css("max-width", this.slider.options.width + "px");
            if (this.hasFixedLayer) {
                this.$fixedLayers.css("max-width", this.slider.options.width + "px");
            }
        }
    };
    p.loadLayers = function(callback) {
        this._onReadyCallback = callback;
        if (this.preloadCount === 0) {
            this._onlayersReady();
            return;
        }
        for (var i = 0; i !== this.layersCount; ++i) {
            if (this.layers[i].needPreload) {
                this.layers[i].loadImage();
            }
        }
    };
    p.prepareToShow = function() {
        if (this.hasParallaxLayer) {
            this._enableParallaxEffect();
        }
        if (this.hasFixedLayer) {
            this.$fixedLayers.prependTo(this.slide.view.$element);
        }
    };
    p.showLayers = function() {
        if (this.layersHideTween) {
            this.layersHideTween.stop(true);
        }
        if (this.fixedLayersHideTween) {
            this.fixedLayersHideTween.stop(true);
        }
        this._resetLayers();
        this.$animLayers.css("opacity", "").css("display", "");
        if (this.hasFixedLayer) {
            this.$fixedLayers.css("opacity", "").css("display", "");
        }
        if (this.ready) {
            this._initLayers();
            this._locateLayers();
            this._startLayers();
        }
    };
    p.hideLayers = function() {
        if (this.slide.selected || this.slider.options.instantStartLayers) {
            var that = this;
            that.layersHideTween = CTween.animate(this.$animLayers, 500, {
                opacity: 0
            }, {
                complete: function() {
                    that._resetLayers();
                }
            });
            if (this.hasFixedLayer) {
                this.fixedLayersHideTween = CTween.animate(this.$fixedLayers, 500, {
                    opacity: 0
                }, {
                    complete: function() {
                        that.$fixedLayers.detach();
                    }
                });
            }
            if (this.hasParallaxLayer) {
                this._disableParallaxEffect();
            }
        }
    };
    p.animHideLayers = function() {
        if (!this.ready) {
            return;
        }
        for (var i = 0; i !== this.layersCount; ++i) {
            this.layers[i].hide();
        }
    };
    p.setSize = function(width, height, hard) {
        if (this.ready && (this.slide.selected || this.hasStaticLayer)) {
            if (hard) {
                this._initLayers(true);
            }
            this._locateLayers(!this.slide.selected);
        }
        if (this.slider.options.autoHeight) {
            this.updateHeight();
        }
        if (this.slider.options.layersMode == "center") {
            var left = Math.max(0, (width - this.slider.options.width) / 2) + "px";
            this.$layers[0].style.left = left;
            this.$fixedLayers[0].style.left = left;
        }
    };
    p.updateHeight = function() {
        var h = this.slide.getHeight() + "px";
        this.$layers[0].style.height = h;
        this.$fixedLayers[0].style.height = h;
    };
    p._onlayersReady = function() {
        this.ready = true;
        if (this.hasStaticLayer && !this.slide.isSleeping) {
            this._initLayers(false, true);
        }
        this._onReadyCallback.call(this.slide);
    };
    p.onSlideSleep = function() {};
    p.onSlideWakeup = function() {
        if (this.hasStaticLayer && this.ready) {
            this._initLayers(false, true);
        }
    };
    p.destroy = function() {
        if (this.slide.selected && this.hasParallaxLayer) {
            this._disableParallaxEffect();
        }
        for (var i = 0; i < this.layersCount; ++i) {
            this.layers[i].$element.stop(true).remove();
        }
        this.$layers.remove();
        this.$staticLayers.remove();
        this.$fixedLayers.remove();
        this.$animLayers.remove();
    };
    p._startLayers = function() {
        for (var i = 0; i !== this.layersCount; ++i) {
            this.layers[i].start();
        }
    };
    p._initLayers = function(force, onlyStatics) {
        if (this.init && !force || this.slider.init_safemode) {
            return;
        }
        this.init = onlyStatics !== true;
        var i = 0;
        if (onlyStatics && !this.staticsInit) {
            this.staticsInit = true;
            for (;i !== this.layersCount; ++i) {
                if (this.layers[i].staticLayer) {
                    this.layers[i].init();
                }
            }
        } else if (this.staticsInit && !force) {
            for (;i !== this.layersCount; ++i) {
                if (!this.layers[i].staticLayer) {
                    this.layers[i].init();
                }
            }
        } else {
            for (;i !== this.layersCount; ++i) {
                this.layers[i].init();
            }
        }
    };
    p._locateLayers = function(onlyStatics) {
        var i = 0;
        if (onlyStatics) {
            for (;i !== this.layersCount; ++i) {
                if (this.layers[i].staticLayer) {
                    this.layers[i].locate();
                }
            }
        } else {
            for (;i !== this.layersCount; ++i) {
                this.layers[i].locate();
            }
        }
    };
    p._resetLayers = function() {
        this.$animLayers.css("display", "none").css("opacity", 1);
        for (var i = 0; i !== this.layersCount; ++i) {
            this.layers[i].reset();
        }
    };
    p._applyParallax = function(x, y, fast) {
        for (var i = 0; i !== this.layersCount; ++i) {
            if (this.layers[i].parallax != null) {
                this.layers[i].moveParallax(x, y, fast);
            }
        }
    };
    p._enableParallaxEffect = function() {
        if (this.slider.options.parallaxMode === "swipe") {
            this.slide.view.addEventListener(MSViewEvents.SCROLL, this._swipeParallaxMove, this);
        } else {
            this.slide.$element.on("mousemove", {
                that: this
            }, this._mouseParallaxMove).on("mouseleave", {
                that: this
            }, this._resetParalax);
        }
    };
    p._disableParallaxEffect = function() {
        if (this.slider.options.parallaxMode === "swipe") {
            this.slide.view.removeEventListener(MSViewEvents.SCROLL, this._swipeParallaxMove, this);
        } else {
            this.slide.$element.off("mousemove", this._mouseParallaxMove).off("mouseleave", this._resetParalax);
        }
    };
    p._resetParalax = function(e) {
        var that = e.data.that;
        that._applyParallax(0, 0);
    };
    p._mouseParallaxMove = function(e) {
        var that = e.data.that, os = that.slide.$element.offset(), slider = that.slider;
        if (slider.options.parallaxMode !== "mouse:y-only") {
            var x = e.pageX - os.left - that.slide.__width / 2;
        } else {
            var x = 0;
        }
        if (slider.options.parallaxMode !== "mouse:x-only") {
            var y = e.pageY - os.top - that.slide.__height / 2;
        } else {
            var y = 0;
        }
        that._applyParallax(-x, -y);
    };
    p._swipeParallaxMove = function(e) {
        var value = this.slide.position - this.slide.view.__contPos;
        if (this.slider.options.dir === "v") {
            this._applyParallax(0, value, true);
        } else {
            this._applyParallax(value, 0, true);
        }
    };
})(window, document, jQuery);

(function($) {
    window.MSLayerEffects = {};
    var installed, _fade = {
        opacity: 0
    };
    MSLayerEffects.setup = function() {
        if (installed) return;
        installed = true;
        var st = MSLayerEffects, transform_css = window._jcsspfx + "Transform", transform_orig_css = window._jcsspfx + "TransformOrigin", o = $.browser.opera;
        _2d = window._css2d && window._cssanim && !o;
        st.defaultValues = {
            left: 0,
            top: 0,
            opacity: isMSIE("<=9") ? 1 : "",
            right: 0,
            bottom: 0
        };
        st.defaultValues[transform_css] = "";
        st.rf = 1;
        st.presetEffParams = {
            random: "30|300",
            "long": 300,
            "short": 30,
            "false": false,
            "true": true,
            tl: "top left",
            bl: "bottom left",
            tr: "top right",
            br: "bottom right",
            rt: "top right",
            lb: "bottom left",
            lt: "top left",
            rb: "bottom right",
            t: "top",
            b: "bottom",
            r: "right",
            l: "left",
            c: "center"
        };
        st.fade = function() {
            return _fade;
        };
        st.left = _2d ? function(dist, fade) {
            var r = fade === false ? {} : {
                opacity: 0
            };
            r[transform_css] = "translateX(" + -dist * st.rf + "px)";
            return r;
        } : function(dist, fade) {
            var r = fade === false ? {} : {
                opacity: 0
            };
            r.left = -dist * st.rf + "px";
            return r;
        };
        st.right = _2d ? function(dist, fade) {
            var r = fade === false ? {} : {
                opacity: 0
            };
            r[transform_css] = "translateX(" + dist * st.rf + "px)";
            return r;
        } : function(dist, fade) {
            var r = fade === false ? {} : {
                opacity: 0
            };
            r.left = dist * st.rf + "px";
            return r;
        };
        st.top = _2d ? function(dist, fade) {
            var r = fade === false ? {} : {
                opacity: 0
            };
            r[transform_css] = "translateY(" + -dist * st.rf + "px)";
            return r;
        } : function(dist, fade) {
            var r = fade === false ? {} : {
                opacity: 0
            };
            r.top = -dist * st.rf + "px";
            return r;
        };
        st.bottom = _2d ? function(dist, fade) {
            var r = fade === false ? {} : {
                opacity: 0
            };
            r[transform_css] = "translateY(" + dist * st.rf + "px)";
            return r;
        } : function(dist, fade) {
            var r = fade === false ? {} : {
                opacity: 0
            };
            r.top = dist * st.rf + "px";
            return r;
        };
        st.from = _2d ? function(leftdis, topdis, fade) {
            var r = fade === false ? {} : {
                opacity: 0
            };
            r[transform_css] = "translateX(" + leftdis * st.rf + "px) translateY(" + topdis * st.rf + "px)";
            return r;
        } : function(leftdis, topdis, fade) {
            var r = fade === false ? {} : {
                opacity: 0
            };
            r.top = topdis * st.rf + "px";
            r.left = leftdis * st.rf + "px";
            return r;
        };
        st.rotate = _2d ? function(deg, orig) {
            var r = {
                opacity: 0
            };
            r[transform_css] = " rotate(" + deg + "deg)";
            if (orig) r[transform_orig_css] = orig;
            return r;
        } : function(deg, orig) {
            return _fade;
        };
        st.rotateleft = _2d ? function(deg, dist, orig, fade) {
            var r = st.left(dist, fade);
            r[transform_css] += " rotate(" + deg + "deg)";
            if (orig) r[transform_orig_css] = orig;
            return r;
        } : function(deg, dist, orig, fade) {
            return st.left(dist, fade);
        };
        st.rotateright = _2d ? function(deg, dist, orig, fade) {
            var r = st.right(dist, fade);
            r[transform_css] += " rotate(" + deg + "deg)";
            if (orig) r[transform_orig_css] = orig;
            return r;
        } : function(deg, dist, orig, fade) {
            return st.right(dist, fade);
        };
        st.rotatetop = _2d ? function(deg, dist, orig, fade) {
            var r = st.top(dist, fade);
            r[transform_css] += " rotate(" + deg + "deg)";
            if (orig) r[transform_orig_css] = orig;
            return r;
        } : function(deg, dist, orig, fade) {
            return st.top(dist, fade);
        };
        st.rotatebottom = _2d ? function(deg, dist, orig, fade) {
            var r = st.bottom(dist, fade);
            r[transform_css] += " rotate(" + deg + "deg)";
            if (orig) r[transform_orig_css] = orig;
            return r;
        } : function(deg, dist, orig, fade) {
            return st.bottom(dist, fade);
        };
        st.rotatefrom = _2d ? function(deg, leftdis, topdis, orig, fade) {
            var r = st.from(leftdis, topdis, fade);
            r[transform_css] += " rotate(" + deg + "deg)";
            if (orig) r[transform_orig_css] = orig;
            return r;
        } : function(deg, leftdis, topdis, orig, fade) {
            return st.from(leftdis, topdis, fade);
        };
        st.skewleft = _2d ? function(deg, dist, fade) {
            var r = st.left(dist, fade);
            r[transform_css] += " skewX(" + deg + "deg)";
            return r;
        } : function(deg, dist, fade) {
            return st.left(dist, fade);
        };
        st.skewright = _2d ? function(deg, dist, fade) {
            var r = st.right(dist, fade);
            r[transform_css] += " skewX(" + -deg + "deg)";
            return r;
        } : function(deg, dist, fade) {
            return st.right(dist, fade);
        };
        st.skewtop = _2d ? function(deg, dist, fade) {
            var r = st.top(dist, fade);
            r[transform_css] += " skewY(" + deg + "deg)";
            return r;
        } : function(deg, dist, fade) {
            return st.top(dist, fade);
        };
        st.skewbottom = _2d ? function(deg, dist, fade) {
            var r = st.bottom(dist, fade);
            r[transform_css] += " skewY(" + -deg + "deg)";
            return r;
        } : function(deg, dist, fade) {
            return st.bottom(dist, fade);
        };
        st.scale = _2d ? function(x, y, orig, fade) {
            var r = fade === false ? {} : {
                opacity: 0
            };
            r[transform_css] = " scaleX(" + x + ") scaleY(" + y + ")";
            if (orig) r[transform_orig_css] = orig;
            return r;
        } : function(x, y, orig, fade) {
            return fade === false ? {} : {
                opacity: 0
            };
        };
        st.scaleleft = _2d ? function(x, y, dist, orig, fade) {
            var r = st.left(dist, fade);
            r[transform_css] = " scaleX(" + x + ") scaleY(" + y + ")";
            if (orig) r[transform_orig_css] = orig;
            return r;
        } : function(x, y, dist, orig, fade) {
            return st.left(dist, fade);
        };
        st.scaleright = _2d ? function(x, y, dist, orig, fade) {
            var r = st.right(dist, fade);
            r[transform_css] = " scaleX(" + x + ") scaleY(" + y + ")";
            if (orig) r[transform_orig_css] = orig;
            return r;
        } : function(x, y, dist, orig, fade) {
            return st.right(dist, fade);
        };
        st.scaletop = _2d ? function(x, y, dist, orig, fade) {
            var r = st.top(dist, fade);
            r[transform_css] = " scaleX(" + x + ") scaleY(" + y + ")";
            if (orig) r[transform_orig_css] = orig;
            return r;
        } : function(x, y, dist, orig, fade) {
            return st.top(dist, fade);
        };
        st.scalebottom = _2d ? function(x, y, dist, orig, fade) {
            var r = st.bottom(dist, fade);
            r[transform_css] = " scaleX(" + x + ") scaleY(" + y + ")";
            if (orig) r[transform_orig_css] = orig;
            return r;
        } : function(x, y, dist, orig, fade) {
            return st.bottom(dist, fade);
        };
        st.scalefrom = _2d ? function(x, y, leftdis, topdis, orig, fade) {
            var r = st.from(leftdis, topdis, fade);
            r[transform_css] += " scaleX(" + x + ") scaleY(" + y + ")";
            if (orig) r[transform_orig_css] = orig;
            return r;
        } : function(x, y, leftdis, topdis, orig, fade) {
            return st.from(leftdis, topdis, fade);
        };
        st.rotatescale = _2d ? function(deg, x, y, orig, fade) {
            var r = st.scale(x, y, orig, fade);
            r[transform_css] += " rotate(" + deg + "deg)";
            if (orig) r[transform_orig_css] = orig;
            return r;
        } : function(deg, x, y, orig, fade) {
            return st.scale(x, y, orig, fade);
        };
        st.front = window._css3d ? function(dist, fade) {
            var r = fade === false ? {} : {
                opacity: 0
            };
            r[transform_css] = "perspective(2000px) translate3d(0 , 0 ," + dist + "px ) rotate(0.001deg)";
            return r;
        } : function(dist) {
            return _fade;
        };
        st.back = window._css3d ? function(dist, fade) {
            var r = fade === false ? {} : {
                opacity: 0
            };
            r[transform_css] = "perspective(2000px) translate3d(0 , 0 ," + -dist + "px ) rotate(0.001deg)";
            return r;
        } : function(dist) {
            return _fade;
        };
        st.rotatefront = window._css3d ? function(deg, dist, orig, fade) {
            var r = fade === false ? {} : {
                opacity: 0
            };
            r[transform_css] = "perspective(2000px) translate3d(0 , 0 ," + dist + "px ) rotate(" + (deg || .001) + "deg)";
            if (orig) r[transform_orig_css] = orig;
            return r;
        } : function(deg, dist, orig, fade) {
            return _fade;
        };
        st.rotateback = window._css3d ? function(deg, dist, orig, fade) {
            var r = fade === false ? {} : {
                opacity: 0
            };
            r[transform_css] = "perspective(2000px) translate3d(0 , 0 ," + -dist + "px ) rotate(" + (deg || .001) + "deg)";
            if (orig) r[transform_orig_css] = orig;
            return r;
        } : function(deg, dist, orig, fade) {
            return _fade;
        };
        st.rotate3dleft = window._css3d ? function(x, y, z, dist, orig, fade) {
            var r = st.left(dist, fade);
            r[transform_css] += (x ? " rotateX(" + x + "deg)" : " ") + (y ? " rotateY(" + y + "deg)" : "") + (z ? " rotateZ(" + z + "deg)" : "");
            if (orig) r[transform_orig_css] = orig;
            return r;
        } : function(x, y, z, dist, orig, fade) {
            return st.left(dist, fade);
        };
        st.rotate3dright = window._css3d ? function(x, y, z, dist, orig, fade) {
            var r = st.right(dist, fade);
            r[transform_css] += (x ? " rotateX(" + x + "deg)" : " ") + (y ? " rotateY(" + y + "deg)" : "") + (z ? " rotateZ(" + z + "deg)" : "");
            if (orig) r[transform_orig_css] = orig;
            return r;
        } : function(x, y, z, dist, orig, fade) {
            return st.right(dist, fade);
        };
        st.rotate3dtop = window._css3d ? function(x, y, z, dist, orig, fade) {
            var r = st.top(dist, fade);
            r[transform_css] += (x ? " rotateX(" + x + "deg)" : " ") + (y ? " rotateY(" + y + "deg)" : "") + (z ? " rotateZ(" + z + "deg)" : "");
            if (orig) r[transform_orig_css] = orig;
            return r;
        } : function(x, y, z, dist, orig, fade) {
            return st.top(dist, fade);
        };
        st.rotate3dbottom = window._css3d ? function(x, y, z, dist, orig, fade) {
            var r = st.bottom(dist, fade);
            r[transform_css] += (x ? " rotateX(" + x + "deg)" : " ") + (y ? " rotateY(" + y + "deg)" : "") + (z ? " rotateZ(" + z + "deg)" : "");
            if (orig) r[transform_orig_css] = orig;
            return r;
        } : function(x, y, z, dist, orig, fade) {
            return st.bottom(dist, fade);
        };
        st.rotate3dfront = window._css3d ? function(x, y, z, dist, orig, fade) {
            var r = st.front(dist, fade);
            r[transform_css] += (x ? " rotateX(" + x + "deg)" : " ") + (y ? " rotateY(" + y + "deg)" : "") + (z ? " rotateZ(" + z + "deg)" : "");
            if (orig) r[transform_orig_css] = orig;
            return r;
        } : function(x, y, z, dist, orig, fade) {
            return st.front(dist, fade);
        };
        st.rotate3dback = window._css3d ? function(x, y, z, dist, orig, fade) {
            var r = st.back(dist, fade);
            r[transform_css] += (x ? " rotateX(" + x + "deg)" : " ") + (y ? " rotateY(" + y + "deg)" : "") + (z ? " rotateZ(" + z + "deg)" : "");
            if (orig) r[transform_orig_css] = orig;
            return r;
        } : function(x, y, z, dist, orig, fade) {
            return st.back(dist, fade);
        };
        st.t = window._css3d ? function(fade, tx, ty, tz, r, rx, ry, rz, scx, scy, skx, sky, ox, oy, oz) {
            var _r = fade === false ? {} : {
                opacity: 0
            };
            var transform = "perspective(2000px) ";
            tx !== "n" && (transform += "translateX(" + tx * st.rf + "px) ");
            ty !== "n" && (transform += "translateY(" + ty * st.rf + "px) ");
            tz !== "n" && (transform += "translateZ(" + tz * st.rf + "px) ");
            r !== "n" && (transform += "rotate(" + r + "deg) ");
            rx !== "n" && (transform += "rotateX(" + rx + "deg) ");
            ry !== "n" && (transform += "rotateY(" + ry + "deg) ");
            rz !== "n" && (transform += "rotateZ(" + rz + "deg) ");
            skx !== "n" && (transform += "skewX(" + skx + "deg) ");
            sky !== "n" && (transform += "skewY(" + sky + "deg) ");
            scx !== "n" && (transform += "scaleX(" + scx + ") ");
            scy !== "n" && (transform += "scaleY(" + scy + ")");
            _r[transform_css] = transform;
            var trans_origin = "";
            trans_origin += ox !== "n" ? ox + "% " : "50% ";
            trans_origin += oy !== "n" ? oy + "% " : "50% ";
            trans_origin += oz !== "n" ? oz + "px" : "";
            _r[transform_orig_css] = trans_origin;
            return _r;
        } : function(fade, tx, ty, tz, r, rx, ry, rz, scx, scy, skx, sky, ox, oy, oz) {
            var r = fade === false ? {} : {
                opacity: 0
            };
            tx !== "n" && (r.left = tx * st.rf + "px");
            ty !== "n" && (r.top = ty * st.rf + "px");
            return r;
        };
    };
})(jQuery);

(function($) {
    window.MSLayerElement = function() {
        this.start_anim = {
            name: "fade",
            duration: 1e3,
            ease: "linear",
            delay: 0
        };
        this.end_anim = {
            duration: 1e3,
            ease: "linear"
        };
        this.type = "text";
        this.resizable = true;
        this.minWidth = -1;
        this.isVisible = true;
        this.__cssConfig = [ "margin-top", "padding-top", "margin-bottom", "padding-left", "margin-right", "padding-right", "margin-left", "padding-bottom", "font-size", "line-height", "width", "left", "right", "top", "bottom" ];
        this.baseStyle = {};
    };
    var p = MSLayerElement.prototype;
    p.setStartAnim = function(anim) {
        $.extend(this.start_anim, anim);
        $.extend(this.start_anim, this._parseEff(this.start_anim.name));
        this.$element.css("visibility", "hidden");
    };
    p.setEndAnim = function(anim) {
        $.extend(this.end_anim, anim);
    };
    p.create = function() {
        this.$element.css("display", "none");
        this.resizable = this.$element.data("resize") !== false;
        this.fixed = this.$element.data("fixed") === true;
        if (this.$element.data("widthlimit") !== undefined) {
            this.minWidth = this.$element.data("widthlimit");
        }
        if (!this.end_anim.name) {
            this.end_anim.name = this.start_anim.name;
        }
        if (this.end_anim.time) {
            this.autoHide = true;
        }
        this.staticLayer = this.$element.data("position") === "static";
        this.fixedLayer = this.$element.data("position") === "fixed";
        this.layersCont = this.controller.$layers;
        if (this.staticLayer) {
            this.$element.css("display", "").css("visibility", "");
        }
        if (this.$element.data("action") !== undefined) {
            var slideController = this.slide.slider.slideController;
            this.$element.on("click", function(event) {
                slideController.runAction($(this).data("action"));
                event.preventDefault();
            }).addClass("ms-action-layer");
        }
        $.extend(this.end_anim, this._parseEff(this.end_anim.name));
        this.slider = this.slide.slider;
        var layerOrigin = this.layerOrigin = this.$element.data("origin");
        if (layerOrigin) {
            var vOrigin = layerOrigin.charAt(0), hOrigin = layerOrigin.charAt(1), offsetX = this.$element.data("offset-x"), offsetY = this.$element.data("offset-y");
            if (offsetY === undefined) {
                offsetY = 0;
            }
            switch (vOrigin) {
              case "t":
                this.$element[0].style.top = offsetY + "px";
                break;

              case "b":
                this.$element[0].style.bottom = offsetY + "px";
                break;

              case "m":
                this.$element[0].style.top = offsetY + "px";
                this.middleAlign = true;
            }
            if (offsetX === undefined) {
                offsetX = 0;
            }
            switch (hOrigin) {
              case "l":
                this.$element[0].style.left = offsetX + "px";
                break;

              case "r":
                this.$element[0].style.right = offsetX + "px";
                break;

              case "c":
                this.$element[0].style.left = offsetX + "px";
                this.centerAlign = true;
            }
        }
        this.parallax = this.$element.data("parallax");
        if (this.parallax != null) {
            this.parallax /= 100;
            this.$parallaxElement = $("<div></div>").addClass("ms-parallax-layer");
            if (this.link) {
                this.link.wrap(this.$parallaxElement);
                this.$parallaxElement = this.link.parent();
            } else {
                this.$element.wrap(this.$parallaxElement);
                this.$parallaxElement = this.$element.parent();
            }
            this._lastParaX = 0;
            this._lastParaY = 0;
            this._paraX = 0;
            this._paraY = 0;
            this.alignedToBot = this.layerOrigin && this.layerOrigin.indexOf("b") !== -1;
            if (this.alignedToBot) {
                this.$parallaxElement.css("bottom", 0);
            }
            if (window._css3d) {
                this.parallaxRender = this._parallaxCSS3DRenderer;
            } else if (window._css2d) {
                this.parallaxRender = this._parallaxCSS2DRenderer;
            } else {
                this.parallaxRender = this._parallax2DRenderer;
            }
            if (this.slider.options.parallaxMode !== "swipe") {
                averta.Ticker.add(this.parallaxRender, this);
            }
        }
        $.removeDataAttrs(this.$element, [ "data-src" ]);
    };
    p.init = function() {
        this.initialized = true;
        var value;
        this.$element.css("visibility", "");
        for (var i = 0, l = this.__cssConfig.length; i < l; i++) {
            var key = this.__cssConfig[i];
            if (this.type === "text" && key === "width") {
                value = this.$element[0].style.width;
            } else {
                value = this.$element.css(key);
                if ((key === "width" || key === "height") && value === "0px") {
                    value = this.$element.data(key) + "px";
                }
            }
            if (value != "auto" && value != "" && value != "normal") {
                this.baseStyle[key] = parseInt(value);
            }
        }
        if (this.middleAlign) {
            this.baseHeight = this.$element.outerHeight(false);
        }
        if (this.centerAlign) {
            this.baseWidth = this.$element.outerWidth(false);
        }
    };
    p.locate = function() {
        if (!this.slide.ready) {
            return;
        }
        var width = parseFloat(this.layersCont.css("width")), height = parseFloat(this.layersCont.css("height")), factor, isPosition;
        if (!this.staticLayer && this.$element.css("display") === "none" && this.isVisible) {
            this.$element.css("display", "").css("visibility", "hidden");
        }
        factor = this.resizeFactor = width / this.slide.slider.options.width;
        for (var key in this.baseStyle) {
            isPosition = key === "top" || key === "left" || key === "bottom" || key === "right";
            if (this.fixed && isPosition) {
                factor = 1;
            } else {
                factor = this.resizeFactor;
            }
            if (!this.resizable && !isPosition) {
                continue;
            }
            if (key === "top" && this.middleAlign) {
                this.$element[0].style.top = "0px";
                this.baseHeight = this.$element.outerHeight(false);
                this.$element[0].style.top = this.baseStyle["top"] * factor + (height - this.baseHeight) / 2 + "px";
            } else if (key === "left" && this.centerAlign) {
                this.$element[0].style.left = "0px";
                this.baseWidth = this.$element.outerWidth(false);
                this.$element[0].style.left = this.baseStyle["left"] * factor + (width - this.baseWidth) / 2 + "px";
            } else {
                this.$element.css(key, this.baseStyle[key] * factor + "px");
            }
        }
        this.visible(this.minWidth < width);
    };
    p.start = function() {
        if (this.isShowing || this.staticLayer) {
            return;
        }
        this.isShowing = true;
        var key, base;
        MSLayerEffects.rf = this.resizeFactor;
        var effect_css = MSLayerEffects[this.start_anim.eff_name].apply(null, this._parseEffParams(this.start_anim.eff_params));
        var start_css_eff = {};
        for (key in effect_css) {
            if (this._checkPosKey(key, effect_css)) {
                continue;
            }
            if (MSLayerEffects.defaultValues[key] != null) {
                start_css_eff[key] = MSLayerEffects.defaultValues[key];
            }
            if (key in this.baseStyle) {
                base = this.baseStyle[key];
                if (this.middleAlign && key === "top") {
                    base += (parseInt(this.layersCont.height()) - this.$element.outerHeight(false)) / 2;
                }
                if (this.centerAlign && key === "left") {
                    base += (parseInt(this.layersCont.width()) - this.$element.outerWidth(false)) / 2;
                }
                effect_css[key] = base + parseFloat(effect_css[key]) + "px";
                start_css_eff[key] = base + "px";
            }
            this.$element.css(key, effect_css[key]);
        }
        var that = this;
        clearTimeout(this.to);
        this.to = setTimeout(function() {
            that.$element.css("visibility", "");
            that._playAnimation(that.start_anim, start_css_eff);
        }, that.start_anim.delay || .01);
        this.clTo = setTimeout(function() {
            that.show_cl = true;
        }, (this.start_anim.delay || .01) + this.start_anim.duration);
        if (this.autoHide) {
            clearTimeout(this.hto);
            this.hto = setTimeout(function() {
                that.hide();
            }, that.end_anim.time);
        }
    };
    p.hide = function() {
        if (this.staticLayer) {
            return;
        }
        this.isShowing = false;
        var effect_css = MSLayerEffects[this.end_anim.eff_name].apply(null, this._parseEffParams(this.end_anim.eff_params));
        for (key in effect_css) {
            if (this._checkPosKey(key, effect_css)) continue;
            if (key === window._jcsspfx + "TransformOrigin") {
                this.$element.css(key, effect_css[key]);
            }
            if (key in this.baseStyle) {
                effect_css[key] = this.baseStyle[key] + parseFloat(effect_css[key]) + "px";
            }
        }
        this._playAnimation(this.end_anim, effect_css);
        clearTimeout(this.to);
        clearTimeout(this.hto);
        clearTimeout(this.clTo);
    };
    p.reset = function() {
        if (this.staticLayer) {
            return;
        }
        this.isShowing = false;
        this.$element[0].style.display = "none";
        this.$element.css("opacity", "");
        this.$element[0].style["transitionDuration"] = "";
        if (this.show_tween) this.show_tween.stop(true);
        clearTimeout(this.to);
        clearTimeout(this.hto);
    };
    p.destroy = function() {
        this.reset();
        this.$element.remove();
    };
    p.visible = function(value) {
        if (this.isVisible == value) return;
        this.isVisible = value;
        this.$element.css("display", value ? "" : "none");
    };
    p.moveParallax = function(x, y, fast) {
        this._paraX = x;
        this._paraY = y;
        if (fast) {
            this._lastParaX = x;
            this._lastParaY = y;
            this.parallaxRender();
        }
    };
    p._playAnimation = function(animation, css) {
        var options = {};
        if (animation.ease) {
            options.ease = animation.ease;
        }
        options.transProperty = window._csspfx + "transform,opacity";
        this.show_tween = CTween.animate(this.$element, animation.duration, css, options);
    };
    p._randomParam = function(value) {
        var min = Number(value.slice(0, value.indexOf("|")));
        var max = Number(value.slice(value.indexOf("|") + 1));
        return min + Math.random() * (max - min);
    };
    p._parseEff = function(eff_name) {
        var eff_params = [];
        if (eff_name.indexOf("(") !== -1) {
            var temp = eff_name.slice(0, eff_name.indexOf("(")).toLowerCase();
            var value;
            eff_params = eff_name.slice(eff_name.indexOf("(") + 1, -1).replace(/\"|\'|\s/g, "").split(",");
            eff_name = temp;
            for (var i = 0, l = eff_params.length; i < l; ++i) {
                value = eff_params[i];
                if (value in MSLayerEffects.presetEffParams) {
                    value = MSLayerEffects.presetEffParams[value];
                }
                eff_params[i] = value;
            }
        }
        return {
            eff_name: eff_name,
            eff_params: eff_params
        };
    };
    p._parseEffParams = function(params) {
        var eff_params = [];
        for (var i = 0, l = params.length; i < l; ++i) {
            var value = params[i];
            if (typeof value === "string" && value.indexOf("|") !== -1) value = this._randomParam(value);
            eff_params[i] = value;
        }
        return eff_params;
    };
    p._checkPosKey = function(key, style) {
        if (key === "left" && !(key in this.baseStyle) && "right" in this.baseStyle) {
            style.right = -parseInt(style.left) + "px";
            delete style.left;
            return true;
        }
        if (key === "top" && !(key in this.baseStyle) && "bottom" in this.baseStyle) {
            style.bottom = -parseInt(style.top) + "px";
            delete style.top;
            return true;
        }
        return false;
    };
    p._parallaxCalc = function() {
        var x_def = this._paraX - this._lastParaX, y_def = this._paraY - this._lastParaY;
        this._lastParaX += x_def / 12;
        this._lastParaY += y_def / 12;
        if (Math.abs(x_def) < .019) {
            this._lastParaX = this._paraX;
        }
        if (Math.abs(y_def) < .019) {
            this._lastParaY = this._paraY;
        }
    };
    p._parallaxCSS3DRenderer = function() {
        this._parallaxCalc();
        this.$parallaxElement[0].style[window._jcsspfx + "Transform"] = "translateX(" + this._lastParaX * this.parallax + "px) translateY(" + this._lastParaY * this.parallax + "px) translateZ(0)";
    };
    p._parallaxCSS2DRenderer = function() {
        this._parallaxCalc();
        this.$parallaxElement[0].style[window._jcsspfx + "Transform"] = "translateX(" + this._lastParaX * this.parallax + "px) translateY(" + this._lastParaY * this.parallax + "px)";
    };
    p._parallax2DRenderer = function() {
        this._parallaxCalc();
        if (this.alignedToBot) {
            this.$parallaxElement[0].style.bottom = this._lastParaY * this.parallax + "px";
        } else {
            this.$parallaxElement[0].style.top = this._lastParaY * this.parallax + "px";
        }
        this.$parallaxElement[0].style.left = this._lastParaX * this.parallax + "px";
    };
})(jQuery);

(function($) {
    window.MSImageLayerElement = function() {
        MSLayerElement.call(this);
        this.needPreload = true;
        this.__cssConfig = [ "width", "height", "margin-top", "padding-top", "margin-bottom", "padding-left", "margin-right", "padding-right", "margin-left", "padding-bottom", "left", "right", "top", "bottom" ];
        this.type = "image";
    };
    MSImageLayerElement.extend(MSLayerElement);
    var p = MSImageLayerElement.prototype;
    var _super = MSLayerElement.prototype;
    p.create = function() {
        if (this.link) {
            var p = this.$element.parent();
            p.append(this.link);
            this.link.append(this.$element);
            this.link.removeClass("ms-layer");
            this.$element.addClass("ms-layer");
            p = null;
        }
        _super.create.call(this);
        if (this.$element.data("src") != undefined) {
            this.img_src = this.$element.data("src");
            this.$element.removeAttr("data-src");
        } else {
            var that = this;
            this.$element.on("load", function(event) {
                that.controller.preloadCount--;
                if (that.controller.preloadCount === 0) that.controller._onlayersReady();
            }).each($.jqLoadFix);
        }
        if ($.browser.msie) this.$element.on("dragstart", function(event) {
            event.preventDefault();
        });
    };
    p.loadImage = function() {
        var that = this;
        this.$element.preloadImg(this.img_src, function(event) {
            that.controller.preloadCount--;
            if (that.controller.preloadCount === 0) that.controller._onlayersReady();
        });
    };
})(jQuery);

(function($) {
    window.MSVideoLayerElement = function() {
        MSLayerElement.call(this);
        this.__cssConfig.push("height");
        this.type = "video";
    };
    MSVideoLayerElement.extend(MSLayerElement);
    var p = MSVideoLayerElement.prototype;
    var _super = MSLayerElement.prototype;
    p.__playVideo = function() {
        if (this.img) CTween.fadeOut(this.img, 500, 2);
        CTween.fadeOut(this.video_btn, 500, 2);
        this.video_frame.attr("src", "about:blank").css("display", "block");
        if (this.video_url.indexOf("?") == -1) this.video_url += "?";
        this.video_frame.attr("src", this.video_url + "&autoplay=1");
    };
    p.start = function() {
        _super.start.call(this);
        if (this.$element.data("autoplay")) {
            this.__playVideo();
        }
    };
    p.reset = function() {
        _super.reset.call(this);
        if (this.needPreload || this.$element.data("btn")) {
            this.video_btn.css("opacity", 1).css("display", "block");
            this.video_frame.attr("src", "about:blank").css("display", "none");
        }
        if (this.needPreload) {
            this.img.css("opacity", 1).css("display", "block");
            return;
        }
        this.video_frame.attr("src", this.video_url);
    };
    p.create = function() {
        _super.create.call(this);
        this.video_frame = this.$element.find("iframe").css({
            width: "100%",
            height: "100%"
        });
        this.video_url = this.video_frame.attr("src");
        var has_img = this.$element.has("img").length != 0;
        if (!has_img && !this.$element.data("btn")) return;
        this.video_frame.attr("src", "about:blank").css("display", "none");
        var that = this;
        this.video_btn = $("<div></div>").appendTo(this.$element).addClass("ms-video-btn").click(function() {
            that.__playVideo();
        });
        if (!has_img) return;
        this.needPreload = true;
        this.img = this.$element.find("img:first").addClass("ms-video-img");
        if (this.img.data("src") !== undefined) {
            this.img_src = this.img.data("src");
            this.img.removeAttr("data-src");
        } else {
            var that = this;
            this.img.attr("src", this.img_src).on("load", function(event) {
                that.controller.preloadCount--;
                if (that.controller.preloadCount === 0) that.controller._onlayersReady();
            }).each($.jqLoadFix);
        }
        if ($.browser.msie) this.img.on("dragstart", function(event) {
            event.preventDefault();
        });
    };
    p.loadImage = function() {
        var that = this;
        this.img.preloadImg(this.img_src, function(event) {
            that.controller.preloadCount--;
            if (that.controller.preloadCount === 0) that.controller._onlayersReady();
        });
    };
})(jQuery);

(function($) {
    "use strict";
    window.MSHotspotLayer = function() {
        MSLayerElement.call(this);
        this.__cssConfig = [ "margin-top", "padding-top", "margin-bottom", "padding-left", "margin-right", "padding-right", "margin-left", "padding-bottom", "left", "right", "top", "bottom" ];
        this.ease = "Expo";
        this.hide_start = true;
        this.type = "hotspot";
    };
    MSHotspotLayer.extend(MSLayerElement);
    var p = MSHotspotLayer.prototype;
    var _super = MSLayerElement.prototype;
    p._showTT = function() {
        if (!this.show_cl) return;
        clearTimeout(this.hto);
        if (this._tween) this._tween.stop(true);
        if (this.hide_start) {
            this.align = this._orgAlign;
            this._locateTT();
            this.tt.css({
                display: "block"
            });
            this._tween = CTween.animate(this.tt, 900, this.to, {
                ease: "easeOut" + this.ease
            });
            this.hide_start = false;
        }
    };
    p._hideTT = function() {
        if (!this.show_cl) return;
        if (this._tween) this._tween.stop(true);
        var that = this;
        clearTimeout(this.hto);
        this.hto = setTimeout(function() {
            that.hide_start = true;
            that._tween = CTween.animate(that.tt, 900, that.from, {
                ease: "easeOut" + that.ease,
                complete: function() {
                    that.tt.css("display", "none");
                }
            });
        }, 200);
    };
    p._updateClassName = function(name) {
        if (this._lastClass) this.tt.removeClass(this._lastClass);
        this.tt.addClass(name);
        this._lastClass = name;
    };
    p._alignPolicy = function() {
        var h = this.tt.outerHeight(false), w = Math.max(this.tt.outerWidth(false), parseInt(this.tt.css("max-width"))), ww = window.innerWidth, wh = window.innerHeight;
        switch (this.align) {
          case "top":
            if (this.base_t < 0) return "bottom";
            break;

          case "right":
            if (this.base_l + w > ww || this.base_t < 0) return "bottom";
            break;

          case "left":
            if (this.base_l < 0 || this.base_t < 0) return "bottom";
            break;
        }
        return null;
    };
    p._locateTT = function() {
        var os = this.$element.offset(), os2 = this.slide.slider.$element.offset();
        var dist = 50, space = 15;
        this.pos_x = os.left - os2.left - this.slide.slider.$element.scrollLeft();
        this.pos_y = os.top - os2.top - this.slide.slider.$element.scrollTop();
        this.from = {
            opacity: 0
        };
        this.to = {
            opacity: 1
        };
        this._updateClassName("ms-tooltip-" + this.align);
        this.tt_arrow.css("margin-left", "");
        var arrow_w = 15, arrow_h = 15;
        switch (this.align) {
          case "top":
            var w = Math.min(this.tt.outerWidth(false), parseInt(this.tt.css("max-width")));
            this.base_t = this.pos_y - this.tt.outerHeight(false) - arrow_h - space;
            this.base_l = this.pos_x - w / 2;
            if (this.base_l + w > window.innerWidth) {
                this.tt_arrow.css("margin-left", -arrow_w / 2 + this.base_l + w - window.innerWidth + "px");
                this.base_l = window.innerWidth - w;
            }
            if (this.base_l < 0) {
                this.base_l = 0;
                this.tt_arrow.css("margin-left", -arrow_w / 2 + this.pos_x - this.tt.outerWidth(false) / 2 + "px");
            }
            if (window._css3d) {
                this.from[window._jcsspfx + "Transform"] = "translateY(-" + dist + "px)";
                this.to[window._jcsspfx + "Transform"] = "";
            } else {
                this.from.top = this.base_t - dist + "px";
                this.to.top = this.base_t + "px";
            }
            break;

          case "bottom":
            var w = Math.min(this.tt.outerWidth(false), parseInt(this.tt.css("max-width")));
            this.base_t = this.pos_y + arrow_h + space;
            this.base_l = this.pos_x - w / 2;
            if (this.base_l + w > window.innerWidth) {
                this.tt_arrow.css("margin-left", -arrow_w / 2 + this.base_l + w - window.innerWidth + "px");
                this.base_l = window.innerWidth - w;
            }
            if (this.base_l < 0) {
                this.base_l = 0;
                this.tt_arrow.css("margin-left", -arrow_w / 2 + this.pos_x - this.tt.outerWidth(false) / 2 + "px");
            }
            if (window._css3d) {
                this.from[window._jcsspfx + "Transform"] = "translateY(" + dist + "px)";
                this.to[window._jcsspfx + "Transform"] = "";
            } else {
                this.from.top = this.base_t + dist + "px";
                this.to.top = this.base_t + "px";
            }
            break;

          case "right":
            this.base_l = this.pos_x + arrow_w + space;
            this.base_t = this.pos_y - this.tt.outerHeight(false) / 2;
            if (window._css3d) {
                this.from[window._jcsspfx + "Transform"] = "translateX(" + dist + "px)";
                this.to[window._jcsspfx + "Transform"] = "";
            } else {
                this.from.left = this.base_l + dist + "px";
                this.to.left = this.base_l + "px";
            }
            break;

          case "left":
            this.base_l = this.pos_x - arrow_w - this.tt.outerWidth(false) - space;
            this.base_t = this.pos_y - this.tt.outerHeight(false) / 2;
            if (window._css3d) {
                this.from[window._jcsspfx + "Transform"] = "translateX(-" + dist + "px)";
                this.to[window._jcsspfx + "Transform"] = "";
            } else {
                this.from.left = this.base_l - dist + "px";
                this.to.left = this.base_l + "px";
            }
            break;
        }
        var policyAlign = this._alignPolicy();
        if (policyAlign !== null) {
            this.align = policyAlign;
            this._locateTT();
            return;
        }
        this.tt.css("top", parseInt(this.base_t) + "px").css("left", parseInt(this.base_l) + "px");
        this.tt.css(this.from);
    };
    p.start = function() {
        _super.start.call(this);
        this.tt.appendTo(this.slide.slider.$element);
        this.tt.css("display", "none");
    };
    p.reset = function() {
        _super.reset.call(this);
        this.tt.detach();
    };
    p.create = function() {
        var that = this;
        this._orgAlign = this.align = this.$element.data("align") !== undefined ? this.$element.data("align") : "top";
        this.data = this.$element.html();
        this.$element.html("").on("mouseenter", function() {
            that._showTT();
        }).on("mouseleave", function() {
            that._hideTT();
        });
        this.point = $('<div><div class="ms-point-center"></div><div class="ms-point-border"></div></div>').addClass("ms-tooltip-point").appendTo(this.$element);
        var link = this.$element.data("link"), target = this.$element.data("target");
        if (link) {
            this.point.on("click", function() {
                window.open(link, target || "_self");
            });
        }
        this.tt = $("<div></div>").addClass("ms-tooltip").css("display", "hidden").css("opacity", 0);
        if (this.$element.data("width") !== undefined) {
            this.tt.css("width", this.$element.data("width")).css("max-width", this.$element.data("width"));
        }
        this.tt_arrow = $("<div></div>").addClass("ms-tooltip-arrow").appendTo(this.tt);
        this._updateClassName("ms-tooltip-" + this.align);
        this.ttcont = $("<div></div>").addClass("ms-tooltip-cont").html(this.data).appendTo(this.tt);
        if (this.$element.data("stay-hover") === true) {
            this.tt.on("mouseenter", function() {
                if (that.hide_start) {
                    return;
                }
                clearTimeout(that.hto);
                that._tween.stop(true);
                that._showTT();
            }).on("mouseleave", function() {
                that._hideTT();
            });
        }
        _super.create.call(this);
    };
})(jQuery);

(function($) {
    window.MSButtonLayer = function() {
        MSLayerElement.call(this);
        this.type = "button";
    };
    MSButtonLayer.extend(MSLayerElement);
    var p = MSButtonLayer.prototype;
    var _super = MSLayerElement.prototype;
    var positionKies = [ "top", "left", "bottom", "right" ];
    p.create = function() {
        _super.create.call(this);
        this.$element.wrap('<div class="ms-btn-container"></div>').css("position", "relative");
        this.$container = this.$element.parent();
    };
    p.locate = function() {
        _super.locate.call(this);
        var key, tempValue;
        for (var i = 0; i < 4; i++) {
            key = positionKies[i];
            if (key in this.baseStyle) {
                tempValue = this.$element.css(key);
                this.$element.css(key, "");
                this.$container.css(key, tempValue);
            }
        }
        this.$container.width(this.$element.outerWidth(true)).height(this.$element.outerHeight(true));
    };
})(jQuery);

window.MSSliderEvent = function(type) {
    this.type = type;
};

MSSliderEvent.CHANGE_START = "ms_changestart";

MSSliderEvent.CHANGE_END = "ms_changeend";

MSSliderEvent.WAITING = "ms_waiting";

MSSliderEvent.AUTOPLAY_CHANGE = "ms_autoplaychange";

MSSliderEvent.VIDEO_PLAY = "ms_videoPlay";

MSSliderEvent.VIDEO_CLOSE = "ms_videoclose";

MSSliderEvent.INIT = "ms_init";

MSSliderEvent.HARD_UPDATE = "ms_hard_update";

MSSliderEvent.RESIZE = "ms_resize";

MSSliderEvent.RESERVED_SPACE_CHANGE = "ms_rsc";

MSSliderEvent.DESTROY = "ms_destroy";

(function(window, document, $) {
    "use strict";
    window.MSSlide = function() {
        this.$element = null;
        this.$loading = $("<div></div>").addClass("ms-slide-loading");
        this.view = null;
        this.index = -1;
        this.__width = 0;
        this.__height = 0;
        this.fillMode = "fill";
        this.selected = false;
        this.pselected = false;
        this.autoAppend = true;
        this.isSleeping = true;
        this.moz = $.browser.mozilla;
    };
    var p = MSSlide.prototype;
    p.onSwipeStart = function() {
        if (this.link) {
            this.linkdis = true;
        }
        if (this.video) {
            this.videodis = true;
        }
    };
    p.onSwipeMove = function(e) {
        var move = Math.max(Math.abs(e.data.distanceX), Math.abs(e.data.distanceY));
        this.swipeMoved = move > 4;
    };
    p.onSwipeCancel = function(e) {
        if (this.swipeMoved) {
            this.swipeMoved = false;
            return;
        }
        if (this.link) {
            this.linkdis = false;
        }
        if (this.video) {
            this.videodis = false;
        }
    };
    p.setupLayerController = function() {
        this.hasLayers = true;
        this.layerController = new MSLayerController(this);
    };
    p.assetsLoaded = function() {
        this.ready = true;
        this.slider.api._startTimer();
        if (this.selected || this.pselected && this.slider.options.instantStartLayers) {
            if (this.hasLayers) {
                this.layerController.showLayers();
            }
            if (this.vinit) {
                this.bgvideo.play();
                if (!this.autoPauseBgVid) {
                    this.bgvideo.currentTime = 0;
                }
            }
        }
        if (!this.isSleeping) {
            this.setupBG();
        }
        CTween.fadeOut(this.$loading, 300, true);
        if ((this.slider.options.preload === 0 || this.slider.options.preload === "all") && this.index < this.view.slideList.length - 1) {
            this.view.slideList[this.index + 1].loadImages();
        } else if (this.slider.options.preload === "all" && this.index === this.view.slideList.length - 1) {
            this.slider._removeLoading();
        }
    };
    p.setBG = function(img) {
        this.hasBG = true;
        var that = this;
        this.$imgcont = $("<div></div>").addClass("ms-slide-bgcont");
        this.$element.append(this.$loading).append(this.$imgcont);
        this.$bg_img = $(img).css("visibility", "hidden");
        this.$imgcont.append(this.$bg_img);
        this.bgAligner = new MSAligner(that.fillMode, that.$imgcont, that.$bg_img);
        this.bgAligner.widthOnly = this.slider.options.autoHeight;
        if (that.slider.options.autoHeight && (that.pselected || that.selected)) {
            that.slider.setHeight(that.slider.options.height);
        }
        if (this.$bg_img.data("src") !== undefined) {
            this.bg_src = this.$bg_img.data("src");
            this.$bg_img.removeAttr("data-src");
        } else {
            this.$bg_img.one("load", function(event) {
                that._onBGLoad(event);
            }).each($.jqLoadFix);
        }
    };
    p.setupBG = function() {
        if (!this.initBG && this.bgLoaded) {
            this.initBG = true;
            this.$bg_img.css("visibility", "");
            this.bgWidth = this.bgNatrualWidth || this.$bg_img.width();
            this.bgHeight = this.bgNatrualHeight || this.$bg_img.height();
            CTween.fadeIn(this.$imgcont, 300);
            if (this.slider.options.autoHeight) {
                this.$imgcont.height(this.bgHeight * this.ratio);
            }
            this.bgAligner.init(this.bgWidth, this.bgHeight);
            this.setSize(this.__width, this.__height);
            if (this.slider.options.autoHeight && (this.pselected || this.selected)) this.slider.setHeight(this.getHeight());
        }
    };
    p.loadImages = function() {
        if (this.ls) {
            return;
        }
        this.ls = true;
        if (this.bgvideo) {
            this.bgvideo.load();
        }
        if (this.hasBG && this.bg_src) {
            var that = this;
            this.$bg_img.preloadImg(this.bg_src, function(event) {
                that._onBGLoad(event);
            });
        }
        if (this.hasLayers) {
            this.layerController.loadLayers(this._onLayersLoad);
        }
        if (!this.hasBG && !this.hasLayers) {
            this.assetsLoaded();
        }
    };
    p._onLayersLoad = function() {
        this.layersLoaded = true;
        if (!this.hasBG || this.bgLoaded) {
            this.assetsLoaded();
        }
    };
    p._onBGLoad = function(event) {
        this.bgNatrualWidth = event.width;
        this.bgNatrualHeight = event.height;
        this.bgLoaded = true;
        if ($.browser.msie) {
            this.$bg_img.on("dragstart", function(event) {
                event.preventDefault();
            });
        }
        if (!this.hasLayers || this.layerController.ready) {
            this.assetsLoaded();
        }
    };
    p.setBGVideo = function($video) {
        if (!$video[0].play) {
            return;
        }
        if (window._mobile) {
            $video.remove();
            return;
        }
        this.bgvideo = $video[0];
        var that = this;
        $video.addClass("ms-slide-bgvideo");
        if ($video.data("loop") !== false) {
            this.bgvideo.addEventListener("ended", function() {
                that.bgvideo.play();
            });
        }
        if ($video.data("mute") !== false) {
            this.bgvideo.muted = true;
        }
        if ($video.data("autopause") === true) {
            this.autoPauseBgVid = true;
        }
        this.bgvideo_fillmode = $video.data("fill-mode") || "fill";
        if (this.bgvideo_fillmode !== "none") {
            this.bgVideoAligner = new MSAligner(this.bgvideo_fillmode, this.$element, $video);
            this.bgvideo.addEventListener("loadedmetadata", function() {
                if (that.vinit) return;
                that.vinit = true;
                that.video_aspect = that.bgVideoAligner.baseHeight / that.bgVideoAligner.baseWidth;
                that.bgVideoAligner.init(that.bgvideo.videoWidth, that.bgvideo.videoHeight);
                that._alignBGVideo();
                CTween.fadeIn($(that.bgvideo), 200);
                if (that.selected) {
                    that.bgvideo.play();
                }
            });
        }
        $video.css("opacity", 0);
        this.$bgvideocont = $("<div></div>").addClass("ms-slide-bgvideocont").append($video);
        if (this.hasBG) {
            this.$imgcont.before(this.$bgvideocont);
        } else {
            this.$bgvideocont.appendTo(this.$element);
        }
    };
    p._alignBGVideo = function() {
        if (!this.bgvideo_fillmode || this.bgvideo_fillmode === "none") {
            return;
        }
        this.bgVideoAligner.align();
    };
    p.setSize = function(width, height, hard) {
        this.__width = width;
        if (this.slider.options.autoHeight) {
            if (this.bgLoaded) {
                this.ratio = this.__width / this.bgWidth;
                height = Math.floor(this.ratio * this.bgHeight);
                this.$imgcont.height(height);
            } else {
                this.ratio = width / this.slider.options.width;
                height = this.slider.options.height * this.ratio;
            }
        }
        this.__height = height;
        this.$element.width(width).height(height);
        if (this.hasBG && this.bgLoaded) this.bgAligner.align();
        this._alignBGVideo();
        if (this.hasLayers) {
            this.layerController.setSize(width, height, hard);
        }
    };
    p.getHeight = function() {
        if (this.hasBG && this.bgLoaded) {
            return this.bgHeight * this.ratio;
        }
        return Math.max(this.$element[0].clientHeight, this.slider.options.height * this.ratio);
    };
    p.__playVideo = function() {
        if (this.vplayed || this.videodis) {
            return;
        }
        this.vplayed = true;
        if (!this.slider.api.paused) {
            this.slider.api.pause();
            this.roc = true;
        }
        this.vcbtn.css("display", "");
        CTween.fadeOut(this.vpbtn, 500, false);
        CTween.fadeIn(this.vcbtn, 500);
        CTween.fadeIn(this.vframe, 500);
        this.vframe.css("display", "block").attr("src", this.video + "&autoplay=1");
        this.view.$element.addClass("ms-def-cursor");
        if (this.moz) {
            this.view.$element.css("perspective", "none");
        }
        if (this.view.swipeControl) {
            this.view.swipeControl.disable();
        }
        this.slider.slideController.dispatchEvent(new MSSliderEvent(MSSliderEvent.VIDEO_PLAY));
    };
    p.__closeVideo = function() {
        if (!this.vplayed) {
            return;
        }
        this.vplayed = false;
        if (this.roc) {
            this.slider.api.resume();
        }
        var that = this;
        CTween.fadeIn(this.vpbtn, 500);
        CTween.animate(this.vcbtn, 500, {
            opacity: 0
        }, {
            complete: function() {
                that.vcbtn.css("display", "none");
            }
        });
        CTween.animate(this.vframe, 500, {
            opacity: 0
        }, {
            complete: function() {
                that.vframe.attr("src", "about:blank").css("display", "none");
            }
        });
        if (this.moz) {
            this.view.$element.css("perspective", "");
        }
        if (this.view.swipeControl) {
            this.view.swipeControl.enable();
        }
        this.view.$element.removeClass("ms-def-cursor");
        this.slider.slideController.dispatchEvent(new MSSliderEvent(MSSliderEvent.VIDEO_CLOSE));
    };
    p.create = function() {
        var that = this;
        if (this.hasLayers) {
            this.layerController.create();
        }
        if (this.link) {
            this.link.addClass("ms-slide-link").html("").click(function(e) {
                if (that.linkdis) {
                    e.preventDefault();
                }
            });
        }
        if (this.video) {
            if (this.video.indexOf("?") === -1) {
                this.video += "?";
            }
            this.vframe = $("<iframe></iframe>").addClass("ms-slide-video").css({
                width: "100%",
                height: "100%",
                display: "none"
            }).attr("src", "about:blank").attr("allowfullscreen", "true").appendTo(this.$element);
            this.vpbtn = $("<div></div>").addClass("ms-slide-vpbtn").click(function() {
                that.__playVideo();
            }).appendTo(this.$element);
            this.vcbtn = $("<div></div>").addClass("ms-slide-vcbtn").click(function() {
                that.__closeVideo();
            }).appendTo(this.$element).css("display", "none");
            if (window._touch) {
                this.vcbtn.removeClass("ms-slide-vcbtn").addClass("ms-slide-vcbtn-mobile").append('<div class="ms-vcbtn-txt">Close video</div>').appendTo(this.view.$element.parent());
            }
        }
        if (!this.slider.options.autoHeight && this.hasBG) {
            this.$imgcont.css("height", "100%");
            if (this.fillMode === "center" || this.fillMode === "stretch") {
                this.fillMode = "fill";
            }
        }
        if (this.slider.options.autoHeight) {
            this.$element.addClass("ms-slide-auto-height");
        }
        this.sleep(true);
    };
    p.destroy = function() {
        if (this.hasLayers) {
            this.layerController.destroy();
            this.layerController = null;
        }
        this.$element.remove();
        this.$element = null;
    };
    p.prepareToSelect = function() {
        if (this.pselected || this.selected) {
            return;
        }
        this.pselected = true;
        if (this.link || this.video) {
            this.view.addEventListener(MSViewEvents.SWIPE_START, this.onSwipeStart, this);
            this.view.addEventListener(MSViewEvents.SWIPE_MOVE, this.onSwipeMove, this);
            this.view.addEventListener(MSViewEvents.SWIPE_CANCEL, this.onSwipeCancel, this);
            this.linkdis = false;
            this.swipeMoved = false;
        }
        this.loadImages();
        if (this.hasLayers) {
            this.layerController.prepareToShow();
        }
        if (this.ready) {
            if (this.bgvideo) {
                this.bgvideo.play();
            }
            if (this.hasLayers && this.slider.options.instantStartLayers) {
                this.layerController.showLayers();
            }
        }
        if (this.moz) {
            this.$element.css("margin-top", "");
        }
    };
    p.select = function() {
        if (this.selected) {
            return;
        }
        this.selected = true;
        this.pselected = false;
        this.$element.addClass("ms-sl-selected");
        if (this.hasLayers) {
            if (this.slider.options.autoHeight) {
                this.layerController.updateHeight();
            }
            if (!this.slider.options.instantStartLayers) {
                this.layerController.showLayers();
            }
        }
        if (this.ready && this.bgvideo) {
            this.bgvideo.play();
        }
        if (this.videoAutoPlay) {
            this.videodis = false;
            this.vpbtn.trigger("click");
        }
    };
    p.unselect = function() {
        this.pselected = false;
        if (this.moz) {
            this.$element.css("margin-top", "0.1px");
        }
        if (this.link || this.video) {
            this.view.removeEventListener(MSViewEvents.SWIPE_START, this.onSwipeStart, this);
            this.view.removeEventListener(MSViewEvents.SWIPE_MOVE, this.onSwipeMove, this);
            this.view.removeEventListener(MSViewEvents.SWIPE_CANCEL, this.onSwipeCancel, this);
        }
        if (this.bgvideo) {
            this.bgvideo.pause();
            if (!this.autoPauseBgVid && this.vinit) this.bgvideo.currentTime = 0;
        }
        if (this.hasLayers) {
            this.layerController.hideLayers();
        }
        if (!this.selected) {
            return;
        }
        this.selected = false;
        this.$element.removeClass("ms-sl-selected");
        if (this.video && this.vplayed) {
            this.__closeVideo();
            this.roc = false;
        }
    };
    p.sleep = function(force) {
        if (this.isSleeping && !force) {
            return;
        }
        this.isSleeping = true;
        if (this.autoAppend) {
            this.$element.detach();
        }
        if (this.hasLayers) {
            this.layerController.onSlideSleep();
        }
    };
    p.wakeup = function() {
        if (!this.isSleeping) {
            return;
        }
        this.isSleeping = false;
        if (this.autoAppend) {
            this.view.$slideCont.append(this.$element);
        }
        if (this.moz) {
            this.$element.css("margin-top", "0.1px");
        }
        this.setupBG();
        if (this.hasBG) {
            this.bgAligner.align();
        }
        if (this.hasLayers) {
            this.layerController.onSlideWakeup();
        }
    };
})(window, document, jQuery);

(function($) {
    "use strict";
    var SliderViewList = {};
    window.MSSlideController = function(slider) {
        this._delayProgress = 0;
        this._timer = new averta.Timer(100);
        this._timer.onTimer = this.onTimer;
        this._timer.refrence = this;
        this.currentSlide = null;
        this.slider = slider;
        this.so = slider.options;
        averta.EventDispatcher.call(this);
    };
    MSSlideController.registerView = function(name, _class) {
        if (name in SliderViewList) {
            throw new Error(name + ", is already registered.");
            return;
        }
        SliderViewList[name] = _class;
    };
    MSSlideController.SliderControlList = {};
    MSSlideController.registerControl = function(name, _class) {
        if (name in MSSlideController.SliderControlList) {
            throw new Error(name + ", is already registered.");
            return;
        }
        MSSlideController.SliderControlList[name] = _class;
    };
    var p = MSSlideController.prototype;
    p.setupView = function() {
        var that = this;
        this.resize_listener = function() {
            that.__resize();
        };
        var viewOptions = {
            spacing: this.so.space,
            mouseSwipe: this.so.mouse,
            loop: this.so.loop,
            autoHeight: this.so.autoHeight,
            swipe: this.so.swipe,
            speed: this.so.speed,
            dir: this.so.dir,
            viewNum: this.so.inView,
            critMargin: this.so.critMargin
        };
        if (this.so.viewOptions) $.extend(viewOptions, this.so.viewOptions);
        if (this.so.autoHeight) this.so.heightLimit = false;
        var viewClass = SliderViewList[this.slider.options.view] || MSBasicView;
        if (viewClass._3dreq && (!window._css3d || $.browser.msie)) viewClass = viewClass._fallback || MSBasicView;
        this.view = new viewClass(viewOptions);
        if (this.so.overPause) {
            var that = this;
            this.slider.$element.mouseenter(function() {
                that.is_over = true;
                that._stopTimer();
            }).mouseleave(function() {
                that.is_over = false;
                that._startTimer();
            });
        }
    };
    p.onChangeStart = function() {
        this.change_started = true;
        if (this.currentSlide) this.currentSlide.unselect();
        this.currentSlide = this.view.currentSlide;
        this.currentSlide.prepareToSelect();
        if (this.so.endPause && this.currentSlide.index === this.slider.slides.length - 1) {
            this.pause();
            this.skipTimer();
        }
        if (this.so.autoHeight) {
            this.slider.setHeight(this.currentSlide.getHeight());
        }
        if (this.so.deepLink) {
            this.__updateWindowHash();
        }
        this.dispatchEvent(new MSSliderEvent(MSSliderEvent.CHANGE_START));
    };
    p.onChangeEnd = function() {
        this.change_started = false;
        this._startTimer();
        this.currentSlide.select();
        if (this.so.preload > 1) {
            var loc, i, l = this.so.preload - 1, slide;
            for (i = 1; i <= l; ++i) {
                loc = this.view.index + i;
                if (loc >= this.view.slideList.length) {
                    if (this.so.loop) {
                        loc = loc - this.view.slideList.length;
                    } else {
                        i = l;
                        continue;
                    }
                }
                slide = this.view.slideList[loc];
                if (slide) {
                    slide.loadImages();
                }
            }
            if (l > this.view.slideList.length / 2) l = Math.floor(this.view.slideList.length / 2);
            for (i = 1; i <= l; ++i) {
                loc = this.view.index - i;
                if (loc < 0) {
                    if (this.so.loop) {
                        loc = this.view.slideList.length + loc;
                    } else {
                        i = l;
                        continue;
                    }
                }
                slide = this.view.slideList[loc];
                if (slide) {
                    slide.loadImages();
                }
            }
        }
        this.dispatchEvent(new MSSliderEvent(MSSliderEvent.CHANGE_END));
    };
    p.onSwipeStart = function() {
        this.skipTimer();
    };
    p.skipTimer = function() {
        this._timer.reset();
        this._delayProgress = 0;
        this.dispatchEvent(new MSSliderEvent(MSSliderEvent.WAITING));
    };
    p.onTimer = function(time) {
        if (this._timer.getTime() >= this.view.currentSlide.delay * 1e3) {
            this.skipTimer();
            this.view.next();
            this.hideCalled = false;
        }
        this._delayProgress = this._timer.getTime() / (this.view.currentSlide.delay * 10);
        if (this.so.hideLayers && !this.hideCalled && this.view.currentSlide.delay * 1e3 - this._timer.getTime() <= 300) {
            var currentSlide = this.view.currentSlide;
            if (currentSlide.hasLayers) {
                currentSlide.layerController.animHideLayers();
            }
            this.hideCalled = true;
        }
        this.dispatchEvent(new MSSliderEvent(MSSliderEvent.WAITING));
    };
    p._stopTimer = function() {
        if (this._timer) this._timer.stop();
    };
    p._startTimer = function() {
        if (!this.paused && !this.is_over && this.currentSlide && this.currentSlide.ready && !this.change_started) this._timer.start();
    };
    p.__appendSlides = function() {
        var slide, loc, i = 0, l = this.view.slideList.length - 1;
        for (i; i < l; ++i) {
            slide = this.view.slideList[i];
            if (!slide.detached) {
                slide.$element.detach();
                slide.detached = true;
            }
        }
        this.view.appendSlide(this.view.slideList[this.view.index]);
        l = 3;
        for (i = 1; i <= l; ++i) {
            loc = this.view.index + i;
            if (loc >= this.view.slideList.length) {
                if (this.so.loop) {
                    loc = loc - this.view.slideList.length;
                } else {
                    i = l;
                    continue;
                }
            }
            slide = this.view.slideList[loc];
            slide.detached = false;
            this.view.appendSlide(slide);
        }
        if (l > this.view.slideList.length / 2) l = Math.floor(this.view.slideList.length / 2);
        for (i = 1; i <= l; ++i) {
            loc = this.view.index - i;
            if (loc < 0) {
                if (this.so.loop) {
                    loc = this.view.slideList.length + loc;
                } else {
                    i = l;
                    continue;
                }
            }
            slide = this.view.slideList[loc];
            slide.detached = false;
            this.view.appendSlide(slide);
        }
    };
    p.__resize = function(hard) {
        if (!this.created) return;
        this.width = this.slider.$element[0].clientWidth || this.so.width;
        if (!this.so.fullwidth) {
            this.width = Math.min(this.width, this.so.width);
        }
        if (this.so.fullheight) {
            this.so.heightLimit = false;
            this.so.autoHeight = false;
            this.height = this.slider.$element[0].clientHeight;
        } else {
            this.height = this.width / this.slider.aspect;
        }
        if (this.so.autoHeight) {
            this.currentSlide.setSize(this.width, null, hard);
            this.view.setSize(this.width, this.currentSlide.getHeight(), hard);
        } else {
            this.view.setSize(this.width, Math.max(this.so.minHeight, this.so.heightLimit ? Math.min(this.height, this.so.height) : this.height), hard);
        }
        if (this.slider.$controlsCont) {
            if (this.so.centerControls && this.so.fullwidth) {
                this.view.$element.css("left", Math.min(0, -(this.slider.$element[0].clientWidth - this.so.width) / 2) + "px");
            }
        }
        this.dispatchEvent(new MSSliderEvent(MSSliderEvent.RESIZE));
    };
    p.__dispatchInit = function() {
        this.dispatchEvent(new MSSliderEvent(MSSliderEvent.INIT));
    };
    p.__updateWindowHash = function() {
        var hash = window.location.hash, dl = this.so.deepLink, dlt = this.so.deepLinkType, eq = dlt === "path" ? "/" : "=", sep = dlt === "path" ? "/" : "&", sliderHash = dl + eq + (this.view.index + 1), regTest = new RegExp(dl + eq + "[0-9]+", "g");
        if (hash === "") {
            window.location.hash = sep + sliderHash;
        } else if (regTest.test(hash)) {
            window.location.hash = hash.replace(regTest, sliderHash);
        } else {
            window.location.hash = hash + sep + sliderHash;
        }
    };
    p.__curentSlideInHash = function() {
        var hash = window.location.hash, dl = this.so.deepLink, dlt = this.so.deepLinkType, eq = dlt === "path" ? "/" : "=", regTest = new RegExp(dl + eq + "[0-9]+", "g");
        if (regTest.test(hash)) {
            var index = Number(hash.match(regTest)[0].match(/[0-9]+/g).pop());
            if (!isNaN(index)) {
                return index - 1;
            }
        }
        return -1;
    };
    p.__onHashChanged = function() {
        var index = this.__curentSlideInHash();
        if (index !== -1) {
            this.gotoSlide(index);
        }
    };
    p.setup = function() {
        this.created = true;
        this.paused = !this.so.autoplay;
        this.view.addEventListener(MSViewEvents.CHANGE_START, this.onChangeStart, this);
        this.view.addEventListener(MSViewEvents.CHANGE_END, this.onChangeEnd, this);
        this.view.addEventListener(MSViewEvents.SWIPE_START, this.onSwipeStart, this);
        this.currentSlide = this.view.slideList[this.so.start - 1];
        this.__resize();
        var slideInHash = this.__curentSlideInHash(), startSlide = slideInHash !== -1 ? slideInHash : this.so.start - 1;
        this.view.create(startSlide);
        if (this.so.preload === 0) {
            this.view.slideList[0].loadImages();
        }
        this.scroller = this.view.controller;
        if (this.so.wheel) {
            var that = this;
            var last_time = new Date().getTime();
            this.wheellistener = function(event) {
                var e = window.event || event.orginalEvent || event;
                e.preventDefault();
                var current_time = new Date().getTime();
                if (current_time - last_time < 400) return;
                last_time = current_time;
                var delta = Math.abs(e.detail || e.wheelDelta);
                if ($.browser.mozilla) {
                    delta *= 100;
                }
                var scrollThreshold = 15;
                if (e.detail < 0 || e.wheelDelta > 0) {
                    if (delta >= scrollThreshold) {
                        that.previous(true);
                    }
                } else {
                    if (delta >= scrollThreshold) {
                        that.next(true);
                    }
                }
                return false;
            };
            if ($.browser.mozilla) this.slider.$element[0].addEventListener("DOMMouseScroll", this.wheellistener); else this.slider.$element.bind("mousewheel", this.wheellistener);
        }
        if (this.slider.$element[0].clientWidth === 0) this.slider.init_safemode = true;
        this.__resize();
        var that = this;
        if (this.so.deepLink) {
            $(window).on("hashchange", function() {
                that.__onHashChanged();
            });
        }
    };
    p.index = function() {
        return this.view.index;
    };
    p.count = function() {
        return this.view.slidesCount;
    };
    p.next = function(checkLoop) {
        this.skipTimer();
        this.view.next(checkLoop);
    };
    p.previous = function(checkLoop) {
        this.skipTimer();
        this.view.previous(checkLoop);
    };
    p.gotoSlide = function(index) {
        index = Math.min(index, this.count() - 1);
        this.skipTimer();
        this.view.gotoSlide(index);
    };
    p.destroy = function(reset) {
        this.dispatchEvent(new MSSliderEvent(MSSliderEvent.DESTROY));
        this.slider.destroy(reset);
    };
    p._destroy = function() {
        this._timer.reset();
        this._timer = null;
        $(window).unbind("resize", this.resize_listener);
        this.view.destroy();
        this.view = null;
        if (this.so.wheel) {
            if ($.browser.mozilla) this.slider.$element[0].removeEventListener("DOMMouseScroll", this.wheellistener); else this.slider.$element.unbind("mousewheel", this.wheellistener);
            this.wheellistener = null;
        }
        this.so = null;
    };
    p.runAction = function(action) {
        var actionParams = [];
        if (action.indexOf("(") !== -1) {
            var temp = action.slice(0, action.indexOf("("));
            actionParams = action.slice(action.indexOf("(") + 1, -1).replace(/\"|\'|\s/g, "").split(",");
            action = temp;
        }
        if (action in this) {
            this[action].apply(this, actionParams);
        } else if (console) {
            console.log('Master Slider Error: Action "' + action + '" not found.');
        }
    };
    p.update = function(hard) {
        if (this.slider.init_safemode && hard) this.slider.init_safemode = false;
        this.__resize(hard);
        if (hard) {
            this.dispatchEvent(new MSSliderEvent(MSSliderEvent.HARD_UPDATE));
        }
    };
    p.locate = function() {
        this.__resize();
    };
    p.resume = function() {
        if (!this.paused) return;
        this.paused = false;
        this._startTimer();
    };
    p.pause = function() {
        if (this.paused) return;
        this.paused = true;
        this._stopTimer();
    };
    p.currentTime = function() {
        return this._delayProgress;
    };
    averta.EventDispatcher.extend(p);
})(jQuery);

(function($) {
    "use strict";
    var LayerTypes = {
        image: MSImageLayerElement,
        text: MSLayerElement,
        video: MSVideoLayerElement,
        hotspot: MSHotspotLayer,
        button: MSButtonLayer
    };
    window.MasterSlider = function() {
        this.options = {
            autoplay: false,
            loop: false,
            mouse: true,
            swipe: true,
            grabCursor: true,
            space: 0,
            fillMode: "fill",
            start: 1,
            view: "basic",
            width: 300,
            height: 150,
            inView: 15,
            critMargin: 1,
            heightLimit: true,
            smoothHeight: true,
            autoHeight: false,
            minHeight: -1,
            fullwidth: false,
            fullheight: false,
            autofill: false,
            layersMode: "center",
            hideLayers: false,
            endPause: false,
            centerControls: true,
            overPause: true,
            shuffle: false,
            speed: 17,
            dir: "h",
            preload: 0,
            wheel: false,
            layout: "boxed",
            autofillTarget: null,
            fullscreenMargin: 0,
            instantStartLayers: false,
            parallaxMode: "mouse",
            rtl: false,
            deepLink: null,
            deepLinkType: "path",
            disablePlugins: []
        };
        this.slides = [];
        this.activePlugins = [];
        this.$element = null;
        this.lastMargin = 0;
        this.leftSpace = 0;
        this.topSpace = 0;
        this.rightSpace = 0;
        this.bottomSpace = 0;
        this._holdOn = 0;
        var that = this;
        this.resize_listener = function() {
            that._resize();
        };
        $(window).bind("resize", this.resize_listener);
    };
    MasterSlider.author = "Averta Ltd. (www.averta.net)";
    MasterSlider.version = "2.15.1";
    MasterSlider.releaseDate = "Jul 2015";
    MasterSlider._plugins = [];
    var MS = MasterSlider;
    MS.registerPlugin = function(plugin) {
        if (MS._plugins.indexOf(plugin) === -1) {
            MS._plugins.push(plugin);
        }
    };
    var p = MasterSlider.prototype;
    p.__setupSlides = function() {
        var that = this, new_slide, ind = 0;
        this.$element.children(".ms-slide").each(function(index) {
            var $slide_ele = $(this);
            new_slide = new MSSlide();
            new_slide.$element = $slide_ele;
            new_slide.slider = that;
            new_slide.delay = $slide_ele.data("delay") !== undefined ? $slide_ele.data("delay") : 3;
            new_slide.fillMode = $slide_ele.data("fill-mode") !== undefined ? $slide_ele.data("fill-mode") : that.options.fillMode;
            new_slide.index = ind++;
            var slide_img = $slide_ele.children("img:not(.ms-layer)");
            if (slide_img.length > 0) {
                new_slide.setBG(slide_img[0]);
            }
            var slide_video = $slide_ele.children("video");
            if (slide_video.length > 0) new_slide.setBGVideo(slide_video);
            if (that.controls) {
                for (var i = 0, l = that.controls.length; i < l; ++i) that.controls[i].slideAction(new_slide);
            }
            var slide_link = $slide_ele.children("a").each(function(index) {
                var $this = $(this);
                if (this.getAttribute("data-type") === "video") {
                    new_slide.video = this.getAttribute("href");
                    new_slide.videoAutoPlay = $this.data("autoplay");
                    $this.remove();
                } else if (!$this.hasClass("ms-layer")) {
                    new_slide.link = $(this);
                }
            });
            that.__createSlideLayers(new_slide, $slide_ele.find(".ms-layer"));
            that.slides.push(new_slide);
            that.slideController.view.addSlide(new_slide);
        });
    };
    p.__createSlideLayers = function(slide, layers) {
        if (layers.length == 0) return;
        slide.setupLayerController();
        layers.each(function(index, domEle) {
            var $layer_element = $(this), $parent_ele;
            if (domEle.nodeName === "A" && $layer_element.find(">img").data("type") === "image") {
                $parent_ele = $(this);
                $layer_element = $parent_ele.find("img");
            }
            var layer = new (LayerTypes[$layer_element.data("type") || "text"])();
            layer.$element = $layer_element;
            layer.link = $parent_ele;
            var eff_parameters = {}, end_eff_parameters = {};
            if ($layer_element.data("effect") !== undefined) eff_parameters.name = $layer_element.data("effect");
            if ($layer_element.data("ease") !== undefined) eff_parameters.ease = $layer_element.data("ease");
            if ($layer_element.data("duration") !== undefined) eff_parameters.duration = $layer_element.data("duration");
            if ($layer_element.data("delay") !== undefined) eff_parameters.delay = $layer_element.data("delay");
            if ($layer_element.data("hide-effect")) end_eff_parameters.name = $layer_element.data("hide-effect");
            if ($layer_element.data("hide-ease")) end_eff_parameters.ease = $layer_element.data("hide-ease");
            if ($layer_element.data("hide-duration") !== undefined) end_eff_parameters.duration = $layer_element.data("hide-duration");
            if ($layer_element.data("hide-time") !== undefined) end_eff_parameters.time = $layer_element.data("hide-time");
            layer.setStartAnim(eff_parameters);
            layer.setEndAnim(end_eff_parameters);
            slide.layerController.addLayer(layer);
        });
    };
    p._removeLoading = function() {
        $(window).unbind("resize", this.resize_listener);
        this.$element.removeClass("before-init").css("visibility", "visible").css("height", "").css("opacity", 0);
        CTween.fadeIn(this.$element);
        this.$loading.remove();
        if (this.slideController) this.slideController.__resize();
    };
    p._resize = function(e) {
        if (this.$loading) {
            var h = this.$loading[0].clientWidth / this.aspect;
            h = this.options.heightLimit ? Math.min(h, this.options.height) : h;
            this.$loading.height(h);
            this.$element.height(h);
        }
    };
    p._shuffleSlides = function() {
        var slides = this.$element.children(".ms-slide"), r;
        for (var i = 0, l = slides.length; i < l; ++i) {
            r = Math.floor(Math.random() * (l - 1));
            if (i != r) {
                this.$element[0].insertBefore(slides[i], slides[r]);
                slides = this.$element.children(".ms-slide");
            }
        }
    };
    p._setupSliderLayout = function() {
        this._updateSideMargins();
        this.lastMargin = this.leftSpace;
        var lo = this.options.layout;
        if (lo !== "boxed" && lo !== "partialview") {
            this.options.fullwidth = true;
        }
        if (lo === "fullscreen" || lo === "autofill") {
            this.options.fullheight = true;
            if (lo === "autofill") {
                this.$autofillTarget = $(this.options.autofillTarget);
                if (this.$autofillTarget.length === 0) {
                    this.$autofillTarget = this.$element.parent();
                }
            }
        }
        if (lo === "partialview") {
            this.$element.addClass("ms-layout-partialview");
        }
        if (lo === "fullscreen" || lo === "fullwidth" || lo === "autofill") {
            $(window).bind("resize", {
                that: this
            }, this._updateLayout);
            this._updateLayout();
        }
        $(window).bind("resize", this.slideController.resize_listener);
    };
    p._updateLayout = function(event) {
        var that = event ? event.data.that : this, lo = that.options.layout, $element = that.$element, $win = $(window);
        if (lo === "fullscreen") {
            document.body.style.overflow = "hidden";
            $element.height($win.height() - that.options.fullscreenMargin - that.topSpace - that.bottomSpace);
            document.body.style.overflow = "";
        } else if (lo === "autofill") {
            $element.height(that.$autofillTarget.height() - that.options.fullscreenMargin - that.topSpace - that.bottomSpace).width(that.$autofillTarget.width() - that.leftSpace - that.rightSpace);
            return;
        }
        $element.width($win.width() - that.leftSpace - that.rightSpace);
        var margin = -$element.offset().left + that.leftSpace + that.lastMargin;
        $element.css("margin-left", margin);
        that.lastMargin = margin;
    };
    p._init = function() {
        if (this._holdOn > 0 || !this._docReady) {
            return;
        }
        this.initialized = true;
        if (this.options.preload !== "all") {
            this._removeLoading();
        }
        if (this.options.shuffle) this._shuffleSlides();
        MSLayerEffects.setup();
        this.slideController.setupView();
        this.view = this.slideController.view;
        this.$controlsCont = $("<div></div>").addClass("ms-inner-controls-cont");
        if (this.options.centerControls) {
            this.$controlsCont.css("max-width", this.options.width + "px");
        }
        this.$controlsCont.prepend(this.view.$element);
        this.$msContainer = $("<div></div>").addClass("ms-container").prependTo(this.$element).append(this.$controlsCont);
        if (this.controls) {
            for (var i = 0, l = this.controls.length; i < l; ++i) {
                this.controls[i].setup();
            }
        }
        this._setupSliderLayout();
        this.__setupSlides();
        this.slideController.setup();
        if (this.controls) {
            for (i = 0, l = this.controls.length; i < l; ++i) this.controls[i].create();
        }
        if (this.options.autoHeight) {
            this.slideController.view.$element.height(this.slideController.currentSlide.getHeight());
        }
        if (this.options.swipe && !window._touch && this.options.grabCursor && this.options.mouse) {
            var $view = this.view.$element;
            $view.mousedown(function() {
                $view.removeClass("ms-grab-cursor");
                $view.addClass("ms-grabbing-cursor");
                if ($.browser.msie && window.ms_grabbing_curosr) {
                    $view[0].style.cursor = "url(" + window.ms_grabbing_curosr + "), move";
                }
            }).addClass("ms-grab-cursor");
            $(document).mouseup(function() {
                $view.removeClass("ms-grabbing-cursor");
                $view.addClass("ms-grab-cursor");
                if ($.browser.msie && window.ms_grab_curosr) {
                    $view[0].style.cursor = "url(" + window.ms_grab_curosr + "), move";
                }
            });
        }
        this.slideController.__dispatchInit();
    };
    p.setHeight = function(value) {
        if (this.options.smoothHeight) {
            if (this.htween) {
                if (this.htween.reset) this.htween.reset(); else this.htween.stop(true);
            }
            this.htween = CTween.animate(this.slideController.view.$element, 500, {
                height: value
            }, {
                ease: "easeOutQuart"
            });
        } else this.slideController.view.$element.height(value);
    };
    p.reserveSpace = function(side, space) {
        var sideSpace = side + "Space", pos = this[sideSpace];
        this[sideSpace] += space;
        this._updateSideMargins();
        return pos;
    };
    p._updateSideMargins = function() {
        this.$element.css("margin", this.topSpace + "px " + this.rightSpace + "px " + this.bottomSpace + "px " + this.leftSpace + "px");
    };
    p._realignControls = function() {
        this.rightSpace = this.leftSpace = this.topSpace = this.bottomSpace = 0;
        this._updateSideMargins();
        this.api.dispatchEvent(new MSSliderEvent(MSSliderEvent.RESERVED_SPACE_CHANGE));
    };
    p.control = function(control, options) {
        if (!(control in MSSlideController.SliderControlList)) return;
        if (!this.controls) this.controls = [];
        var ins = new MSSlideController.SliderControlList[control](options);
        ins.slider = this;
        this.controls.push(ins);
        return this;
    };
    p.holdOn = function() {
        this._holdOn++;
    };
    p.release = function() {
        this._holdOn--;
        this._init();
    };
    p.setup = function(target, options) {
        if (typeof target === "string") {
            this.$element = $("#" + target);
        } else {
            this.$element = target.eq(0);
        }
        this.setupMarkup = this.$element.html();
        if (this.$element.length === 0) {
            return;
        }
        this.$element.addClass("master-slider").addClass("before-init");
        if ($.browser.msie) {
            this.$element.addClass("ms-ie").addClass("ms-ie" + $.browser.version.slice(0, $.browser.version.indexOf(".")));
        } else if ($.browser.webkit) {
            this.$element.addClass("ms-wk");
        } else if ($.browser.mozilla) {
            this.$element.addClass("ms-moz");
        }
        var ua = navigator.userAgent.toLowerCase();
        var isAndroid = ua.indexOf("android") > -1;
        if (isAndroid) {
            this.$element.addClass("ms-android");
        }
        var that = this;
        $.extend(this.options, options);
        this.aspect = this.options.width / this.options.height;
        this.$loading = $("<div></div>").addClass("ms-loading-container").insertBefore(this.$element).append($("<div></div>").addClass("ms-loading"));
        this.$loading.parent().css("position", "relative");
        if (this.options.autofill) {
            this.options.fullwidth = true;
            this.options.fullheight = true;
        }
        if (this.options.fullheight) {
            this.$element.addClass("ms-fullheight");
        }
        this._resize();
        this.slideController = new MSSlideController(this);
        this.api = this.slideController;
        for (var i = 0, l = MS._plugins.length; i !== l; i++) {
            var plugin = MS._plugins[i];
            if (this.options.disablePlugins.indexOf(plugin.name) === -1) {
                this.activePlugins.push(new plugin(this));
            }
        }
        $(document).ready(function() {
            that._docReady = true;
            that._init();
        });
        return this;
    };
    p.destroy = function(insertMarkup) {
        for (var i = 0, l = this.activePlugins.length; i !== l; i++) {
            this.activePlugins[i].destroy();
        }
        if (this.controls) {
            for (i = 0, l = this.controls.length; i !== l; i++) this.controls[i].destroy();
        }
        if (this.slideController) this.slideController._destroy();
        if (this.$loading) this.$loading.remove();
        if (insertMarkup) {
            this.$element.html(this.setupMarkup).css("visibility", "hidden");
        } else {
            this.$element.remove();
        }
        var lo = this.options.layout;
        if (lo === "fullscreen" || lo === "fullwidth") {
            $(window).unbind("resize", this._updateLayout);
        }
        this.view = null;
        this.slides = null;
        this.options = null;
        this.slideController = null;
        this.api = null;
        this.resize_listener = null;
        this.activePlugins = null;
    };
})(jQuery);

(function($, window, document, undefined) {
    var pluginName = "masterslider", defaults = {
        controls: {}
    };
    function MasterSliderPlugin(element, options) {
        this.element = element;
        this.$element = $(element);
        this.settings = $.extend({}, defaults, options);
        this._defaults = defaults;
        this._name = pluginName;
        this.init();
    }
    $.extend(MasterSliderPlugin.prototype, {
        init: function() {
            var self = this;
            this._slider = new MasterSlider();
            for (var control in this.settings.controls) {
                this._slider.control(control, this.settings.controls[control]);
            }
            this._slider.setup(this.$element, this.settings);
            var _superDispatch = this._slider.api.dispatchEvent;
            this._slider.api.dispatchEvent = function(event) {
                self.$element.trigger(event.type);
                _superDispatch.call(this, event);
            };
        },
        api: function() {
            return this._slider.api;
        },
        slider: function() {
            return this._slider;
        }
    });
    $.fn[pluginName] = function(options) {
        var args = arguments, plugin = "plugin_" + pluginName;
        if (options === undefined || typeof options === "object") {
            return this.each(function() {
                if (!$.data(this, plugin)) {
                    $.data(this, plugin, new MasterSliderPlugin(this, options));
                }
            });
        } else if (typeof options === "string" && options[0] !== "_" && options !== "init") {
            var returns;
            this.each(function() {
                var instance = $.data(this, plugin);
                if (instance instanceof MasterSliderPlugin && typeof instance[options] === "function") {
                    returns = instance[options].apply(instance, Array.prototype.slice.call(args, 1));
                }
                if (instance instanceof MasterSliderPlugin && typeof instance._slider.api[options] === "function") {
                    returns = instance._slider.api[options].apply(instance._slider.api, Array.prototype.slice.call(args, 1));
                }
                if (options === "destroy") {
                    $.data(this, plugin, null);
                }
            });
            return returns !== undefined ? returns : this;
        }
    };
})(jQuery, window, document);

window.MSViewEvents = function(type, data) {
    this.type = type;
    this.data = data;
};

MSViewEvents.SWIPE_START = "swipeStart";

MSViewEvents.SWIPE_END = "swipeEnd";

MSViewEvents.SWIPE_MOVE = "swipeMove";

MSViewEvents.SWIPE_CANCEL = "swipeCancel";

MSViewEvents.SCROLL = "scroll";

MSViewEvents.CHANGE_START = "slideChangeStart";

MSViewEvents.CHANGE_END = "slideChangeEnd";

(function($) {
    "use strict";
    window.MSBasicView = function(options) {
        this.options = {
            loop: false,
            dir: "h",
            autoHeight: false,
            spacing: 5,
            mouseSwipe: true,
            swipe: true,
            speed: 17,
            minSlideSpeed: 2,
            viewNum: 20,
            critMargin: 1
        };
        $.extend(this.options, options);
        this.dir = this.options.dir;
        this.loop = this.options.loop;
        this.spacing = this.options.spacing;
        this.__width = 0;
        this.__height = 0;
        this.__cssProb = this.dir === "h" ? "left" : "top";
        this.__offset = this.dir === "h" ? "offsetLeft" : "offsetTop";
        this.__dimension = this.dir === "h" ? "__width" : "__height";
        this.__translate_end = window._css3d ? " translateZ(0px)" : "";
        this.$slideCont = $("<div></div>").addClass("ms-slide-container");
        this.$element = $("<div></div>").addClass("ms-view").addClass("ms-basic-view").append(this.$slideCont);
        this.currentSlide = null;
        this.index = -1;
        this.slidesCount = 0;
        this.slides = [];
        this.slideList = [];
        this.viewSlidesList = [];
        this.css3 = window._cssanim;
        this.start_buffer = 0;
        this.firstslide_snap = 0;
        this.slideChanged = false;
        this.controller = new Controller(0, 0, {
            snapping: true,
            snapsize: 100,
            paging: true,
            snappingMinSpeed: this.options.minSlideSpeed,
            friction: (100 - this.options.speed * .5) / 100,
            endless: this.loop
        });
        this.controller.renderCallback(this.dir === "h" ? this._horizUpdate : this._vertiUpdate, this);
        this.controller.snappingCallback(this.__snapUpdate, this);
        this.controller.snapCompleteCallback(this.__snapCompelet, this);
        averta.EventDispatcher.call(this);
    };
    var p = MSBasicView.prototype;
    p.__snapCompelet = function(snap, type) {
        if (!this.slideChanged) {
            return;
        }
        this.slideChanged = false;
        this.__locateSlides();
        this.start_buffer = 0;
        this.dispatchEvent(new MSViewEvents(MSViewEvents.CHANGE_END));
    };
    p.__snapUpdate = function(controller, snap, change) {
        if (this.loop) {
            var target_index = this.index + change;
            this.updateLoop(target_index);
            if (target_index >= this.slidesCount) target_index = target_index - this.slidesCount;
            if (target_index < 0) target_index = this.slidesCount + target_index;
            this.index = target_index;
        } else {
            if (snap < 0 || snap >= this.slidesCount) return;
            this.index = snap;
        }
        this._checkCritMargins();
        if ($.browser.mozilla) {
            this.slideList[this.index].$element[0].style.marginTop = "0.1px";
            if (this.currentSlide) {
                this.currentSlide.$element[0].style.marginTop = "";
            }
        }
        var new_slide = this.slideList[this.index];
        if (new_slide === this.currentSlide) return;
        this.currentSlide = new_slide;
        if (this.autoUpdateZIndex) {
            this.__updateSlidesZindex();
        }
        this.slideChanged = true;
        this.dispatchEvent(new MSViewEvents(MSViewEvents.CHANGE_START));
    };
    p._checkCritMargins = function() {
        if (this.normalMode) return;
        var hlf = Math.floor(this.options.viewNum / 2), inView = this.viewSlidesList.indexOf(this.slideList[this.index]), size = this[this.__dimension] + this.spacing, cm = this.options.critMargin;
        if (this.loop) {
            if (inView <= cm || inView >= this.viewSlidesList.length - cm) {
                size *= inView - hlf;
                this.__locateSlides(false, size + this.start_buffer);
                this.start_buffer += size;
            }
            return;
        }
        if (inView < cm && this.index >= cm || inView >= this.viewSlidesList.length - cm && this.index < this.slidesCount - cm) {
            this.__locateSlides(false);
        }
    };
    p._vertiUpdate = function(controller, value) {
        this.__contPos = value;
        this.dispatchEvent(new MSViewEvents(MSViewEvents.SCROLL));
        if (this.css3) {
            this.$slideCont[0].style[window._jcsspfx + "Transform"] = "translateY(" + -value + "px)" + this.__translate_end;
            return;
        }
        this.$slideCont[0].style.top = -value + "px";
    };
    p._horizUpdate = function(controller, value) {
        this.__contPos = value;
        this.dispatchEvent(new MSViewEvents(MSViewEvents.SCROLL));
        if (this.css3) {
            this.$slideCont[0].style[window._jcsspfx + "Transform"] = "translateX(" + -value + "px)" + this.__translate_end;
            return;
        }
        this.$slideCont[0].style.left = -value + "px";
    };
    p.__updateViewList = function() {
        if (this.normalMode) {
            this.viewSlidesList = this.slides;
            return;
        }
        var temp = this.viewSlidesList.slice();
        this.viewSlidesList = [];
        var i = 0, hlf = Math.floor(this.options.viewNum / 2), l;
        if (this.loop) {
            for (;i !== this.options.viewNum; i++) this.viewSlidesList.push(this.slides[this.currentSlideLoc - hlf + i]);
        } else {
            for (i = 0; i !== hlf && this.index - i !== -1; i++) this.viewSlidesList.unshift(this.slideList[this.index - i]);
            for (i = 1; i !== hlf && this.index + i !== this.slidesCount; i++) this.viewSlidesList.push(this.slideList[this.index + i]);
        }
        for (i = 0, l = temp.length; i !== l; i++) if (this.viewSlidesList.indexOf(temp[i]) === -1) temp[i].sleep();
        temp = null;
        if (this.currentSlide) {
            this.__updateSlidesZindex();
        }
    };
    p.__locateSlides = function(move, start) {
        this.__updateViewList();
        start = !this.loop ? this.slides.indexOf(this.viewSlidesList[0]) * (this[this.__dimension] + this.spacing) : start || 0;
        var l = this.viewSlidesList.length, slide;
        for (var i = 0; i !== l; i++) {
            var pos = start + i * (this[this.__dimension] + this.spacing);
            slide = this.viewSlidesList[i];
            slide.wakeup();
            slide.position = pos;
            slide.$element[0].style[this.__cssProb] = pos + "px";
        }
        if (move !== false) this.controller.changeTo(this.slideList[this.index].position, false, null, null, false);
    };
    p.__createLoopList = function() {
        var return_arr = [];
        var i = 0, count = this.slidesCount / 2;
        var before_count = this.slidesCount % 2 === 0 ? count - 1 : Math.floor(count);
        var after_count = this.slidesCount % 2 === 0 ? count : Math.floor(count);
        this.currentSlideLoc = before_count;
        for (i = 1; i <= before_count; ++i) return_arr.unshift(this.slideList[this.index - i < 0 ? this.slidesCount - i + this.index : this.index - i]);
        return_arr.push(this.slideList[this.index]);
        for (i = 1; i <= after_count; ++i) return_arr.push(this.slideList[this.index + i >= this.slidesCount ? this.index + i - this.slidesCount : this.index + i]);
        return return_arr;
    };
    p.__getSteps = function(index, target) {
        var right = target < index ? this.slidesCount - index + target : target - index;
        var left = Math.abs(this.slidesCount - right);
        return right < left ? right : -left;
    };
    p.__pushEnd = function() {
        var first_slide = this.slides.shift();
        var last_slide = this.slides[this.slidesCount - 2];
        this.slides.push(first_slide);
        if (!this.normalMode) return;
        var pos = last_slide.$element[0][this.__offset] + this.spacing + this[this.__dimension];
        first_slide.$element[0].style[this.__cssProb] = pos + "px";
        first_slide.position = pos;
    };
    p.__pushStart = function() {
        var last_slide = this.slides.pop();
        var first_slide = this.slides[0];
        this.slides.unshift(last_slide);
        if (!this.normalMode) return;
        var pos = first_slide.$element[0][this.__offset] - this.spacing - this[this.__dimension];
        last_slide.$element[0].style[this.__cssProb] = pos + "px";
        last_slide.position = pos;
    };
    p.__updateSlidesZindex = function() {
        var slide, l = this.viewSlidesList.length, hlf = Math.floor(l / 2);
        if (this.loop) {
            var loc = this.viewSlidesList.indexOf(this.currentSlide);
            for (var i = 0; i !== l; i++) {
                slide = this.viewSlidesList[i];
                this.viewSlidesList[i].$element.css("z-index", i <= loc ? i + 1 : l - i);
            }
        } else {
            var beforeNum = this.currentSlide.index - this.viewSlidesList[0].index, afterNum = l - beforeNum, diff = beforeNum - afterNum;
            for (var i = 0; i !== l; i++) {
                this.viewSlidesList[i].$element.css("z-index", i <= beforeNum ? i + 1 : l - i);
            }
            this.currentSlide.$element.css("z-index", l);
        }
    };
    p.addSlide = function(slide) {
        slide.view = this;
        this.slides.push(slide);
        this.slideList.push(slide);
        this.slidesCount++;
    };
    p.appendSlide = function(slide) {
        this.$slideCont.append(slide.$element);
    };
    p.updateLoop = function(index) {
        if (this.loop) {
            var steps = this.__getSteps(this.index, index);
            for (var i = 0, l = Math.abs(steps); i < l; ++i) {
                if (steps < 0) this.__pushStart(); else this.__pushEnd();
            }
        }
    };
    p.gotoSlide = function(index, fast) {
        this.updateLoop(index);
        this.index = index;
        var target_slide = this.slideList[index];
        this._checkCritMargins();
        this.controller.changeTo(target_slide.position, !fast, null, null, false);
        if (target_slide === this.currentSlide) return;
        this.slideChanged = true;
        this.currentSlide = target_slide;
        if (this.autoUpdateZIndex) {
            this.__updateSlidesZindex();
        }
        this.dispatchEvent(new MSViewEvents(MSViewEvents.CHANGE_START));
        if (fast) this.dispatchEvent(new MSViewEvents(MSViewEvents.CHANGE_END));
    };
    p.next = function(checkLoop) {
        if (checkLoop && !this.loop && this.index + 1 >= this.slidesCount) {
            this.controller.bounce(10);
            return;
        }
        this.gotoSlide(this.index + 1 >= this.slidesCount ? 0 : this.index + 1);
    };
    p.previous = function(checkLoop) {
        if (checkLoop && !this.loop && this.index - 1 < 0) {
            this.controller.bounce(-10);
            return;
        }
        this.gotoSlide(this.index - 1 < 0 ? this.slidesCount - 1 : this.index - 1);
    };
    p.setupSwipe = function() {
        this.swipeControl = new averta.TouchSwipe(this.$element);
        this.swipeControl.swipeType = this.dir === "h" ? "horizontal" : "vertical";
        var that = this;
        if (this.dir === "h") {
            this.swipeControl.onSwipe = function(status) {
                that.horizSwipeMove(status);
            };
        } else {
            this.swipeControl.onSwipe = function(status) {
                that.vertSwipeMove(status);
            };
        }
    };
    p.vertSwipeMove = function(status) {
        var phase = status.phase;
        if (phase === "start") {
            this.controller.stop();
            this.dispatchEvent(new MSViewEvents(MSViewEvents.SWIPE_START, status));
        } else if (phase === "move" && (!this.loop || Math.abs(this.currentSlide.position - this.controller.value + status.moveY) < this.cont_size / 2)) {
            this.controller.drag(status.moveY);
            this.dispatchEvent(new MSViewEvents(MSViewEvents.SWIPE_MOVE, status));
        } else if (phase === "end" || phase === "cancel") {
            var speed = status.distanceY / status.duration * 50 / 3;
            if (Math.abs(speed) > .1) {
                this.controller.push(-speed);
                if (speed > this.controller.options.snappingMinSpeed) this.dispatchEvent(new MSViewEvents(MSViewEvents.SWIPE_END, status));
            } else {
                this.controller.cancel();
                this.dispatchEvent(new MSViewEvents(MSViewEvents.SWIPE_CANCEL, status));
            }
        }
    };
    p.horizSwipeMove = function(status) {
        var phase = status.phase;
        if (phase === "start") {
            this.controller.stop();
            this.dispatchEvent(new MSViewEvents(MSViewEvents.SWIPE_START, status));
        } else if (phase === "move" && (!this.loop || Math.abs(this.currentSlide.position - this.controller.value + status.moveX) < this.cont_size / 2)) {
            this.controller.drag(status.moveX);
            this.dispatchEvent(new MSViewEvents(MSViewEvents.SWIPE_MOVE, status));
        } else if (phase === "end" || phase === "cancel") {
            var speed = status.distanceX / status.duration * 50 / 3;
            if (Math.abs(speed) > .1) {
                this.controller.push(-speed);
                if (speed > this.controller.options.snappingMinSpeed) this.dispatchEvent(new MSViewEvents(MSViewEvents.SWIPE_END, status));
            } else {
                this.controller.cancel();
                this.dispatchEvent(new MSViewEvents(MSViewEvents.SWIPE_CANCEL, status));
            }
        }
    };
    p.setSize = function(width, height, hard) {
        if (this.lastWidth === width && height === this.lastHeight && !hard) return;
        this.$element.width(width).height(height);
        for (var i = 0; i < this.slidesCount; ++i) this.slides[i].setSize(width, height, hard);
        this.__width = width;
        this.__height = height;
        if (this.__created) {
            this.__locateSlides();
            this.cont_size = (this.slidesCount - 1) * (this[this.__dimension] + this.spacing);
            if (!this.loop) this.controller._max_value = this.cont_size;
            this.controller.options.snapsize = this[this.__dimension] + this.spacing;
            this.controller.changeTo(this.currentSlide.position, false, null, null, false);
            this.controller.cancel();
            this.lastWidth = width;
            this.lastHeight = height;
        }
    };
    p.create = function(index) {
        this.__created = true;
        this.index = Math.min(index || 0, this.slidesCount - 1);
        this.lastSnap = this.index;
        if (this.loop) this.slides = this.__createLoopList();
        this.normalMode = this.slidesCount <= this.options.viewNum;
        for (var i = 0; i < this.slidesCount; ++i) this.slides[i].create();
        this.__locateSlides();
        this.controller.options.snapsize = this[this.__dimension] + this.spacing;
        if (!this.loop) this.controller._max_value = (this.slidesCount - 1) * (this[this.__dimension] + this.spacing);
        this.gotoSlide(this.index, true);
        if (this.options.swipe && (window._touch || this.options.mouseSwipe)) this.setupSwipe();
    };
    p.destroy = function() {
        if (!this.__created) return;
        for (var i = 0; i < this.slidesCount; ++i) this.slides[i].destroy();
        this.slides = null;
        this.slideList = null;
        this.$element.remove();
        this.controller.destroy();
        this.controller = null;
    };
    averta.EventDispatcher.extend(p);
    MSSlideController.registerView("basic", MSBasicView);
})(jQuery);

(function($) {
    "use strict";
    window.MSWaveView = function(options) {
        MSBasicView.call(this, options);
        this.$element.removeClass("ms-basic-view").addClass("ms-wave-view");
        this.$slideCont.css(window._csspfx + "transform-style", "preserve-3d");
        this.autoUpdateZIndex = true;
    };
    MSWaveView.extend(MSBasicView);
    MSWaveView._3dreq = true;
    MSWaveView._fallback = MSBasicView;
    var p = MSWaveView.prototype;
    var _super = MSBasicView.prototype;
    p._horizUpdate = function(controller, value) {
        _super._horizUpdate.call(this, controller, value);
        var cont_scroll = -value;
        var slide_pos, slide, distance;
        for (var i = 0; i < this.slidesCount; ++i) {
            slide = this.slideList[i];
            distance = -cont_scroll - slide.position;
            this.__updateSlidesHoriz(slide, distance);
        }
    };
    p._vertiUpdate = function(controller, value) {
        _super._vertiUpdate.call(this, controller, value);
        var cont_scroll = -value;
        var slide_pos, slide, distance;
        for (var i = 0; i < this.slidesCount; ++i) {
            slide = this.slideList[i];
            distance = -cont_scroll - slide.position;
            this.__updateSlidesVertic(slide, distance);
        }
    };
    p.__updateSlidesHoriz = function(slide, distance) {
        var value = Math.abs(distance * 100 / this.__width);
        slide.$element.css(window._csspfx + "transform", "translateZ(" + -value * 3 + "px) rotateY(0.01deg)");
    };
    p.__updateSlidesVertic = function(slide, distance) {
        this.__updateSlidesHoriz(slide, distance);
    };
    MSSlideController.registerView("wave", MSWaveView);
})(jQuery);

(function() {
    window.MSFadeBasicView = function(options) {
        MSWaveView.call(this, options);
        this.$element.removeClass("ms-wave-view").addClass("ms-fade-basic-view");
    };
    MSFadeBasicView.extend(MSWaveView);
    var p = MSFadeBasicView.prototype;
    var _super = MSFadeBasicView.prototype;
    p.__updateSlidesHoriz = function(slide, distance) {
        var value = Math.abs(distance * .6 / this.__width);
        value = 1 - Math.min(value, .6);
        slide.$element.css("opacity", value);
    };
    p.__updateSlidesVertic = function(slide, distance) {
        this.__updateSlidesHoriz(slide, distance);
    };
    MSSlideController.registerView("fadeBasic", MSFadeBasicView);
    MSWaveView._fallback = MSFadeBasicView;
})();

(function() {
    window.MSFadeWaveView = function(options) {
        MSWaveView.call(this, options);
        this.$element.removeClass("ms-wave-view").addClass("ms-fade-wave-view");
    };
    MSFadeWaveView.extend(MSWaveView);
    MSFadeWaveView._3dreq = true;
    MSFadeWaveView._fallback = MSFadeBasicView;
    var p = MSFadeWaveView.prototype;
    var _super = MSWaveView.prototype;
    p.__updateSlidesHoriz = function(slide, distance) {
        var value = Math.abs(distance * 100 / this.__width);
        value = Math.min(value, 100);
        slide.$element.css("opacity", 1 - value / 300);
        slide.$element[0].style[window._jcsspfx + "Transform"] = "scale(" + (1 - value / 800) + ") rotateY(0.01deg) ";
    };
    p.__updateSlidesVertic = function(slide, distance) {
        this.__updateSlidesHoriz(slide, distance);
    };
    MSSlideController.registerView("fadeWave", MSFadeWaveView);
})();

(function($) {
    "use strict";
    window.MSFlowView = function(options) {
        MSWaveView.call(this, options);
        this.$element.removeClass("ms-wave-view").addClass("ms-flow-view");
    };
    MSFlowView.extend(MSWaveView);
    MSFlowView._3dreq = true;
    MSFlowView._fallback = MSFadeBasicView;
    var p = MSFlowView.prototype;
    var _super = MSWaveView.prototype;
    p.__updateSlidesHoriz = function(slide, distance) {
        var value = Math.abs(distance * 100 / this.__width);
        var rvalue = Math.min(value * .3, 30) * (distance < 0 ? -1 : 1);
        var zvalue = value * 1.2;
        slide.$element[0].style[window._jcsspfx + "Transform"] = "translateZ(" + -zvalue * 5 + "px) rotateY(" + rvalue + "deg) ";
    };
    p.__updateSlidesVertic = function(slide, distance) {
        var value = Math.abs(distance * 100 / this.__width);
        var rvalue = Math.min(value * .3, 30) * (distance < 0 ? -1 : 1);
        var zvalue = value * 1.2;
        slide.$element[0].style[window._jcsspfx + "Transform"] = "translateZ(" + -zvalue * 5 + "px) rotateX(" + -rvalue + "deg) ";
    };
    MSSlideController.registerView("flow", MSFlowView);
})(jQuery);

(function() {
    window.MSFadeFlowView = function(options) {
        MSWaveView.call(this, options);
        this.$element.removeClass("ms-wave-view").addClass("ms-fade-flow-view");
    };
    MSFadeFlowView.extend(MSWaveView);
    MSFadeFlowView._3dreq = true;
    var p = MSFadeFlowView.prototype;
    var _super = MSWaveView.prototype;
    p.__calculate = function(distance) {
        var value = Math.min(Math.abs(distance * 100 / this.__width), 100);
        var rvalue = Math.min(value * .5, 50) * (distance < 0 ? -1 : 1);
        return {
            value: value,
            rvalue: rvalue
        };
    };
    p.__updateSlidesHoriz = function(slide, distance) {
        var clc = this.__calculate(distance);
        slide.$element.css("opacity", 1 - clc.value / 300);
        console.log(window._jcsspfx + "transform", "translateZ(" + -clc.value + "px) rotateY(" + clc.rvalue + "deg) ");
        slide.$element[0].style[window._jcsspfx + "Transform"] = "translateZ(" + -clc.value + "px) rotateY(" + clc.rvalue + "deg) ";
    };
    p.__updateSlidesVertic = function(slide, distance) {
        var clc = this.__calculate(distance);
        slide.$element.css("opacity", 1 - clc.value / 300);
        slide.$element[0].style[window._jcsspfx + "Transform"] = "translateZ(" + -clc.value + "px) rotateX(" + -clc.rvalue + "deg) ";
    };
    MSSlideController.registerView("fadeFlow", MSFadeFlowView);
})();

(function($) {
    "use strict";
    window.MSMaskView = function(options) {
        MSBasicView.call(this, options);
        this.$element.removeClass("ms-basic-view").addClass("ms-mask-view");
    };
    MSMaskView.extend(MSBasicView);
    var p = MSMaskView.prototype;
    var _super = MSBasicView.prototype;
    p.addSlide = function(slide) {
        slide.view = this;
        slide.$frame = $("<div></div>").addClass("ms-mask-frame").append(slide.$element);
        slide.$element[0].style.position = "relative";
        slide.autoAppend = false;
        this.slides.push(slide);
        this.slideList.push(slide);
        this.slidesCount++;
    };
    p.setSize = function(width, height) {
        var slider = this.slides[0].slider;
        for (var i = 0; i < this.slidesCount; ++i) {
            this.slides[i].$frame[0].style.width = width + "px";
            if (!slider.options.autoHeight) this.slides[i].$frame[0].style.height = height + "px";
        }
        _super.setSize.call(this, width, height);
    };
    p._horizUpdate = function(controller, value) {
        _super._horizUpdate.call(this, controller, value);
        var i = 0;
        if (this.css3) {
            for (i = 0; i < this.slidesCount; ++i) {
                this.slideList[i].$element[0].style[window._jcsspfx + "Transform"] = "translateX(" + (value - this.slideList[i].position) + "px)" + this.__translate_end;
            }
            return;
        }
        for (i = 0; i < this.slidesCount; ++i) {
            this.slideList[i].$element[0].style.left = value - this.slideList[i].position + "px";
        }
    };
    p._vertiUpdate = function(controller, value) {
        _super._vertiUpdate.call(this, controller, value);
        var i = 0;
        if (this.css3) {
            for (i = 0; i < this.slidesCount; ++i) {
                this.slideList[i].$element[0].style[window._jcsspfx + "Transform"] = "translateY(" + (value - this.slideList[i].position) + "px)" + this.__translate_end;
            }
            return;
        }
        for (i = 0; i < this.slidesCount; ++i) {
            this.slideList[i].$element[0].style.top = value - this.slideList[i].position + "px";
        }
    };
    p.__pushEnd = function() {
        var first_slide = this.slides.shift();
        var last_slide = this.slides[this.slidesCount - 2];
        this.slides.push(first_slide);
        if (!this.normalMode) return;
        var pos = last_slide.$frame[0][this.__offset] + this.spacing + this[this.__dimension];
        first_slide.$frame[0].style[this.__cssProb] = pos + "px";
        first_slide.position = pos;
    };
    p.__pushStart = function() {
        var last_slide = this.slides.pop();
        var first_slide = this.slides[0];
        this.slides.unshift(last_slide);
        if (!this.normalMode) return;
        var pos = first_slide.$frame[0][this.__offset] - this.spacing - this[this.__dimension];
        last_slide.$frame[0].style[this.__cssProb] = pos + "px";
        last_slide.position = pos;
    };
    p.__updateViewList = function() {
        if (this.normalMode) {
            this.viewSlidesList = this.slides;
            return;
        }
        var temp = this.viewSlidesList.slice();
        this.viewSlidesList = [];
        var i = 0, hlf = Math.floor(this.options.viewNum / 2), l;
        if (this.loop) {
            for (;i !== this.options.viewNum; i++) this.viewSlidesList.push(this.slides[this.currentSlideLoc - hlf + i]);
        } else {
            for (i = 0; i !== hlf && this.index - i !== -1; i++) this.viewSlidesList.unshift(this.slideList[this.index - i]);
            for (i = 1; i !== hlf && this.index + i !== this.slidesCount; i++) this.viewSlidesList.push(this.slideList[this.index + i]);
        }
        for (i = 0, l = temp.length; i !== l; i++) {
            if (this.viewSlidesList.indexOf(temp[i]) === -1) {
                temp[i].sleep();
                temp[i].$frame.detach();
            }
        }
        temp = null;
    };
    p.__locateSlides = function(move, start) {
        this.__updateViewList();
        start = !this.loop ? this.slides.indexOf(this.viewSlidesList[0]) * (this[this.__dimension] + this.spacing) : start || 0;
        var l = this.viewSlidesList.length, slide;
        for (var i = 0; i !== l; i++) {
            var pos = start + i * (this[this.__dimension] + this.spacing);
            slide = this.viewSlidesList[i];
            this.$slideCont.append(slide.$frame);
            slide.wakeup(false);
            slide.position = pos;
            if (slide.selected && slide.bgvideo) {
                try {
                    slide.bgvideo.play();
                } catch (e) {}
            }
            slide.$frame[0].style[this.__cssProb] = pos + "px";
        }
        if (move !== false) this.controller.changeTo(this.slideList[this.index].position, false, null, null, false);
    };
    MSSlideController.registerView("mask", MSMaskView);
})(jQuery);

(function($) {
    "use strict";
    window.MSParallaxMaskView = function(options) {
        MSMaskView.call(this, options);
        this.$element.removeClass("ms-basic-view").addClass("ms-parallax-mask-view");
    };
    MSParallaxMaskView.extend(MSMaskView);
    MSParallaxMaskView.parallaxAmount = .5;
    var p = MSParallaxMaskView.prototype;
    var _super = MSBasicView.prototype;
    p._horizUpdate = function(controller, value) {
        _super._horizUpdate.call(this, controller, value);
        var i = 0;
        if (this.css3) {
            for (i = 0; i < this.slidesCount; ++i) {
                this.slideList[i].$element[0].style[window._jcsspfx + "Transform"] = "translateX(" + (value - this.slideList[i].position) * MSParallaxMaskView.parallaxAmount + "px)" + this.__translate_end;
            }
            return;
        }
        for (i = 0; i < this.slidesCount; ++i) {
            this.slideList[i].$element[0].style.left = (value - this.slideList[i].position) * MSParallaxMaskView.parallaxAmount + "px";
        }
    };
    p._vertiUpdate = function(controller, value) {
        _super._vertiUpdate.call(this, controller, value);
        var i = 0;
        if (this.css3) {
            for (i = 0; i < this.slidesCount; ++i) {
                this.slideList[i].$element[0].style[window._jcsspfx + "Transform"] = "translateY(" + (value - this.slideList[i].position) * MSParallaxMaskView.parallaxAmount + "px)" + this.__translate_end;
            }
            return;
        }
        for (i = 0; i < this.slidesCount; ++i) {
            this.slideList[i].$element[0].style.top = (value - this.slideList[i].position) * MSParallaxMaskView.parallaxAmount + "px";
        }
    };
    MSSlideController.registerView("parallaxMask", MSParallaxMaskView);
})(jQuery);

(function($) {
    "use strict";
    window.MSFadeView = function(options) {
        MSBasicView.call(this, options);
        this.$element.removeClass("ms-basic-view").addClass("ms-fade-view");
        this.controller.renderCallback(this.__update, this);
    };
    MSFadeView.extend(MSBasicView);
    var p = MSFadeView.prototype;
    var _super = MSBasicView.prototype;
    p.__update = function(controller, value) {
        var cont_scroll = -value;
        var slide_pos, slide, distance;
        for (var i = 0; i < this.slidesCount; ++i) {
            slide = this.slideList[i];
            distance = -cont_scroll - slide.position;
            this.__updateSlides(slide, distance);
        }
    };
    p.__updateSlides = function(slide, distance) {
        var value = Math.abs(distance / this[this.__dimension]);
        if (1 - value <= 0) {
            slide.$element.fadeTo(0, 0).css("visibility", "hidden");
        } else {
            slide.$element.fadeTo(0, 1 - value).css("visibility", "");
        }
    };
    p.__locateSlides = function(move, start) {
        this.__updateViewList();
        start = !this.loop ? this.slides.indexOf(this.viewSlidesList[0]) * (this[this.__dimension] + this.spacing) : start || 0;
        var l = this.viewSlidesList.length, slide;
        for (var i = 0; i !== l; i++) {
            var pos = start + i * this[this.__dimension];
            slide = this.viewSlidesList[i];
            slide.wakeup();
            slide.position = pos;
        }
        if (move !== false) this.controller.changeTo(this.slideList[this.index].position, false, null, null, false);
    };
    p.__pushEnd = function() {
        var first_slide = this.slides.shift();
        var last_slide = this.slides[this.slidesCount - 2];
        this.slides.push(first_slide);
        first_slide.position = last_slide.position + this[this.__dimension];
    };
    p.__pushStart = function() {
        var last_slide = this.slides.pop();
        var first_slide = this.slides[0];
        this.slides.unshift(last_slide);
        last_slide.position = first_slide.position - this[this.__dimension];
    };
    p.create = function(index) {
        _super.create.call(this, index);
        this.spacing = 0;
        this.controller.options.minValidDist = 10;
    };
    MSSlideController.registerView("fade", MSFadeView);
})(jQuery);

(function($) {
    "use strict";
    window.MSScaleView = function(options) {
        MSBasicView.call(this, options);
        this.$element.removeClass("ms-basic-view").addClass("ms-scale-view");
        this.controller.renderCallback(this.__update, this);
    };
    MSScaleView.extend(MSFadeView);
    var p = MSScaleView.prototype;
    var _super = MSFadeView.prototype;
    p.__updateSlides = function(slide, distance) {
        var value = Math.abs(distance / this[this.__dimension]), element = slide.$element[0];
        if (1 - value <= 0) {
            element.style.opacity = 0;
            element.style.visibility = "hidden";
            element.style[window._jcsspfx + "Transform"] = "";
        } else {
            element.style.opacity = 1 - value;
            element.style.visibility = "";
            element.style[window._jcsspfx + "Transform"] = "perspective(2000px) translateZ(" + value * (distance < 0 ? -.5 : .5) * 300 + "px)";
        }
    };
    p.create = function(index) {
        _super.create.call(this, index);
        this.controller.options.minValidDist = .03;
    };
    MSSlideController.registerView("scale", MSScaleView);
})(jQuery);

(function($) {
    "use strict";
    window.MSStackView = function(options) {
        MSBasicView.call(this, options);
        this.$element.removeClass("ms-basic-view").addClass("ms-stack-view");
        this.controller.renderCallback(this.__update, this);
        this.autoUpdateZIndex = true;
    };
    MSStackView.extend(MSFadeView);
    MSStackView._3dreq = true;
    MSStackView._fallback = MSFadeView;
    var p = MSStackView.prototype;
    var _super = MSFadeView.prototype;
    p.__updateSlidesZindex = function() {
        var slide, l = this.viewSlidesList.length;
        for (var i = 0; i !== l; i++) {
            slide = this.viewSlidesList[i];
            this.viewSlidesList[i].$element.css("z-index", l - i);
        }
    };
    p.__updateSlides = function(slide, distance) {
        var value = Math.abs(distance / this[this.__dimension]), element = slide.$element[0];
        if (1 - value <= 0) {
            element.style.opacity = 1;
            element.style.visibility = "hidden";
            element.style[window._jcsspfx + "Transform"] = "";
        } else {
            element.style.visibility = "";
            if (distance < 0) {
                element.style[window._jcsspfx + "Transform"] = "perspective(2000px) translateZ(" + value * -300 + "px)";
            } else {
                element.style[window._jcsspfx + "Transform"] = this.__translate + "(" + -value * this[this.__dimension] + "px)";
            }
        }
    };
    p.create = function(index) {
        _super.create.call(this, index);
        this.controller.options.minValidDist = .03;
        this.__translate = this.dir === "h" ? "translateX" : "translateY";
    };
    MSSlideController.registerView("stack", MSStackView);
})(jQuery);

(function() {
    "use strict";
    var perspective = 2e3;
    window.MSFocusView = function(options) {
        MSWaveView.call(this, options);
        this.$element.removeClass("ms-wave-view").addClass("ms-focus-view");
        this.options.centerSpace = this.options.centerSpace || 1;
    };
    MSFocusView.extend(MSWaveView);
    MSFocusView._3dreq = true;
    MSFocusView._fallback = MSFadeBasicView;
    var p = MSFocusView.prototype;
    var _super = MSWaveView.prototype;
    p.__calcview = function(z, w) {
        var a = w / 2 * z / (z + perspective);
        return a * (z + perspective) / perspective;
    };
    p.__updateSlidesHoriz = function(slide, distance) {
        var value = Math.abs(distance * 100 / this.__width);
        value = -Math.min(value, 100) * 15;
        slide.$element.css(window._csspfx + "transform", "translateZ(" + (value + 1) + "px) rotateY(0.01deg) translateX(" + (distance < 0 ? 1 : -1) * (-this.__calcview(value, this.__width) * this.options.centerSpace) + "px)");
    };
    p.__updateSlidesVertic = function(slide, distance) {
        var value = Math.abs(distance * 100 / this.__width);
        value = -Math.min(value, 100) * 15;
        slide.$element.css(window._csspfx + "transform", "translateZ(" + (value + 1) + "px) rotateY(0.01deg) translateY(" + (distance < 0 ? 1 : -1) * (-this.__calcview(value, this.__width) * this.options.centerSpace) + "px)");
    };
    MSSlideController.registerView("focus", MSFocusView);
})();

(function() {
    window.MSPartialWaveView = function(options) {
        MSWaveView.call(this, options);
        this.$element.removeClass("ms-wave-view").addClass("ms-partial-wave-view");
    };
    MSPartialWaveView.extend(MSWaveView);
    MSPartialWaveView._3dreq = true;
    MSPartialWaveView._fallback = MSFadeBasicView;
    var p = MSPartialWaveView.prototype;
    var _super = MSWaveView.prototype;
    p.__updateSlidesHoriz = function(slide, distance) {
        var value = Math.abs(distance * 100 / this.__width);
        if (slide.hasBG) {
            slide.$bg_img.css("opacity", (100 - Math.abs(distance * 120 / this.__width / 3)) / 100);
        }
        slide.$element.css(window._csspfx + "transform", "translateZ(" + -value * 3 + "px) rotateY(0.01deg) translateX(" + distance * .75 + "px)");
    };
    p.__updateSlidesVertic = function(slide, distance) {
        var value = Math.abs(distance * 100 / this.__width);
        if (slide.hasBG) {
            slide.$bg_img.css("opacity", (100 - Math.abs(distance * 120 / this.__width / 3)) / 100);
        }
        slide.$element.css(window._csspfx + "transform", "translateZ(" + -value * 3 + "px) rotateY(0.01deg) translateY(" + distance * .75 + "px)");
    };
    MSSlideController.registerView("partialWave", MSPartialWaveView);
})();

(function($) {
    "use strict";
    var BaseControl = function() {
        this.options = {
            prefix: "ms-",
            autohide: true,
            overVideo: true,
            customClass: null
        };
    };
    var p = BaseControl.prototype;
    p.slideAction = function(slide) {};
    p.setup = function() {
        this.cont = this.options.insertTo ? $(this.options.insertTo) : this.slider.$controlsCont;
        if (!this.options.overVideo) this._hideOnvideoStarts();
    };
    p.checkHideUnder = function() {
        if (this.options.hideUnder) {
            this.needsRealign = !this.options.insetTo && (this.options.align === "left" || this.options.align === "right") && this.options.inset === false;
            $(window).bind("resize", {
                that: this
            }, this.onResize);
            this.onResize();
        }
    };
    p.onResize = function(event) {
        var that = event && event.data.that || this;
        var w = window.innerWidth;
        if (w <= that.options.hideUnder && !that.detached) {
            that.hide(true);
            that.detached = true;
            that.onDetach();
        } else if (w >= that.options.hideUnder && that.detached) {
            that.detached = false;
            that.visible();
            that.onAppend();
        }
    };
    p.create = function() {
        var that = this;
        if (this.options.autohide) {
            this.hide(true);
            this.slider.$controlsCont.mouseenter($.proxy(this._onMouseEnter, this)).mouseleave($.proxy(this._onMouseLeave, this)).mousedown($.proxy(this._onMouseDown, this));
            if (this.$element) {
                this.$element.mouseenter($.proxy(this._onMouseEnter, this)).mouseleave($.proxy(this._onMouseLeave, this)).mousedown($.proxy(this._onMouseDown, this));
            }
            $(document).mouseup($.proxy(this._onMouseUp, this));
        }
        if (this.options.align) {
            this.$element.addClass("ms-align-" + this.options.align);
        }
        if (this.options.customClass && this.$element) {
            this.$element.addClass(this.options.customClass);
        }
    };
    p._onMouseEnter = function() {
        if (!this._disableAH && !this.mdown) {
            this.visible();
        }
        this.mleave = false;
    };
    p._onMouseLeave = function() {
        if (!this.mdown) {
            this.hide();
        }
        this.mleave = true;
    };
    p._onMouseDown = function() {
        this.mdown = true;
    };
    p._onMouseUp = function() {
        if (this.mdown && this.mleave) {
            this.hide();
        }
        this.mdown = false;
    };
    p.onAppend = function() {
        if (this.needsRealign) {
            this.slider._realignControls();
        }
    };
    p.onDetach = function() {
        if (this.needsRealign) {
            this.slider._realignControls();
        }
    };
    p._hideOnvideoStarts = function() {
        var that = this;
        this.slider.api.addEventListener(MSSliderEvent.VIDEO_PLAY, function() {
            that._disableAH = true;
            that.hide();
        });
        this.slider.api.addEventListener(MSSliderEvent.VIDEO_CLOSE, function() {
            that._disableAH = false;
            that.visible();
        });
    };
    p.hide = function(fast) {
        if (fast) {
            this.$element.css("opacity", 0);
            this.$element.css("display", "none");
        } else {
            clearTimeout(this.hideTo);
            var $element = this.$element;
            this.hideTo = setTimeout(function() {
                CTween.fadeOut($element, 400, false);
            }, 20);
        }
        this.$element.addClass("ms-ctrl-hide");
    };
    p.visible = function() {
        if (this.detached) return;
        clearTimeout(this.hideTo);
        this.$element.css("display", "");
        CTween.fadeIn(this.$element, 400, false);
        this.$element.removeClass("ms-ctrl-hide");
    };
    p.destroy = function() {
        if (this.options && this.options.hideUnder) {
            $(window).unbind("resize", this.onResize);
        }
    };
    window.BaseControl = BaseControl;
})(jQuery);

(function($) {
    "use strict";
    var MSArrows = function(options) {
        BaseControl.call(this);
        $.extend(this.options, options);
    };
    MSArrows.extend(BaseControl);
    var p = MSArrows.prototype;
    var _super = BaseControl.prototype;
    p.setup = function() {
        var that = this;
        this.$next = $("<div></div>").addClass(this.options.prefix + "nav-next").bind("click", function() {
            that.slider.api.next(true);
        });
        this.$prev = $("<div></div>").addClass(this.options.prefix + "nav-prev").bind("click", function() {
            that.slider.api.previous(true);
        });
        _super.setup.call(this);
        this.cont.append(this.$next);
        this.cont.append(this.$prev);
        this.checkHideUnder();
    };
    p.hide = function(fast) {
        if (fast) {
            this.$prev.css("opacity", 0).css("display", "none");
            this.$next.css("opacity", 0).css("display", "none");
            return;
        }
        CTween.fadeOut(this.$prev, 400, false);
        CTween.fadeOut(this.$next, 400, false);
        this.$prev.addClass("ms-ctrl-hide");
        this.$next.addClass("ms-ctrl-hide");
    };
    p.visible = function() {
        if (this.detached) return;
        CTween.fadeIn(this.$prev, 400);
        CTween.fadeIn(this.$next, 400);
        this.$prev.removeClass("ms-ctrl-hide").css("display", "");
        this.$next.removeClass("ms-ctrl-hide").css("display", "");
    };
    p.destroy = function() {
        _super.destroy();
        this.$next.remove();
        this.$prev.remove();
    };
    window.MSArrows = MSArrows;
    MSSlideController.registerControl("arrows", MSArrows);
})(jQuery);

(function($) {
    "use strict";
    var MSThumblist = function(options) {
        BaseControl.call(this);
        this.options.dir = "h";
        this.options.wheel = options.dir === "v";
        this.options.arrows = false;
        this.options.speed = 17;
        this.options.align = null;
        this.options.inset = false;
        this.options.margin = 10;
        this.options.space = 10;
        this.options.width = 100;
        this.options.height = 100;
        this.options.type = "thumbs";
        this.options.hover = false;
        $.extend(this.options, options);
        this.thumbs = [];
        this.index_count = 0;
        this.__dimen = this.options.dir === "h" ? "width" : "height";
        this.__alignsize = this.options.dir === "h" ? "height" : "width";
        this.__jdimen = this.options.dir === "h" ? "outerWidth" : "outerHeight";
        this.__pos = this.options.dir === "h" ? "left" : "top";
        this.click_enable = true;
    };
    MSThumblist.extend(BaseControl);
    var p = MSThumblist.prototype;
    var _super = BaseControl.prototype;
    p.setup = function() {
        this.$element = $("<div></div>").addClass(this.options.prefix + "thumb-list");
        if (this.options.type === "tabs") {
            this.$element.addClass(this.options.prefix + "tabs");
        }
        this.$element.addClass("ms-dir-" + this.options.dir);
        _super.setup.call(this);
        if (this.slider.$controlsCont === this.cont) {
            this.$element.appendTo(this.slider.$element);
        } else {
            this.$element.appendTo(this.cont);
        }
        this.$thumbscont = $("<div></div>").addClass("ms-thumbs-cont").appendTo(this.$element);
        if (this.options.arrows) {
            var that = this;
            this.$fwd = $("<div></div>").addClass("ms-thumblist-fwd").appendTo(this.$element).click(function() {
                that.controller.push(-15);
            });
            this.$bwd = $("<div></div>").addClass("ms-thumblist-bwd").appendTo(this.$element).click(function() {
                that.controller.push(15);
            });
        }
        if (!this.options.insetTo && this.options.align) {
            var align = this.options.align;
            if (this.options.inset) {
                this.$element.css(align, this.options.margin);
            } else if (align === "top") {
                this.$element.detach().prependTo(this.slider.$element).css({
                    "margin-bottom": this.options.margin,
                    position: "relative"
                });
            } else if (align === "bottom") {
                this.$element.css({
                    "margin-top": this.options.margin,
                    position: "relative"
                });
            } else {
                this.slider.api.addEventListener(MSSliderEvent.RESERVED_SPACE_CHANGE, this.align, this);
                this.align();
            }
            if (this.options.dir === "v") {
                this.$element.width(this.options.width);
            } else {
                this.$element.height(this.options.height);
            }
        }
        this.checkHideUnder();
    };
    p.align = function(event) {
        if (this.detached) {
            return;
        }
        var align = this.options.align;
        var pos = this.slider.reserveSpace(align, this.options[this.__alignsize] + this.options.margin * 2);
        this.$element.css(align, -pos - this.options[this.__alignsize] - this.options.margin);
    };
    p.slideAction = function(slide) {
        var thumb_ele = slide.$element.find(".ms-thumb");
        var that = this;
        var thumb_frame = $("<div></div>").addClass("ms-thumb-frame").append(thumb_ele).append($('<div class="ms-thumb-ol"></div>')).bind(this.options.hover ? "hover" : "click", function() {
            that.changeSlide(thumb_frame);
        });
        if (this.options.align) {
            thumb_frame.width(this.options.width - (this.options.dir === "v" && this.options.type === "tabs" ? 12 : 0)).height(this.options.height).css("margin-" + (this.options.dir === "v" ? "bottom" : "right"), this.options.space);
        }
        thumb_frame[0].index = this.index_count++;
        this.$thumbscont.append(thumb_frame);
        if (this.options.fillMode && thumb_ele.is("img")) {
            var aligner = new window.MSAligner(this.options.fillMode, thumb_frame, thumb_ele);
            thumb_ele[0].aligner = aligner;
            thumb_ele.one("load", function(e) {
                var $this = $(this);
                $this[0].aligner.init($this.width(), $this.height());
                $this[0].aligner.align();
            }).each($.jqLoadFix);
        }
        if ($.browser.msie) thumb_ele.on("dragstart", function(event) {
            event.preventDefault();
        });
        this.thumbs.push(thumb_frame);
    };
    p.create = function() {
        _super.create.call(this);
        this.__translate_end = window._css3d ? " translateZ(0px)" : "";
        this.controller = new Controller(0, 0, {
            snappingMinSpeed: 2,
            friction: (100 - this.options.speed * .5) / 100
        });
        this.controller.renderCallback(this.options.dir === "h" ? this._hMove : this._vMove, this);
        var that = this;
        this.resize_listener = function() {
            that.__resize();
        };
        $(window).bind("resize", this.resize_listener);
        this.thumbSize = this.thumbs[0][this.__jdimen](true);
        this.setupSwipe();
        this.__resize();
        var that = this;
        if (this.options.wheel) {
            this.wheellistener = function(event) {
                var e = window.event || event.orginalEvent || event;
                var delta = Math.max(-1, Math.min(1, e.wheelDelta || -e.detail));
                that.controller.push(-delta * 10);
                return false;
            };
            if ($.browser.mozilla) this.$element[0].addEventListener("DOMMouseScroll", this.wheellistener); else this.$element.bind("mousewheel", this.wheellistener);
        }
        this.slider.api.addEventListener(MSSliderEvent.CHANGE_START, this.update, this);
        this.slider.api.addEventListener(MSSliderEvent.HARD_UPDATE, this.realignThumbs, this);
        this.cindex = this.slider.api.index();
        this.select(this.thumbs[this.cindex]);
    };
    p._hMove = function(controller, value) {
        this.__contPos = value;
        if (window._cssanim) {
            this.$thumbscont[0].style[window._jcsspfx + "Transform"] = "translateX(" + -value + "px)" + this.__translate_end;
            return;
        }
        this.$thumbscont[0].style.left = -value + "px";
    };
    p._vMove = function(controller, value) {
        this.__contPos = value;
        if (window._cssanim) {
            this.$thumbscont[0].style[window._jcsspfx + "Transform"] = "translateY(" + -value + "px)" + this.__translate_end;
            return;
        }
        this.$thumbscont[0].style.top = -value + "px";
    };
    p.setupSwipe = function() {
        this.swipeControl = new averta.TouchSwipe(this.$element);
        this.swipeControl.swipeType = this.options.dir === "h" ? "horizontal" : "vertical";
        var that = this;
        if (this.options.dir === "h") this.swipeControl.onSwipe = function(status) {
            that.horizSwipeMove(status);
        }; else this.swipeControl.onSwipe = function(status) {
            that.vertSwipeMove(status);
        };
    };
    p.vertSwipeMove = function(status) {
        if (this.dTouch) return;
        var phase = status.phase;
        if (phase === "start") this.controller.stop(); else if (phase === "move") this.controller.drag(status.moveY); else if (phase === "end" || phase === "cancel") {
            var speed = Math.abs(status.distanceY / status.duration * 50 / 3);
            if (speed > .1) {
                this.controller.push(-status.distanceY / status.duration * 50 / 3);
            } else {
                this.click_enable = true;
                this.controller.cancel();
            }
        }
    };
    p.horizSwipeMove = function(status) {
        if (this.dTouch) return;
        var phase = status.phase;
        if (phase === "start") {
            this.controller.stop();
            this.click_enable = false;
        } else if (phase === "move") this.controller.drag(status.moveX); else if (phase === "end" || phase === "cancel") {
            var speed = Math.abs(status.distanceX / status.duration * 50 / 3);
            if (speed > .1) {
                this.controller.push(-status.distanceX / status.duration * 50 / 3);
            } else {
                this.click_enable = true;
                this.controller.cancel();
            }
        }
    };
    p.update = function() {
        var nindex = this.slider.api.index();
        if (this.cindex === nindex) return;
        if (this.cindex != null) this.unselect(this.thumbs[this.cindex]);
        this.cindex = nindex;
        this.select(this.thumbs[this.cindex]);
        if (!this.dTouch) this.updateThumbscroll();
    };
    p.realignThumbs = function() {
        this.$element.find(".ms-thumb").each(function(index, thumb) {
            if (thumb.aligner) {
                thumb.aligner.align();
            }
        });
    };
    p.updateThumbscroll = function() {
        var thumb_size;
        var pos = this.thumbSize * this.cindex;
        if (this.controller.value == NaN) this.controller.value = 0;
        if (pos - this.controller.value < 0) {
            this.controller.gotoSnap(this.cindex, true);
            return;
        }
        if (pos + this.thumbSize - this.controller.value > this.$element[this.__dimen]()) {
            var first_snap = this.cindex - Math.floor(this.$element[this.__dimen]() / this.thumbSize) + 1;
            this.controller.gotoSnap(first_snap, true);
            return;
        }
    };
    p.changeSlide = function(thumb) {
        if (!this.click_enable || this.cindex === thumb[0].index) return;
        this.slider.api.gotoSlide(thumb[0].index);
    };
    p.unselect = function(ele) {
        ele.removeClass("ms-thumb-frame-selected");
    };
    p.select = function(ele) {
        ele.addClass("ms-thumb-frame-selected");
    };
    p.__resize = function() {
        var size = this.$element[this.__dimen]();
        if (this.ls === size) return;
        this.ls = size;
        this.thumbSize = this.thumbs[0][this.__jdimen](true);
        var len = this.slider.api.count() * this.thumbSize;
        this.$thumbscont[0].style[this.__dimen] = len + "px";
        if (len <= size) {
            this.dTouch = true;
            this.controller.stop();
            this.$thumbscont[0].style[this.__pos] = (size - len) * .5 + "px";
            this.$thumbscont[0].style[window._jcsspfx + "Transform"] = "";
        } else {
            this.dTouch = false;
            this.click_enable = true;
            this.$thumbscont[0].style[this.__pos] = "";
            this.controller._max_value = len - size;
            this.controller.options.snapsize = this.thumbSize;
            this.updateThumbscroll();
        }
    };
    p.destroy = function() {
        _super.destroy();
        if (this.options.wheel) {
            if ($.browser.mozilla) this.$element[0].removeEventListener("DOMMouseScroll", this.wheellistener); else this.$element.unbind("mousewheel", this.wheellistener);
            this.wheellistener = null;
        }
        $(window).unbind("resize", this.resize_listener);
        this.$element.remove();
        this.slider.api.removeEventListener(MSSliderEvent.RESERVED_SPACE_CHANGE, this.align, this);
        this.slider.api.removeEventListener(MSSliderEvent.CHANGE_START, this.update, this);
    };
    window.MSThumblist = MSThumblist;
    MSSlideController.registerControl("thumblist", MSThumblist);
})(jQuery);

(function($) {
    "use strict";
    var MSBulltes = function(options) {
        BaseControl.call(this);
        this.options.dir = "h";
        this.options.inset = true;
        this.options.margin = 10;
        this.options.space = 10;
        $.extend(this.options, options);
        this.bullets = [];
    };
    MSBulltes.extend(BaseControl);
    var p = MSBulltes.prototype;
    var _super = BaseControl.prototype;
    p.setup = function() {
        _super.setup.call(this);
        this.$element = $("<div></div>").addClass(this.options.prefix + "bullets").addClass("ms-dir-" + this.options.dir).appendTo(this.cont);
        this.$bullet_cont = $("<div></div>").addClass("ms-bullets-count").appendTo(this.$element);
        if (!this.options.insetTo && this.options.align) {
            var align = this.options.align;
            if (this.options.inset) {
                this.$element.css(align, this.options.margin);
            }
        }
        this.checkHideUnder();
    };
    p.create = function() {
        _super.create.call(this);
        var that = this;
        this.slider.api.addEventListener(MSSliderEvent.CHANGE_START, this.update, this);
        this.cindex = this.slider.api.index();
        for (var i = 0; i < this.slider.api.count(); ++i) {
            var bullet = $("<div></div>").addClass("ms-bullet");
            bullet[0].index = i;
            bullet.on("click", function() {
                that.changeSlide(this.index);
            });
            this.$bullet_cont.append(bullet);
            this.bullets.push(bullet);
            if (this.options.dir === "h") {
                bullet.css("margin", this.options.space / 2);
            } else {
                bullet.css("margin", this.options.space);
            }
        }
        if (this.options.dir === "h") {
            this.$element.width(bullet.outerWidth(true) * this.slider.api.count());
        } else {
            this.$element.css("margin-top", -this.$element.outerHeight(true) / 2);
        }
        this.select(this.bullets[this.cindex]);
    };
    p.update = function() {
        var nindex = this.slider.api.index();
        if (this.cindex === nindex) return;
        if (this.cindex != null) this.unselect(this.bullets[this.cindex]);
        this.cindex = nindex;
        this.select(this.bullets[this.cindex]);
    };
    p.changeSlide = function(index) {
        if (this.cindex === index) return;
        this.slider.api.gotoSlide(index);
    };
    p.unselect = function(ele) {
        ele.removeClass("ms-bullet-selected");
    };
    p.select = function(ele) {
        ele.addClass("ms-bullet-selected");
    };
    p.destroy = function() {
        _super.destroy();
        this.slider.api.removeEventListener(MSSliderEvent.CHANGE_START, this.update, this);
        this.$element.remove();
    };
    window.MSBulltes = MSBulltes;
    MSSlideController.registerControl("bullets", MSBulltes);
})(jQuery);

(function($) {
    "use strict";
    var MSScrollbar = function(options) {
        BaseControl.call(this);
        this.options.dir = "h";
        this.options.autohide = true;
        this.options.width = 4;
        this.options.color = "#3D3D3D";
        this.options.margin = 10;
        $.extend(this.options, options);
        this.__dimen = this.options.dir === "h" ? "width" : "height";
        this.__jdimen = this.options.dir === "h" ? "outerWidth" : "outerHeight";
        this.__pos = this.options.dir === "h" ? "left" : "top";
        this.__translate_end = window._css3d ? " translateZ(0px)" : "";
        this.__translate_start = this.options.dir === "h" ? " translateX(" : "translateY(";
    };
    MSScrollbar.extend(BaseControl);
    var p = MSScrollbar.prototype;
    var _super = BaseControl.prototype;
    p.setup = function() {
        this.$element = $("<div></div>").addClass(this.options.prefix + "sbar").addClass("ms-dir-" + this.options.dir);
        _super.setup.call(this);
        if (this.slider.$controlsCont === this.cont) {
            this.$element.appendTo(this.slider.$element);
        } else {
            this.$element.appendTo(this.cont);
        }
        this.$bar = $("<div></div>").addClass(this.options.prefix + "bar").appendTo(this.$element);
        if (this.slider.options.loop) {
            console.log("WARNING, MSScrollbar cannot work with looped slider.");
            this.disable = true;
            this.$element.remove();
        }
        if (this.options.dir === "v") {
            this.$bar.width(this.options.width);
        } else {
            this.$bar.height(this.options.width);
        }
        this.$bar.css("background-color", this.options.color);
        if (!this.options.insetTo && this.options.align) {
            if (this.options.dir === "v") {
                this.$element.css({
                    right: "auto",
                    left: "auto"
                });
            } else {
                this.$element.css({
                    top: "auto",
                    bottom: "auto"
                });
            }
            var align = this.options.align;
            if (this.options.inset) {
                this.$element.css(align, this.options.margin);
            } else if (align === "top") {
                this.$element.prependTo(this.slider.$element).css({
                    "margin-bottom": this.options.margin,
                    position: "relative"
                });
            } else if (align === "bottom") {
                this.$element.css({
                    "margin-top": this.options.margin,
                    position: "relative"
                });
            } else {
                this.slider.api.addEventListener(MSSliderEvent.RESERVED_SPACE_CHANGE, this.align, this);
                this.align();
            }
        }
        this.checkHideUnder();
    };
    p.align = function(event) {
        if (this.detached) {
            return;
        }
        var align = this.options.align;
        var pos = this.slider.reserveSpace(align, this.options.margin * 2 + this.options.width);
        this.$element.css(align, -pos - this.options.margin - this.options.width);
    };
    p.create = function() {
        if (this.disable) return;
        var that = this;
        this.scroller = this.slider.api.scroller;
        this.slider.api.view.addEventListener(MSViewEvents.SCROLL, this._update, this);
        this.slider.api.addEventListener(MSSliderEvent.RESIZE, this._resize, this);
        this._resize();
        if (this.options.autohide) {
            this.$bar.css("opacity", "0");
        }
    };
    p._resize = function() {
        this.vdimen = this.$element[this.__dimen]();
        this.bar_dimen = this.slider.api.view["__" + this.__dimen] * this.vdimen / this.scroller._max_value;
        this.$bar[this.__dimen](this.bar_dimen);
    };
    p._update = function() {
        var value = this.scroller.value * (this.vdimen - this.bar_dimen) / this.scroller._max_value;
        if (this.lvalue === value) return;
        this.lvalue = value;
        if (this.options.autohide) {
            clearTimeout(this.hto);
            this.$bar.css("opacity", "1");
            var that = this;
            this.hto = setTimeout(function() {
                that.$bar.css("opacity", "0");
            }, 150);
        }
        if (value < 0) {
            this.$bar[0].style[this.__dimen] = this.bar_dimen + value + "px";
            return;
        }
        if (value > this.vdimen - this.bar_dimen) this.$bar[0].style[this.__dimen] = this.vdimen - value + "px";
        if (window._cssanim) {
            this.$bar[0].style[window._jcsspfx + "Transform"] = this.__translate_start + value + "px)" + this.__translate_end;
            return;
        }
        this.$bar[0].style[this.__pos] = value + "px";
    };
    p.destroy = function() {
        _super.destroy();
        this.slider.api.view.removeEventListener(MSViewEvents.SCROLL, this._update, this);
        this.slider.api.removeEventListener(MSSliderEvent.RESIZE, this._resize, this);
        this.slider.api.removeEventListener(MSSliderEvent.RESERVED_SPACE_CHANGE, this.align, this);
        this.$element.remove();
    };
    window.MSScrollbar = MSScrollbar;
    MSSlideController.registerControl("scrollbar", MSScrollbar);
})(jQuery);

(function($) {
    "use strict";
    var MSTimerbar = function(options) {
        BaseControl.call(this);
        this.options.autohide = false;
        this.options.width = 4;
        this.options.color = "#FFFFFF";
        this.options.inset = true;
        this.options.margin = 0;
        $.extend(this.options, options);
    };
    MSTimerbar.extend(BaseControl);
    var p = MSTimerbar.prototype;
    var _super = BaseControl.prototype;
    p.setup = function() {
        var that = this;
        _super.setup.call(this);
        this.$element = $("<div></div>").addClass(this.options.prefix + "timerbar");
        _super.setup.call(this);
        if (this.slider.$controlsCont === this.cont) {
            this.$element.appendTo(this.slider.$element);
        } else {
            this.$element.appendTo(this.cont);
        }
        this.$bar = $("<div></div>").addClass("ms-time-bar").appendTo(this.$element);
        if (this.options.dir === "v") {
            this.$bar.width(this.options.width);
            this.$element.width(this.options.width);
        } else {
            this.$bar.height(this.options.width);
            this.$element.height(this.options.width);
        }
        this.$bar.css("background-color", this.options.color);
        if (!this.options.insetTo && this.options.align) {
            this.$element.css({
                top: "auto",
                bottom: "auto"
            });
            var align = this.options.align;
            if (this.options.inset) {
                this.$element.css(align, this.options.margin);
            } else if (align === "top") {
                this.$element.prependTo(this.slider.$element).css({
                    "margin-bottom": this.options.margin,
                    position: "relative"
                });
            } else if (align === "bottom") {
                this.$element.css({
                    "margin-top": this.options.margin,
                    position: "relative"
                });
            } else {
                this.slider.api.addEventListener(MSSliderEvent.RESERVED_SPACE_CHANGE, this.align, this);
                this.align();
            }
        }
        this.checkHideUnder();
    };
    p.align = function(event) {
        if (this.detached) {
            return;
        }
        var align = this.options.align;
        var pos = this.slider.reserveSpace(align, this.options.margin * 2 + this.options.width);
        this.$element.css(align, -pos - this.options.margin - this.options.width);
    };
    p.create = function() {
        _super.create.call(this);
        this.slider.api.addEventListener(MSSliderEvent.WAITING, this._update, this);
        this._update();
    };
    p._update = function() {
        this.$bar[0].style.width = this.slider.api._delayProgress + "%";
    };
    p.destroy = function() {
        _super.destroy();
        this.slider.api.removeEventListener(MSSliderEvent.RESERVED_SPACE_CHANGE, this.align, this);
        this.slider.api.removeEventListener(MSSliderEvent.WAITING, this._update, this);
        this.$element.remove();
    };
    window.MSTimerbar = MSTimerbar;
    MSSlideController.registerControl("timebar", MSTimerbar);
})(jQuery);

(function($) {
    "use strict";
    var MSCircleTimer = function(options) {
        BaseControl.call(this);
        this.options.color = "#A2A2A2";
        this.options.stroke = 10;
        this.options.radius = 4;
        this.options.autohide = false;
        $.extend(this.options, options);
    };
    MSCircleTimer.extend(BaseControl);
    var p = MSCircleTimer.prototype;
    var _super = BaseControl.prototype;
    p.setup = function() {
        var that = this;
        _super.setup.call(this);
        this.$element = $("<div></div>").addClass(this.options.prefix + "ctimer").appendTo(this.cont);
        this.$canvas = $("<canvas></canvas>").addClass("ms-ctimer-canvas").appendTo(this.$element);
        this.$bar = $("<div></div>").addClass("ms-ctimer-bullet").appendTo(this.$element);
        if (!this.$canvas[0].getContext) {
            this.destroy();
            this.disable = true;
            return;
        }
        this.ctx = this.$canvas[0].getContext("2d");
        this.prog = 0;
        this.__w = (this.options.radius + this.options.stroke / 2) * 2;
        this.$canvas[0].width = this.__w;
        this.$canvas[0].height = this.__w;
        this.checkHideUnder();
    };
    p.create = function() {
        if (this.disable) return;
        _super.create.call(this);
        this.slider.api.addEventListener(MSSliderEvent.WAITING, this._update, this);
        var that = this;
        this.$element.click(function() {
            if (that.slider.api.paused) that.slider.api.resume(); else that.slider.api.pause();
        });
        this._update();
    };
    p._update = function() {
        var that = this;
        $(this).stop(true).animate({
            prog: this.slider.api._delayProgress * .01
        }, {
            duration: 200,
            step: function() {
                that._draw();
            }
        });
    };
    p._draw = function() {
        this.ctx.clearRect(0, 0, this.__w, this.__w);
        this.ctx.beginPath();
        this.ctx.arc(this.__w * .5, this.__w * .5, this.options.radius, Math.PI * 1.5, Math.PI * 1.5 + 2 * Math.PI * this.prog, false);
        this.ctx.strokeStyle = this.options.color;
        this.ctx.lineWidth = this.options.stroke;
        this.ctx.stroke();
    };
    p.destroy = function() {
        _super.destroy();
        if (this.disable) return;
        $(this).stop(true);
        this.slider.api.removeEventListener(MSSliderEvent.WAITING, this._update, this);
        this.$element.remove();
    };
    window.MSCircleTimer = MSCircleTimer;
    MSSlideController.registerControl("circletimer", MSCircleTimer);
})(jQuery);

(function($) {
    "use strict";
    window.MSLightbox = function(options) {
        BaseControl.call(this, options);
        this.options.autohide = false;
        $.extend(this.options, options);
        this.data_list = [];
    };
    MSLightbox.fadeDuratation = 400;
    MSLightbox.extend(BaseControl);
    var p = MSLightbox.prototype;
    var _super = BaseControl.prototype;
    p.setup = function() {
        _super.setup.call(this);
        this.$element = $("<div></div>").addClass(this.options.prefix + "lightbox-btn").appendTo(this.cont);
        this.checkHideUnder();
    };
    p.slideAction = function(slide) {
        $("<div></div>").addClass(this.options.prefix + "lightbox-btn").appendTo(slide.$element).append($(slide.$element.find(".ms-lightbox")));
    };
    p.create = function() {
        _super.create.call(this);
    };
    MSSlideController.registerControl("lightbox", MSLightbox);
})(jQuery);

(function($) {
    "use strict";
    window.MSSlideInfo = function(options) {
        BaseControl.call(this, options);
        this.options.autohide = false;
        this.options.align = null;
        this.options.inset = false;
        this.options.margin = 10;
        this.options.size = 100;
        this.options.dir = "h";
        $.extend(this.options, options);
        this.data_list = [];
    };
    MSSlideInfo.fadeDuratation = 400;
    MSSlideInfo.extend(BaseControl);
    var p = MSSlideInfo.prototype;
    var _super = BaseControl.prototype;
    p.setup = function() {
        this.$element = $("<div></div>").addClass(this.options.prefix + "slide-info").addClass("ms-dir-" + this.options.dir);
        _super.setup.call(this);
        if (this.slider.$controlsCont === this.cont) {
            this.$element.appendTo(this.slider.$element);
        } else {
            this.$element.appendTo(this.cont);
        }
        if (!this.options.insetTo && this.options.align) {
            var align = this.options.align;
            if (this.options.inset) {
                this.$element.css(align, this.options.margin);
            } else if (align === "top") {
                this.$element.prependTo(this.slider.$element).css({
                    "margin-bottom": this.options.margin,
                    position: "relative"
                });
            } else if (align === "bottom") {
                this.$element.css({
                    "margin-top": this.options.margin,
                    position: "relative"
                });
            } else {
                this.slider.api.addEventListener(MSSliderEvent.RESERVED_SPACE_CHANGE, this.align, this);
                this.align();
            }
            if (this.options.dir === "v") {
                this.$element.width(this.options.size);
            } else {
                this.$element.css("min-height", this.options.size);
            }
        }
        this.checkHideUnder();
    };
    p.align = function(event) {
        if (this.detached) {
            return;
        }
        var align = this.options.align;
        var pos = this.slider.reserveSpace(align, this.options.size + this.options.margin * 2);
        this.$element.css(align, -pos - this.options.size - this.options.margin);
    };
    p.slideAction = function(slide) {
        var info_ele = $(slide.$element.find(".ms-info"));
        var that = this;
        info_ele.detach();
        this.data_list[slide.index] = info_ele;
    };
    p.create = function() {
        _super.create.call(this);
        this.slider.api.addEventListener(MSSliderEvent.CHANGE_START, this.update, this);
        this.cindex = this.slider.api.index();
        this.switchEle(this.data_list[this.cindex]);
    };
    p.update = function() {
        var nindex = this.slider.api.index();
        this.switchEle(this.data_list[nindex]);
        this.cindex = nindex;
    };
    p.switchEle = function(ele) {
        if (this.current_ele) {
            var that = this;
            if (this.current_ele[0].tween) this.current_ele[0].tween.stop(true);
            this.current_ele[0].tween = CTween.animate(this.current_ele, MSSlideInfo.fadeDuratation, {
                opacity: 0
            }, {
                complete: function() {
                    this.detach();
                    this[0].tween = null;
                    ele.css("position", "relative");
                },
                target: this.current_ele
            });
            ele.css("position", "absolute");
        }
        this.__show(ele);
    };
    p.__show = function(ele) {
        ele.appendTo(this.$element).css("opacity", "0");
        if (this.current_ele) {
            ele.height(Math.max(ele.height(), this.current_ele.height()));
        }
        clearTimeout(this.tou);
        this.tou = setTimeout(function() {
            CTween.fadeIn(ele, MSSlideInfo.fadeDuratation);
            ele.css("height", "");
        }, MSSlideInfo.fadeDuratation);
        if (ele[0].tween) ele[0].tween.stop(true);
        this.current_ele = ele;
    };
    p.destroy = function() {
        _super.destroy();
        clearTimeout(this.tou);
        if (this.current_ele && this.current_ele[0].tween) {
            this.current_ele[0].tween.stop("true");
        }
        this.$element.remove();
        this.slider.api.removeEventListener(MSSliderEvent.RESERVED_SPACE_CHANGE, this.align, this);
        this.slider.api.removeEventListener(MSSliderEvent.CHANGE_START, this.update, this);
    };
    MSSlideController.registerControl("slideinfo", MSSlideInfo);
})(jQuery);

(function($) {
    window.MSGallery = function(id, slider) {
        this.id = id;
        this.slider = slider;
        this.telement = $("#" + id);
        this.botcont = $("<div></div>").addClass("ms-gallery-botcont").appendTo(this.telement);
        this.thumbcont = $("<div></div>").addClass("ms-gal-thumbcont hide-thumbs").appendTo(this.botcont);
        this.playbtn = $("<div></div>").addClass("ms-gal-playbtn").appendTo(this.botcont);
        this.thumbtoggle = $("<div></div>").addClass("ms-gal-thumbtoggle").appendTo(this.botcont);
        slider.control("thumblist", {
            insertTo: this.thumbcont,
            autohide: false,
            dir: "h"
        });
        slider.control("slidenum", {
            insertTo: this.botcont,
            autohide: false
        });
        slider.control("slideinfo", {
            insertTo: this.botcont,
            autohide: false
        });
        slider.control("timebar", {
            insertTo: this.botcont,
            autohide: false
        });
        slider.control("bullets", {
            insertTo: this.botcont,
            autohide: false
        });
    };
    var p = MSGallery.prototype;
    p._init = function() {
        var that = this;
        if (!this.slider.api.paused) this.playbtn.addClass("btn-pause");
        this.playbtn.click(function() {
            if (that.slider.api.paused) {
                that.slider.api.resume();
                that.playbtn.addClass("btn-pause");
            } else {
                that.slider.api.pause();
                that.playbtn.removeClass("btn-pause");
            }
        });
        this.thumbtoggle.click(function() {
            if (that.vthumbs) {
                that.thumbtoggle.removeClass("btn-hide");
                that.vthumbs = false;
                that.thumbcont.addClass("hide-thumbs");
            } else {
                that.thumbtoggle.addClass("btn-hide");
                that.thumbcont.removeClass("hide-thumbs");
                that.vthumbs = true;
            }
        });
    };
    p.setup = function() {
        var that = this;
        $(document).ready(function() {
            that._init();
        });
    };
})(jQuery);

(function($) {
    var getPhotosetURL = function(key, id, count) {
        return "https://api.flickr.com/services/rest/?method=flickr.photosets.getPhotos&api_key=" + key + "&photoset_id=" + id + "&per_page=" + count + "&extras=url_o,description,date_taken,owner_name,views&format=json&jsoncallback=?";
    };
    var getUserPublicURL = function(key, id, count) {
        return "https://api.flickr.com/services/rest/?&method=flickr.people.getPublicPhotos&api_key=" + key + "&user_id=" + id + "&per_page=" + count + "&extras=url_o,description,date_taken,owner_name,views&format=json&jsoncallback=?";
    };
    var getImageSource = function(fid, server, id, secret, size, data) {
        if (size === "_o" && data) {
            return data.url_o;
        }
        return "https://farm" + fid + ".staticflickr.com/" + server + "/" + id + "_" + secret + size + ".jpg";
    };
    window.MSFlickrV2 = function(slider, options) {
        var _options = {
            count: 10,
            type: "photoset",
            thumbSize: "q",
            imgSize: "c"
        };
        this.slider = slider;
        this.slider.holdOn();
        if (!options.key) {
            this.errMsg("Flickr API Key required. Please add it in settings.");
            return;
        }
        $.extend(_options, options);
        this.options = _options;
        var that = this;
        if (this.options.type === "photoset") {
            $.getJSON(getPhotosetURL(this.options.key, this.options.id, this.options.count), function(data) {
                that._photosData(data);
            });
        } else {
            $.getJSON(getUserPublicURL(this.options.key, this.options.id, this.options.count), function(data) {
                that.options.type = "photos";
                that._photosData(data);
            });
        }
        if (this.options.imgSize !== "" && this.options.imgSize !== "-") this.options.imgSize = "_" + this.options.imgSize;
        this.options.thumbSize = "_" + this.options.thumbSize;
        this.slideTemplate = this.slider.$element.find(".ms-slide")[0].outerHTML;
        this.slider.$element.find(".ms-slide").remove();
    };
    var p = MSFlickrV2.prototype;
    p._photosData = function(data) {
        if (data.stat === "fail") {
            this.errMsg("Flickr API ERROR#" + data.code + ": " + data.message);
            return;
        }
        var that = this;
        var getInfo = this.options.author || this.options.desc;
        $.each(data[this.options.type].photo, function(i, item) {
            var slide_cont = that.slideTemplate.replace(/{{[\w-]+}}/g, function(match) {
                match = match.replace(/{{|}}/g, "");
                if (shortCodes[match]) {
                    return shortCodes[match](item, that);
                } else {
                    return "{{" + match + "}}";
                }
            });
            $(slide_cont).appendTo(that.slider.$element);
        });
        that._initSlider();
    };
    p.errMsg = function(msg) {
        this.slider.$element.css("display", "block");
        if (!this.errEle) this.errEle = $('<div style="font-family:Arial; color:red; font-size:12px; position:absolute; top:10px; left:10px"></div>').appendTo(this.slider.$loading);
        this.errEle.html(msg);
    };
    p._initSlider = function() {
        this.slider.release();
    };
    var shortCodes = {
        image: function(data, that) {
            return getImageSource(data.farm, data.server, data.id, data.secret, that.options.imgSize, data);
        },
        thumb: function(data, that) {
            return getImageSource(data.farm, data.server, data.id, data.secret, that.options.thumbSize);
        },
        title: function(data, that) {
            return data.title;
        },
        "owner-name": function(data, that) {
            return data.ownername;
        },
        "date-taken": function(data, that) {
            return data.datetaken;
        },
        views: function(data, that) {
            return data.views;
        },
        description: function(data, that) {
            return data.description._content;
        }
    };
})(jQuery);

(function($) {
    window.MSFacebookGallery = function(slider, options) {
        var _options = {
            count: 10,
            type: "photostream",
            thumbSize: "320",
            imgSize: "orginal",
            https: false,
            token: ""
        };
        this.slider = slider;
        this.slider.holdOn();
        $.extend(_options, options);
        this.options = _options;
        this.graph = "https://graph.facebook.com";
        var that = this;
        if (this.options.type === "photostream") {
            $.getJSON(this.graph + "/" + this.options.username + "/photos/uploaded/?fields=source,name,link,images,from&limit=" + this.options.count + "&access_token=" + this.options.token, function(data) {
                that._photosData(data);
            });
        } else {
            $.getJSON(this.graph + "/" + this.options.albumId + "/photos?fields=source,name,link,images,from&limit=" + this.options.count + "&access_token=" + this.options.token, function(data) {
                that._photosData(data);
            });
        }
        this.slideTemplate = this.slider.$element.find(".ms-slide")[0].outerHTML;
        this.slider.$element.find(".ms-slide").remove();
    };
    var p = MSFacebookGallery.prototype;
    p._photosData = function(content) {
        if (content.error) {
            this.errMsg("Facebook API ERROR#" + content.error.code + "(" + content.error.type + ")" + ": " + content.error.message);
            return;
        }
        var that = this;
        var getInfo = this.options.author || this.options.desc;
        for (var i = 0, l = content.data.length; i !== l; i++) {
            var slide_cont = that.slideTemplate.replace(/{{[\w-]+}}/g, function(match) {
                match = match.replace(/{{|}}/g, "");
                if (shortCodes[match]) {
                    return shortCodes[match](content.data[i], that);
                } else {
                    return "{{" + match + "}}";
                }
            });
            $(slide_cont).appendTo(that.slider.$element);
        }
        that._initSlider();
    };
    p.errMsg = function(msg) {
        this.slider.$element.css("display", "block");
        if (!this.errEle) this.errEle = $('<div style="font-family:Arial; color:red; font-size:12px; position:absolute; top:10px; left:10px"></div>').appendTo(this.slider.$loading);
        this.errEle.html(msg);
    };
    p._initSlider = function() {
        this.slider.release();
    };
    var getImageSource = function(images, size) {
        if (size === "orginal") {
            return images[0].source;
        }
        for (var i = 0, l = images.length; i !== l; i++) {
            if (images[i].source.indexOf(size + "x" + size) !== -1) return images[i].source;
        }
        return images[0].source;
    };
    var shortCodes = {
        image: function(data, that) {
            return getImageSource(data.images, that.options.imgSize);
        },
        thumb: function(data, that) {
            return getImageSource(data.images, that.options.thumbSize);
        },
        name: function(data, that) {
            return data.name;
        },
        "owner-name": function(data, that) {
            return data.from.name;
        },
        link: function(data, that) {
            return data.link;
        }
    };
})(jQuery);

(function($) {
    "use strict";
    window.MSScrollParallax = function(slider, parallax, bgparallax, fade) {
        this.fade = fade;
        this.slider = slider;
        this.parallax = parallax / 100;
        this.bgparallax = bgparallax / 100;
        slider.api.addEventListener(MSSliderEvent.INIT, this.init, this);
        slider.api.addEventListener(MSSliderEvent.DESTROY, this.destory, this);
        slider.api.addEventListener(MSSliderEvent.CHANGE_END, this.resetLayers, this);
        slider.api.addEventListener(MSSliderEvent.CHANGE_START, this.updateCurrentSlide, this);
    };
    window.MSScrollParallax.setup = function(slider, parallax, bgparallax, fade) {
        if (window._mobile) {
            return;
        }
        if (parallax == null) {
            parallax = 50;
        }
        if (bgparallax == null) {
            bgparallax = 40;
        }
        return new MSScrollParallax(slider, parallax, bgparallax, fade);
    };
    var p = window.MSScrollParallax.prototype;
    p.init = function(e) {
        this.slider.$element.addClass("ms-scroll-parallax");
        this.sliderOffset = this.slider.$element.offset().top;
        this.updateCurrentSlide();
        var slides = this.slider.api.view.slideList, slide;
        for (var i = 0, l = slides.length; i !== l; i++) {
            slide = slides[i];
            if (slide.hasLayers) {
                slide.layerController.$layers.wrap('<div class="ms-scroll-parallax-cont"></div>');
                slide.$scrollParallaxCont = slide.layerController.$layers.parent();
            }
        }
        $(window).on("scroll", {
            that: this
        }, this.moveParallax).trigger("scroll");
    };
    p.resetLayers = function(e) {
        if (!this.lastSlide) {
            return;
        }
        var layers = this.lastSlide.$scrollParallaxCont;
        if (window._css2d) {
            if (layers) {
                layers[0].style[window._jcsspfx + "Transform"] = "";
            }
            if (this.lastSlide.hasBG) {
                this.lastSlide.$imgcont[0].style[window._jcsspfx + "Transform"] = "";
            }
        } else {
            if (layers) {
                layers[0].style.top = "";
            }
            if (this.lastSlide.hasBG) {
                this.lastSlide.$imgcont[0].style.top = "0px";
            }
        }
    };
    p.updateCurrentSlide = function(e) {
        this.lastSlide = this.currentSlide;
        this.currentSlide = this.slider.api.currentSlide;
        this.moveParallax({
            data: {
                that: this
            }
        });
    };
    p.moveParallax = function(e) {
        var that = e.data.that, slider = that.slider, offset = that.sliderOffset, scrollTop = $(window).scrollTop(), layers = that.currentSlide.$scrollParallaxCont, out = offset - scrollTop;
        if (out <= 0) {
            if (layers) {
                if (window._css3d) {
                    layers[0].style[window._jcsspfx + "Transform"] = "translateY(" + -out * that.parallax + "px) translateZ(0.4px)";
                } else if (window._css2d) {
                    layers[0].style[window._jcsspfx + "Transform"] = "translateY(" + -out * that.parallax + "px)";
                } else {
                    layers[0].style.top = -out * that.parallax + "px";
                }
            }
            that.updateSlidesBG(-out * that.bgparallax + "px", true);
            if (layers && that.fade) {
                layers.css("opacity", 1 - Math.min(1, -out / slider.api.height));
            }
        } else {
            if (layers) {
                if (window._css2d) {
                    layers[0].style[window._jcsspfx + "Transform"] = "";
                } else {
                    layers[0].style.top = "";
                }
            }
            that.updateSlidesBG("0px", false);
            if (layers && that.fade) {
                layers.css("opacity", 1);
            }
        }
    };
    p.updateSlidesBG = function(pos, fixed) {
        var slides = this.slider.api.view.slideList, position = fixed && !$.browser.msie && !$.browser.opera ? "fixed" : "";
        for (var i = 0, l = slides.length; i !== l; i++) {
            if (slides[i].hasBG) {
                slides[i].$imgcont[0].style.position = position;
                slides[i].$imgcont[0].style.top = pos;
            }
            if (slides[i].$bgvideocont) {
                slides[i].$bgvideocont[0].style.position = position;
                slides[i].$bgvideocont[0].style.top = pos;
            }
        }
    };
    p.destory = function() {
        slider.api.removeEventListener(MSSliderEvent.INIT, this.init, this);
        slider.api.removeEventListener(MSSliderEvent.DESTROY, this.destory, this);
        slider.api.removeEventListener(MSSliderEvent.CHANGE_END, this.resetLayers, this);
        slider.api.removeEventListener(MSSliderEvent.CHANGE_START, this.updateCurrentSlide, this);
        $(window).off("scroll", this.moveParallax);
    };
})(jQuery);

(function($, document, window) {
    var PId = 0;
    if (!window.MasterSlider) {
        return;
    }
    var KeyboardNav = function(slider) {
        this.slider = slider;
        this.PId = PId++;
        if (this.slider.options.keyboard) {
            slider.api.addEventListener(MSSliderEvent.INIT, this.init, this);
        }
    };
    KeyboardNav.name = "MSKeyboardNav";
    var p = KeyboardNav.prototype;
    p.init = function() {
        var api = this.slider.api;
        $(document).on("keydown.kbnav" + this.PId, function(event) {
            var which = event.which;
            if (which === 37 || which === 40) {
                api.previous(true);
            } else if (which === 38 || which === 39) {
                api.next(true);
            }
        });
    };
    p.destroy = function() {
        $(document).off("keydown.kbnav" + this.PId);
        this.slider.api.removeEventListener(MSSliderEvent.INIT, this.init, this);
    };
    MasterSlider.registerPlugin(KeyboardNav);
})(jQuery, document, window);

(function($, document, window) {
    var PId = 0, $window = $(window), $doc = $(document);
    if (!window.MasterSlider) {
        return;
    }
    var StartOnAppear = function(slider) {
        this.PId = PId++;
        this.slider = slider;
        this.$slider = slider.$element;
        if (this.slider.options.startOnAppear) {
            slider.holdOn();
            $doc.ready($.proxy(this.init, this));
        }
    };
    StartOnAppear.name = "MSStartOnAppear";
    var p = StartOnAppear.prototype;
    p.init = function() {
        var api = this.slider.api;
        $window.on("scroll.soa" + this.PId, $.proxy(this._onScroll, this)).trigger("scroll");
    };
    p._onScroll = function() {
        var vpBottom = $window.scrollTop() + $window.height(), top = this.$slider.offset().top;
        if (top < vpBottom) {
            $window.off("scroll.soa" + this.PId);
            this.slider.release();
        }
    };
    p.destroy = function() {};
    MasterSlider.registerPlugin(StartOnAppear);
})(jQuery, document, window);

(function(document, window, jQuery) {
    var filterUnits = {
        "hue-rotate": "deg",
        blur: "px"
    }, initialValues = {
        opacity: 1,
        contrast: 1,
        brightness: 1,
        saturate: 1,
        "hue-rotate": 0,
        invert: 0,
        sepia: 0,
        blur: 0,
        grayscale: 0
    };
    if (!window.MasterSlider) {
        return;
    }
    var Filters = function(slider) {
        this.slider = slider;
        if (this.slider.options.filters) {
            slider.api.addEventListener(MSSliderEvent.INIT, this.init, this);
        }
    };
    Filters.name = "MSFilters";
    var p = Filters.prototype;
    p.init = function() {
        var api = this.slider.api, view = api.view;
        this.filters = this.slider.options.filters;
        this.slideList = view.slideList;
        this.slidesCount = view.slidesCount;
        this.dimension = view[view.__dimension];
        this.target = this.slider.options.filterTarget === "slide" ? "$element" : "$bg_img";
        this.filterName = $.browser.webkit ? "WebkitFilter" : "filter";
        var superFun = view.controller.__renderHook.fun, superRef = view.controller.__renderHook.ref;
        view.controller.renderCallback(function(controller, value) {
            superFun.call(superRef, controller, value);
            this.applyEffect(value);
        }, this);
        this.applyEffect(view.controller.value);
    };
    p.applyEffect = function(value) {
        var factor, slide;
        for (var i = 0; i < this.slidesCount; ++i) {
            slide = this.slideList[i];
            factor = Math.min(1, Math.abs(value - slide.position) / this.dimension);
            if (slide[this.target]) {
                if (!$.browser.msie) {
                    slide[this.target][0].style[this.filterName] = this.generateStyle(factor);
                } else if (this.filters.opacity != null) {
                    slide[this.target].opacity(1 - this.filters.opacity * factor);
                }
            }
        }
    };
    p.generateStyle = function(factor) {
        var style = "", unit;
        for (var filter in this.filters) {
            unit = filterUnits[filter] || "";
            style += filter + "(" + (initialValues[filter] + (this.filters[filter] - initialValues[filter]) * factor) + ") ";
        }
        return style;
    };
    p.destroy = function() {
        this.slider.api.removeEventListener(MSSliderEvent.INIT, this.init, this);
    };
    MasterSlider.registerPlugin(Filters);
})(document, window, jQuery);

(function($, document, window) {
    if (!window.MasterSlider) {
        return;
    }
    var ScrollToAction = function(slider) {
        this.slider = slider;
        slider.api.addEventListener(MSSliderEvent.INIT, this.init, this);
    };
    ScrollToAction.name = "MSScrollToAction";
    var p = ScrollToAction.prototype;
    p.init = function() {
        var api = this.slider.api;
        api.scrollToEnd = _scrollToEnd;
        api.scrollTo = _scrollTo;
    };
    p.destroy = function() {};
    var _scrollTo = function(target, duration) {
        var sliderEle = this.slider.$element, target = $(target).eq(0);
        if (target.length === 0) {
            return;
        }
        console.log(target.offset().top, duration);
        if (duration == null) {
            duration = 1.4;
        }
        $("html, body").animate({
            scrollTop: target.offset().top
        }, duration * 1e3, "easeInOutQuad");
    };
    var _scrollToEnd = function(duration) {
        var sliderEle = this.slider.$element;
        if (duration == null) {
            duration = 1.4;
        }
        $("html, body").animate({
            scrollTop: sliderEle.offset().top + sliderEle.outerHeight(false)
        }, duration * 1e3, "easeInOutQuad");
    };
    MasterSlider.registerPlugin(ScrollToAction);
})(jQuery, document, window);

jQuery(document).ready(function($) {
    var defaultRangeValidator = jQuery.validator.methods.range;
    $.validator.methods.range = function(value, element, param) {
        if (element.type === "checkbox") {
            return element.checked;
        } else if ($(element).attr("data-val-date")) {
            var min = $(element).attr("data-val-range-min");
            var max = $(element).attr("data-val-range-max");
            var date = new Date(value).getTime();
            var minDate = new Date(min).getTime();
            var maxDate = new Date(max).getTime();
            return this.optional(element) || date >= minDate && date <= maxDate;
        } else {
            return defaultRangeValidator.call(this, value, element, param);
        }
    };
    $(document).on("invalid-form.validate", "form", function() {
        var button = $(this).find('.form-button-container input[type="submit"]');
        setTimeout(function() {
            button.removeAttr("disabled");
        }, 1);
    });
    $(document).on("submit", "form", function() {
        var button = $(this).find('.form-button-container input[type="submit"]');
        setTimeout(function() {
            button.attr("disabled", "disabled");
        }, 0);
    });
    if ($(".datepicker").length) {
        $(".datepicker").datepicker({
            changeMonth: true,
            changeYear: true,
            yearRange: "-100:+100"
        });
    }
});

(function($) {
    jQuery.fn.jqueryAccordion = function(options) {
        var settings = {
            interval: 400,
            fadeContent: false,
            open: false,
            defaultOpenIndex: 1,
            clickOutToClose: false
        };
        $.extend(settings, options);
        var accordion = $(this);
        if (settings.open == true) {
            $(accordion).children(".accordion-item:nth-child(" + settings.defaultOpenIndex + ")").children(".accordion-header").addClass("opened focus");
            $(accordion).children(".accordion-item:nth-child(" + settings.defaultOpenIndex + ")").children(".accordion-content").show(0);
        }
        $(accordion).children(".accordion-item").children(".accordion-header").bind("click", function() {
            if ($(this).siblings(".accordion-content").is(":hidden")) {
                if (settings.fadeContent == true) {
                    $(accordion).children(".accordion-item").children(".accordion-content").children().animate({
                        opacity: 0
                    }, 0);
                }
                $(accordion).children(".accordion-item").children(".accordion-header").removeClass("opened focus");
                $(accordion).children(".accordion-item").children(".accordion-content").slideUp(settings.interval);
                $(this).siblings(".accordion-content").slideDown(settings.interval);
                $(this).addClass("opened focus");
                if (settings.fadeContent == true) {
                    var time = 0;
                    for (var i = 1; i < $(this).siblings(".accordion-content").children().length + 1; i++) {
                        $(this).siblings(".accordion-content").children(":nth-child(" + i + ")").delay(settings.interval + time).animate({
                            opacity: 1
                        }, 300);
                        time = time + 100;
                    }
                }
            } else {
                $(this).siblings(".accordion-content").slideUp(settings.interval);
                $(this).removeClass("opened focus");
            }
        });
        if (settings.clickOutToClose) {
            $(document).bind("click", function(ev) {
                if ($(ev.target).closest(accordion).length == 0) {
                    $(accordion).find(".accordion-content").slideUp(settings.interval);
                }
            });
        }
    };
})(jQuery);

$(document).ready(function() {
    if ($(".divRoadMapContent").length) {
        $(".roadMapCertTile").click(function(e) {
            if ($(window).innerWidth() > 500) {
                if ($(e.target).is("a") === false) {
                    if ($(this).hasClass("readMore")) {
                        $(this).removeClass("readMore");
                    } else {
                        $(this).addClass("readMore");
                    }
                }
            }
        });
        $(window).resize(function() {
            if ($(window).innerWidth() < 500) {
                setTimeout(function() {
                    $container.isotope();
                }, 2e3);
            }
        });
        var $container = $(".roadMapCertificationTiles").isotope({
            itemSelector: ".roadMapCertTile",
            layoutMode: "fitRows"
        });
        var levels = $(".levels").val("*");
        var providers = $(".providers").val("*");
        var selects = $(".filters select");
        selects.on("change", function() {
            var filters = "";
            if (levels.val() === "*" && providers.val() === "*") {
                filters = "*";
            } else {
                filters = filters + levels.val();
                filters = filters + providers.val();
            }
            $container.isotope({
                filter: filters
            });
        });
    }
});

$(function() {
    var images = [ "https://comptiacdn.azureedge.net/webcontent/images/default-source/researchreports/careerroadmap/person1.png", "https://comptiacdn.azureedge.net/webcontent/images/default-source/researchreports/careerroadmap/person2.png", "https://comptiacdn.azureedge.net/webcontent/images/default-source/researchreports/careerroadmap/person3.png", "https://comptiacdn.azureedge.net/webcontent/images/default-source/researchreports/careerroadmap/person4.png", "https://comptiacdn.azureedge.net/webcontent/images/default-source/researchreports/careerroadmap/person5.png?sfvrsn=f2531cc_4", "https://comptiacdn.azureedge.net/webcontent/images/default-source/researchreports/careerroadmap/person6.png", "https://comptiacdn.azureedge.net/webcontent/images/default-source/researchreports/careerroadmap/person7.png", "https://comptiacdn.azureedge.net/webcontent/images/default-source/researchreports/careerroadmap/person8.png", "https://comptiacdn.azureedge.net/webcontent/images/default-source/researchreports/careerroadmap/person9.png", "https://comptiacdn.azureedge.net/webcontent/images/default-source/researchreports/careerroadmap/person10.png?sfvrsn=96d186e5_8", "https://comptiacdn.azureedge.net/webcontent/images/default-source/researchreports/careerroadmap/person11.png?sfvrsn=e4e8b031_4", "https://comptiacdn.azureedge.net/webcontent/images/default-source/researchreports/careerroadmap/person12.png?sfvrsn=56814065_4" ];
    shuffleArray(images);
    for (var i = 0; i <= 4; i++) {
        $(".roadMap.showOnDesktop").find(".person").eq(i).find("img").attr("src", images[i]);
        $(".roadMap.hideOnDesktop").find(".person").eq(i).find("img").attr("src", images[i]);
    }
    function shuffleArray(array) {
        for (var i = array.length - 1; i > 0; i--) {
            var j = Math.floor(Math.random() * (i + 1));
            var temp = array[i];
            array[i] = array[j];
            array[j] = temp;
        }
    }
    $(".roadMap .categoryBox").click(function(e) {
        if ($(e.target).is("a")) {
            return;
        }
        if ($(this).hasClass("ignoreOnMobile")) {
            return;
        }
        var clickedBox = $(this);
        if (clickedBox.hasClass("closed")) {
            clickedBox.find(".content").show(200, function() {
                clickedBox.removeClass("closed");
                clickedBox.addClass("open");
                var Salary = new CountUp(clickedBox.find("#Salary")[0], 0, clickedBox.find("#Salary").attr("value"), "", 1, {
                    prefix: "$"
                });
                var Openings = new CountUp(clickedBox.find("#Openings")[0], 0, clickedBox.find("#Openings").attr("value"), "", 1, {
                    suffix: "+"
                });
                var Growth = new CountUp(clickedBox.find("#Growth")[0], 0, clickedBox.find("#Growth").attr("value"), "", 1, {
                    suffix: "%"
                });
                Salary.start();
                Openings.start();
                Growth.start();
            });
        } else {
            clickedBox.find(".content").hide(200, function() {
                clickedBox.addClass("closed");
                clickedBox.removeClass("open");
            });
        }
    });
    var $el = $("#roadMapSlider");
    if ($el.length) {
        var slider = new MasterSlider();
        slider.setup("roadMapSlider", {
            space: 5,
            autoplay: false,
            loop: false,
            layout: "partialview",
            autoHeight: true,
            fullwidth: false,
            fillMode: "center",
            width: 300,
            start: 1
        });
        slider.control("bullets", {
            autohide: false,
            dir: "h",
            align: "bottom"
        });
    }
    $(".roadMap map").imageMapResize();
    $(".roadMap .pathMap area").tooltip({
        track: true,
        position: {
            my: "center bottom-10",
            at: "center top"
        },
        content: function() {
            return $(this).prop("title");
        },
        tooltipClass: "roadMap"
    });
    $(".roadMap .numOfCertsCircle").hover(function() {
        $(this).find(".levelToolTip").fadeIn(200);
    }, function() {
        $(this).find(".levelToolTip").fadeOut(200);
    });
    $(".roadMap .mobilePathList .header").on("click", function() {
        if ($(".mobilePathList .content").is(":visible")) {
            $(".header .far").removeClass("fa-chevron-up").addClass("fa-chevron-down");
            $(".mobilePathList .content").slideUp(400);
        } else {
            $(".header .far").removeClass("fa-chevron-down").addClass("fa-chevron-up");
            $(".mobilePathList .content").slideDown(400);
        }
    });
    $(".roadMap table.levelTable #Beginner").on("click", function() {
        if ($(".row.beginner").is(":hidden")) {
            $(".levelTableSection").removeClass("intermediate").removeClass("advanced").addClass("beginner");
            $("table.levelTable").removeClass("intermediate").removeClass("advanced").addClass("beginner");
            $(".beginner").fadeIn();
            $(".intermediate, .advanced").hide();
            animateLevelTableMobileBeginner();
            $(".levelTableContentMobile .advanced, .levelTableContentMobile .intermediate").find(".open").removeClass("open");
        }
    });
    $(".roadMap table.levelTable #Intermediate").on("click", function() {
        if ($(".row.intermediate").is(":hidden")) {
            $(".levelTableSection").removeClass("beginner").removeClass("advanced").addClass("intermediate");
            $("table.levelTable").removeClass("beginner").removeClass("advanced").addClass("intermediate");
            $(".intermediate").fadeIn();
            $(".beginner, .advanced").hide();
            animateLevelTableMobileIntermediate();
            $(".levelTableContentMobile .beginner, .levelTableContentMobile .advanced").find(".open").removeClass("open");
        }
    });
    $(".roadMap table.levelTable #Advanced").on("click", function() {
        if ($(".row.advanced").is(":hidden")) {
            $(".levelTableSection").removeClass("beginner").removeClass("intermediate").addClass("advanced");
            $("table.levelTable").removeClass("beginner").removeClass("intermediate").addClass("advanced");
            $(".advanced").fadeIn();
            $(".beginner, .intermediate").hide();
            animateLevelTableMobileAdvanced();
            $(".levelTableContentMobile .beginner, .levelTableContentMobile .intermediate").find(".open").removeClass("open");
        }
    });
    $(".roadMap .continue").on("click", function() {
        if ($(this).text().indexOf("Beginner") >= 0) {
            $("table.levelTable #Beginner")[0].click();
            $("html, body").animate({
                scrollTop: $(".levelTableSection").offset().top
            }, 500);
        }
        if ($(this).text().indexOf("Intermediate") >= 0) {
            $("table.levelTable #Intermediate")[0].click();
            $("html, body").animate({
                scrollTop: $(".levelTableSection").offset().top
            }, 500);
        }
        if ($(this).text().indexOf("Advanced") >= 0) {
            $("table.levelTable #Advanced")[0].click();
            $("html, body").animate({
                scrollTop: $(".levelTableSection").offset().top
            }, 500);
        }
    });
    $(".roadMap .showMore").click(function() {
        $("html, body").animate({
            scrollTop: $(".pathMap:visible").offset().top
        }, 500);
    });
    var currentPath = $(".pathTabs ul.showOnDesktop li.selected a").text();
    var otherPaths = "";
    $(".pathTabs ul.showOnDesktop li:not(.selected)").each(function(i, obj) {
        if (i !== 0) {
            otherPaths += $(this).html().replace("<br>", "").replace("<br />", "");
        }
    });
    $(".pathTabs .mobilePathList .header h5").text(currentPath);
    $(".pathTabs .mobilePathList .content").html(otherPaths);
    var beginner = '<div class="beginner">';
    beginner += "<p>" + $("tr:nth-child(2) td:nth-child(1)").html() + "</p>";
    beginner += "<p>" + $("tr:nth-child(2) td:nth-child(2)").html() + "</p>";
    beginner += "<p>" + $("tr:nth-child(3) td:nth-child(1)").html() + "</p>";
    beginner += "<p>" + $("tr:nth-child(3) td:nth-child(2)").html() + "</p>";
    beginner += "<p>" + $("tr:nth-child(4) td:nth-child(1) span:first-child").text() + "</p>";
    beginner += "<p>" + $("tr:nth-child(4) td:nth-child(2)").html() + "</p>";
    beginner += "<p>" + $("tr:nth-child(4) td:nth-child(1) span:nth-child(2)").text() + "</p>";
    beginner += "</div>";
    var intermediate = '<div class="intermediate">';
    intermediate += "<p>" + $("tr:nth-child(2) td:nth-child(1)").html() + "</p>";
    intermediate += "<p>" + $("tr:nth-child(2) td:nth-child(3)").html() + "</p>";
    intermediate += "<p>" + $("tr:nth-child(3) td:nth-child(1)").html() + "</p>";
    intermediate += "<p>" + $("tr:nth-child(3) td:nth-child(3)").html() + "</p>";
    intermediate += "<p>" + $("tr:nth-child(4) td:nth-child(1) span:first-child").text() + "</p>";
    intermediate += "<p>" + $("tr:nth-child(4) td:nth-child(3)").html() + "</p>";
    intermediate += "<p>" + $("tr:nth-child(4) td:nth-child(1) span:nth-child(2)").text() + "</p>";
    intermediate += "</div>";
    var advanced = '<div class="advanced">';
    advanced += "<p>" + $("tr:nth-child(2) td:nth-child(1)").html() + "</p>";
    advanced += "<p>" + $("tr:nth-child(2) td:nth-child(4)").html() + "</p>";
    advanced += "<p>" + $("tr:nth-child(3) td:nth-child(1)").html() + "</p>";
    advanced += "<p>" + $("tr:nth-child(3) td:nth-child(4)").html() + "</p>";
    advanced += "<p>" + $("tr:nth-child(4) td:nth-child(1) span:first-child").text() + "</p>";
    advanced += "<p>" + $("tr:nth-child(4) td:nth-child(4)").html() + "</p>";
    advanced += "<p>" + $("tr:nth-child(4) td:nth-child(1) span:nth-child(2)").text() + "</p>";
    advanced += "</div>";
    var levelTableContentMobile = beginner + intermediate + advanced;
    $(".roadMap .levelTableContentMobile").html(levelTableContentMobile);
    if (window.location.href.indexOf("/action/edit") === -1) {
        $(".roadMap .intermediate").hide();
        $(".roadMap .advanced").hide();
    }
    $(".roadMap .levelTableSection").waypoint(function(direction) {
        if ($(".levelTable").find(".open").length === 0) {
            animateLevelTableDesktop();
        }
    }, {
        offset: "70%"
    });
    $(".roadMap .levelTableContentMobile").waypoint(function(direction) {
        if ($(".levelTableContentMobile").find(".open").length === 0) {
            animateLevelTableMobileBeginner();
        }
    }, {
        offset: "70%"
    });
    function animateLevelTableDesktop() {
        var incrementingTime = 0;
        $(".salaryNumber").eq(0).show();
        $(".salaryNumber").each(function() {
            var countUpObj = new CountUp(this, 0, $(this).attr("value"), "", 3, {
                prefix: "$"
            });
            if (incrementingTime == 0) {
                countUpObj.start();
                incrementingTime = 400;
            } else {
                setTimeout(function() {
                    $(this).addClass("open");
                    countUpObj.start();
                }, incrementingTime);
                incrementingTime += 100;
            }
        });
        $(".jobOpeningCircle").each(function() {
            var thisCircle = $(this);
            var countUpObj = new CountUp($(this).find(".number")[0], 0, $(this).find(".number").attr("value"), "", 2, {});
            setTimeout(function() {
                $(thisCircle).addClass("open");
                countUpObj.start();
            }, incrementingTime);
            incrementingTime += 200;
        });
        $(".numOfCertsCircle").each(function() {
            var thisCircle = $(this);
            var countUpObj = new CountUp($(this).find(".number")[0], 0, $(this).find(".number").attr("value"), "", 1, {});
            setTimeout(function() {
                $(thisCircle).addClass("open");
                countUpObj.start();
            }, incrementingTime);
            incrementingTime += 200;
        });
        setTimeout(function() {
            $(".levelTableSection .progressLine").animate({
                width: "680px"
            }, 500, function() {
                $(".levelTableSection .progressLine .leftPart").show();
            });
        }, 2100);
    }
    function animateLevelTableMobileBeginner() {
        var Salary1 = new CountUp($(".levelTableContentMobile").find(".beginner").find(".salaryNumber")[0], 0, $(".levelTableContentMobile").find(".beginner").find(".salaryNumber").attr("value"), "", 3, {
            prefix: "$"
        });
        var JobOpening1 = new CountUp($(".levelTableContentMobile").find(".beginner").find(".jobOpeningCircle").find(".number")[0], 0, $(".levelTableContentMobile").find(".beginner").find(".jobOpeningCircle").find(".number").attr("value"), "", 2, {});
        var NumbOfCerts1 = new CountUp($(".levelTableContentMobile").find(".beginner").find(".numOfCertsCircle").find(".number")[0], 0, $(".levelTableContentMobile").find(".beginner").find(".numOfCertsCircle").find(".number").attr("value"), "", 1, {});
        $(".levelTableContentMobile").find(".beginner").find(".salaryNumber").show();
        Salary1.start();
        setTimeout(function() {
            $(".levelTableContentMobile").find(".beginner").find(".jobOpeningCircle").addClass("open");
            JobOpening1.start();
        }, 500);
        setTimeout(function() {
            $(".levelTableContentMobile").find(".beginner").find(".numOfCertsCircle").addClass("open");
            NumbOfCerts1.start();
        }, 700);
    }
    function animateLevelTableMobileIntermediate() {
        var Salary2 = new CountUp($(".levelTableContentMobile").find(".intermediate").find(".salaryNumber")[0], 0, $(".levelTableContentMobile").find(".intermediate").find(".salaryNumber").attr("value"), "", 3, {
            prefix: "$"
        });
        var JobOpening2 = new CountUp($(".levelTableContentMobile").find(".intermediate").find(".jobOpeningCircle").find(".number")[0], 0, $(".levelTableContentMobile").find(".beginner").find(".jobOpeningCircle").find(".number").attr("value"), "", 2, {});
        var NumbOfCerts2 = new CountUp($(".levelTableContentMobile").find(".intermediate").find(".numOfCertsCircle").find(".number")[0], 0, $(".levelTableContentMobile").find(".beginner").find(".numOfCertsCircle").find(".number").attr("value"), "", 1, {});
        $(".levelTableContentMobile").find(".intermediate").find(".salaryNumber").show();
        Salary2.start();
        setTimeout(function() {
            $(".levelTableContentMobile").find(".intermediate").find(".jobOpeningCircle").addClass("open");
            JobOpening2.start();
        }, 500);
        setTimeout(function() {
            $(".levelTableContentMobile").find(".intermediate").find(".numOfCertsCircle").addClass("open");
            NumbOfCerts2.start();
        }, 700);
    }
    function animateLevelTableMobileAdvanced() {
        var Salary3 = new CountUp($(".levelTableContentMobile").find(".advanced").find(".salaryNumber")[0], 0, $(".levelTableContentMobile").find(".advanced").find(".salaryNumber").attr("value"), "", 3, {
            prefix: "$"
        });
        var JobOpening3 = new CountUp($(".levelTableContentMobile").find(".advanced").find(".jobOpeningCircle").find(".number")[0], 0, $(".levelTableContentMobile").find(".beginner").find(".jobOpeningCircle").find(".number").attr("value"), "", 2, {});
        var NumbOfCerts3 = new CountUp($(".levelTableContentMobile").find(".advanced").find(".numOfCertsCircle").find(".number")[0], 0, $(".levelTableContentMobile").find(".beginner").find(".numOfCertsCircle").find(".number").attr("value"), "", 1, {});
        $(".levelTableContentMobile").find(".advanced").find(".salaryNumber").show();
        Salary3.start();
        setTimeout(function() {
            $(".levelTableContentMobile").find(".advanced").find(".jobOpeningCircle").addClass("open");
            JobOpening3.start();
        }, 500);
        setTimeout(function() {
            $(".levelTableContentMobile").find(".advanced").find(".numOfCertsCircle").addClass("open");
            NumbOfCerts3.start();
        }, 700);
    }
    $(".roadMap .exampleQuestions .intro input[type='button']").on("click", function() {
        var SpecificQuestionsSection = $(this).closest(".exampleQuestions");
        SpecificQuestionsSection.find(".intro").hide();
        SpecificQuestionsSection.find(".step-progress ul li.current").removeClass("current");
        SpecificQuestionsSection.find(".step-progress ul li").not(".active").first().addClass("active current");
        SpecificQuestionsSection.find(".question p").first().prepend('<p style="margin-bottom: 5px;">Question 1 of ' + SpecificQuestionsSection.find(".question").length.toString() + "</p>");
        SpecificQuestionsSection.find(".questionsSection").show();
        SpecificQuestionsSection.find(".question").first().show();
    });
    $(".roadMap .exampleQuestions .question input[type='button']").on("click", function() {
        var SpecificQuestionsSection = $(this).closest(".exampleQuestions");
        var SpecificSingleQuestion = $(this).closest(".question");
        if (SpecificSingleQuestion.next().length) {
            SpecificQuestionsSection.find(".step-progress ul li.current").removeClass("current");
            SpecificQuestionsSection.find(".step-progress ul li").not(".active").first().addClass("active current");
            SpecificSingleQuestion.next().find("p").first().prepend('<p style="margin-bottom: 5px;">Question ' + SpecificQuestionsSection.find(".step-progress ul li.active").length.toString() + " of " + SpecificQuestionsSection.find(".question").length.toString() + "</p>");
            SpecificSingleQuestion.hide();
            SpecificSingleQuestion.next().show();
        } else {
            $.featherlight.close();
            $(".featherlight-close").click();
        }
    });
    $(".roadMap .exampleQuestions .question span").on("click", function() {
        var SpecificSingleQuestion = $(this).closest(".question");
        if (!selectedCorrectAnswers(SpecificSingleQuestion)) {
            if (!$(this).hasClass("right")) {
                SpecificSingleQuestion.find("span").removeClass("wrong");
            }
            if ($(this).get(0).hasAttribute("correct")) {
                $(this).addClass("right");
            } else {
                $(this).addClass("wrong");
            }
        }
        if (selectedCorrectAnswers(SpecificSingleQuestion)) {
            SpecificSingleQuestion.find("input[type='button']").show();
            SpecificSingleQuestion.parents(".featherlight-content").scrollTop(SpecificSingleQuestion.find("input[type='button']").offset().top);
        }
    });
    function selectedCorrectAnswers(SpecificSingleQuestion) {
        var IsComplete = true;
        SpecificSingleQuestion.children("span[correct='']").each(function() {
            if (!$(this).hasClass("right")) {
                IsComplete = false;
            }
        });
        return IsComplete;
    }
});

(function($) {
    $.fn.ResponsiveTables = function(options) {
        var defaults = {
            smallPaddingCharNo: 50,
            mediumPaddingCharNo: 50,
            largePaddingCharNo: 50
        }, $selElement = this, ResponsiveTables = {
            opt: "",
            dataContent: "",
            globalWidth: 0,
            init: function() {
                this.opt = $.extend(defaults, options);
                ResponsiveTables.targetTable();
            },
            targetTable: function() {
                var that = this;
                $selElement.find("tr").each(function() {
                    $(this).find("td").each(function(i, v) {
                        that.checkForTableHead($(this), i);
                        $(this).addClass("tdno" + i);
                    });
                });
            },
            checkForTableHead: function(element, index) {
                if ($selElement.find("th").length) {
                    this.dataContent = $selElement.find("th")[index].textContent;
                } else {
                    this.dataContent = $selElement.find("tr:first td")[index].textContent;
                }
                if (this.opt.smallPaddingCharNo > $.trim(this.dataContent).length) {
                    element.addClass("small-padding");
                } else if (this.opt.mediumPaddingCharNo > $.trim(this.dataContent).length) {
                    element.addClass("medium-padding");
                } else {
                    element.addClass("large-padding");
                }
                element.attr("data-content", this.dataContent);
            }
        };
        $(function() {
            ResponsiveTables.init();
        });
        return this;
    };
})(jQuery);

$(window).load(function() {
    if ($(window).width() <= 768) {
        var TopBar = 64;
        var height = $(window).outerHeight() - TopBar - $(".tocHeader").outerHeight() + 1;
        $(".tocContent").css("height", height);
    }
});

$(document).ready(function() {
    $(".tocHeader").on("click", function() {
        if ($(".tocContent").is(":visible")) {
            $(".tocContent").css("overflow", "auto");
            $(".tocContent").slideUp(400);
        } else {
            $(".tocContent").slideDown(400);
            $(".tocContent").css("overflow", "scroll");
            $(".tocContent").find(".social").detach().appendTo(".tocContent");
        }
    });
    $(window).scroll(function() {
        if ($(window).width() <= 768) {
            if ($(window).scrollTop() < 64) {
                $("#sidebarResearch").css("top", "64px");
                var TopBar = 64;
                var height = $(window).outerHeight() - TopBar - $(".tocHeader").outerHeight() + 1;
                $(".tocContent").css("height", height);
            } else {
                $("#sidebarResearch").css("top", "0px");
                var TopBar = 0;
                var height = $(window).outerHeight() - TopBar - $(".tocHeader").outerHeight() + 1;
                $(".tocContent").css("height", height);
            }
        }
    });
    if ($(window).width() <= 768) {
        if ($(window).scrollTop() < 64) {
            $("#sidebarResearch").css("top", "64px");
        } else {
            $("#sidebarResearch").css("top", "0px");
        }
    }
    $(".tableOfContents a").on("click", function(e) {
        if (!$(e.target).is(".accordian")) {
            if ($(".tocHeader h4").is(":visible")) {
                $(".tocContent").slideUp(400);
            }
        }
    });
    $(window).resize(function() {
        if ($(window).width() <= 768) {
            if ($(".tocContent").is(":visible")) {
                $(".tocContent").css("overflow", "auto");
                $(".tocContent").slideUp(400);
            }
            var TopBar = 64;
            var height = $(window).outerHeight() - TopBar - $(".tocHeader").outerHeight() + 1;
            $(".tocContent").css("height", height);
        }
    });
    $(window).on("orientationchange", function() {
        if ($("#sticky").length) {
            $("#sticky").removeAttr("style");
            stickyItUp();
        }
        $(".tocContent").removeAttr("style");
        $(".tocContent").css("display", "block");
        $(".tocContent").css("overflow", "auto");
        if ($(window).width() <= 768) {
            var TopBar = 64;
            var height = $(window).outerHeight() - TopBar - $(".tocHeader").outerHeight() + 1;
            $(".tocContent").css("height", height);
            $(".tocContent").css("display", "none");
            $(".tocContent").css("overflow", "scroll");
        }
    });
    $(".tableOfContents a, .accordianSection a").on("click", function(event) {
        if (this.hash !== "") {
            event.preventDefault();
            var hash = this.hash.replace("#", "");
            hash = hash + " start";
            if ($(event.target).is("span") == false) {
                $("html, body").animate({
                    scrollTop: $("[id='" + hash + "']").offset().top
                }, 800, function() {
                    Waypoint.enableAll();
                });
            }
        }
    });
    $(".goToLink").on("click", function(event) {
        if (this.hash !== "") {
            event.preventDefault();
            var hash = this.hash.replace("#", "");
            if ($(event.target).is("span") == false) {
                $("html, body").animate({
                    scrollTop: $("[id='" + hash + "']").offset().top
                }, 800, function() {
                    Waypoint.enableAll();
                });
            }
        }
    });
    $(".accordian.closed").on("click", function() {
        if ($(this).hasClass("closed")) {
            $(this).parent().next("div").slideDown(400);
            $(this).removeClass("closed");
            $(this).addClass("open");
        } else if ($(this).hasClass("open")) {
            $(this).parent().next("div").slideUp(400);
            $(this).removeClass("open");
            $(this).addClass("closed");
        }
    });
    $(".tableOfContents a").on("click", function(event) {
        if ($(event.target).is("span") == false) {
            Waypoint.disableAll();
            if ($(this).parent().hasClass("accordianSection")) {
                $(".tableOfContents").find("a").removeClass("active");
                $(this).parent().prev().addClass("active");
                $(this).addClass("active");
            } else {
                $(".tableOfContents").find("a").removeClass("active");
                $(this).addClass("active");
            }
        }
    });
    $('div[id^="section"]').each(function() {
        var sectionLink = this.id;
        sectionLink = sectionLink.replace(" start", "");
        sectionLink = sectionLink.replace(" end", "");
        $(this).waypoint(function(direction) {
            if (direction == "down") {
                $(".tableOfContents").find("a").removeClass("active");
                $('a[href="#' + sectionLink + '"]').addClass("active");
            }
        });
        $(this).waypoint(function(direction) {
            if (direction == "up") {
                if (!$('a[href="#' + sectionLink + '"]').hasClass("active")) {
                    $(".tableOfContents").find("a").removeClass("active");
                    $('a[href="#' + sectionLink + '"]').addClass("active");
                }
            }
        });
    });
    $('div[id^="subsection"]').each(function() {
        var sectionLink = this.id;
        if (sectionLink.indexOf("start") >= 0) {
            sectionLink = sectionLink.replace(" start", "");
            $(this).waypoint(function(direction) {
                if (direction == "down") {
                    $(".tableOfContents").find("a").removeClass("active");
                    $('a[href="#' + sectionLink + '"]').parent().prev().addClass("active");
                    $(".accordianSection").find("a").removeClass("active");
                    $('a[href="#' + sectionLink + '"]').addClass("active");
                }
            });
            $(this).waypoint(function(direction) {
                if (direction == "up") {
                    $(".accordianSection").find("a").removeClass("active");
                }
            }, {});
        }
        if (sectionLink.indexOf("end") >= 0) {
            sectionLink = sectionLink.replace(" end", "");
            $(this).waypoint(function(direction) {
                if (direction == "down") {
                    $('a[href="#' + sectionLink + '"]').removeClass("active");
                }
            });
            $(this).waypoint(function(direction) {
                if (direction == "up") {
                    $(".tableOfContents").find("a").removeClass("active");
                    $('a[href="#' + sectionLink + '"]').parent().prev().addClass("active");
                    $(".accordianSection").find("a").removeClass("active");
                    $('a[href="#' + sectionLink + '"]').addClass("active");
                }
            });
        }
    });
    $("#topOfContent").waypoint(function(direction) {
        if (direction == "up") {
            $(".tableOfContents").find("a").removeClass("active");
        }
    }, {
        offset: "-100%"
    });
    $(document).ready(function() {
        $(".articleLink").mouseenter(function() {
            $(this).find("article").addClass("hover");
        });
        $(".articleLink").mouseleave(function() {
            $(this).find("article").removeClass("hover");
        });
    });
    $('div[id^="section"]').attr("style", "height:1px;");
    $('div[id^="subsection"]').attr("style", "height:1px;");
});

$(function() {
    var $el = $("#accordionResearch");
    if ($el.length) {
        $("#accordionResearch").jqueryAccordion({
            interval: 600,
            fadeContent: false,
            open: false,
            defaultOpenIndex: 1
        });
    }
});

$(function() {
    var $el = $("#mastersliderResearch");
    if ($el.length) {
        var slider = new MasterSlider();
        slider.setup("mastersliderResearch", {
            space: 5,
            autoplay: true,
            speed: 10,
            loop: true,
            layout: "fillwidth",
            autoHeight: true
        });
        slider.control("bullets", {
            autohide: false,
            dir: "h",
            align: "bottom",
            margin: -30
        });
    }
});

var TrackAction = function(ActivityType, Activity, Language, Url) {
    if (ActivityType === 1) {
        gtag("event", "Document Download", {
            event_category: "Exam Objectives",
            event_label: Activity
        });
    } else if (ActivityType === 2) {
        gtag("event", "Document Download", {
            event_category: "Practice Questions",
            event_label: Activity
        });
    } else if (ActivityType === 3) {
        gtag("event", "Document Download", {
            event_category: "Other",
            event_label: Activity
        });
    } else if (ActivityType === 4) {
        gtag("event", "Webinar Registered", {
            event_category: "",
            event_label: Activity
        });
    } else if (ActivityType === 5) {
        gtag("event", "CertMaster", {
            event_category: "Trial Signup",
            event_label: Activity
        });
    } else if (ActivityType === 6) {
        gtag("event", "CertMaster", {
            event_category: "Full Product Signup",
            event_label: Activity
        });
    } else if (ActivityType === 7) {} else if (ActivityType === 8) {} else if (ActivityType === 9) {
        gtag("event", "CertMaster", {
            event_category: "CertMaster Login",
            event_label: Activity
        });
    } else if (ActivityType === 10) {
        gtag("event", "SME", {
            event_category: "Submitted SME Application",
            event_label: Activity
        });
    } else if (ActivityType === 11) {} else if (ActivityType === 12) {} else if (ActivityType === 13) {
        gtag("event", "Training", {
            event_category: "Search for Training Materials",
            event_label: Activity
        });
    } else if (ActivityType === 14) {
        gtag("event", "Training", {
            event_category: "Search for Training Partner",
            event_label: Activity
        });
    } else if (ActivityType === 16) {
        gtag("event", "Blog", {
            event_category: "Blog Comments",
            event_label: Activity
        });
    } else if (ActivityType === 18) {
        gtag("event", "Contact", {
            event_category: "Contact Us Form",
            event_label: Activity
        });
    } else if (ActivityType === 19) {
        gtag("event", "Training", {
            event_category: "Buy Training Materials",
            event_label: Activity
        });
    } else if (ActivityType === 20) {
        gtag("event", "Newsletter", {
            event_category: "Signup",
            event_label: Activity
        });
    } else if (ActivityType === 21) {
        gtag("event", "CertMaster", {
            event_category: "Trial Signup",
            event_label: Activity
        });
    } else if (ActivityType === 22) {
        gtag("event", "CertMaster", {
            event_category: "Trial Signup",
            event_label: Activity
        });
    } else if (ActivityType === 25) {
        gtag("event", "Hub", {
            event_category: "Signup",
            event_label: Activity
        });
    } else if (ActivityType === 26) {
        gtag("event", "Hub", {
            event_category: "Resource Lead Form",
            event_label: Activity
        });
    } else if (ActivityType === 27) {
        gtag("event", "Book Sample Lead Form", {
            event_category: "Document Download",
            event_label: Activity
        });
    } else if (ActivityType === 29) {
        gtag("event", "Download RoadMap PDF", {
            event_category: "RoadMap",
            event_label: Activity
        });
    } else if (ActivityType === 31) {
        gtag("event", "ZipRecruiter", {
            event_category: "ZipRecruiter",
            event_label: Activity
        });
    } else if (ActivityType === 33) {
        gtag("event", "Download DDOS Guide", {
            event_category: "DDOS Guide",
            event_label: Activity
        });
    }
    $.ajax({
        type: "POST",
        url: "/services/trackaction/trackaction",
        data: " {'Activity':'" + Activity + "', 'ActivityType':'" + ActivityType + "', 'Url':'" + Url + "' } ",
        contentType: "application/json; charset=utf-8",
        dataType: "json",
        success: function(r) {}
    });
};

$(window).load(function() {
    stickyItUp();
});

$(window).resize(function() {
    if ($("#sticky").length) {
        $("#sticky").removeAttr("style");
        stickyItUp();
    }
});

$(window).scroll(function() {
    stickyItUp();
});

function isScrolledTo(elem) {
    var docViewTop = $(window).scrollTop();
    var elemTop = $(elem).offset().top;
    return elemTop < docViewTop;
}

function stickyItUp() {
    if ($("#sticky").length) {
        var catcher = $("#catcher");
        var sticky = $("#sticky");
        var footer = $("#footer");
        content = $("#Content");
        sidebarheight = $("#sidebarResearch").height();
        if ($("#SidebarResource").length) {
            content = $("#Content");
            sidebarheight = $("#SidebarResource").height();
        }
        if ($("#SidebarBlog").length) {
            sidebarheight = $("#SidebarBlog").height();
        }
        var currentWidth = sticky.width();
        var windowTop = $(window).scrollTop();
        var contentheight = content.height();
        var contentBottom = content.offset().top + contentheight;
        var windowheight = $(window).height();
        if ($(window).width() > 768) {
            if (contentheight > sidebarheight) {
                if (windowheight > sidebarheight + 50) {
                    if (isScrolledTo(sticky) || !isScrolledTo(footer)) {
                        sticky.css("position", "fixed");
                        sticky.css("top", "25px");
                        sticky.css("width", currentWidth);
                    }
                    var topStopHeight = catcher.offset().top + catcher.height();
                    if (topStopHeight > sticky.offset().top) {
                        sticky.css("position", "relative");
                        sticky.css("top", 0);
                    }
                    if (contentBottom < sticky.offset().top + sticky.height()) {
                        var StopHeight = contentBottom - sticky.height() - topStopHeight;
                        sticky.css("position", "absolute");
                        sticky.css("top", StopHeight);
                    }
                }
            }
        }
    }
}

(function($) {
    "use strict";
    if ("undefined" === typeof $) {
        if ("console" in window) {
            window.console.info("Too much lightness, Featherlight needs jQuery.");
        }
        return;
    }
    function Featherlight($content, config) {
        if (this instanceof Featherlight) {
            this.id = Featherlight.id++;
            this.setup($content, config);
            this.chainCallbacks(Featherlight._callbackChain);
        } else {
            var fl = new Featherlight($content, config);
            fl.open();
            return fl;
        }
    }
    var opened = [], pruneOpened = function(remove) {
        opened = $.grep(opened, function(fl) {
            return fl !== remove && fl.$instance.closest("body").length > 0;
        });
        return opened;
    };
    var structure = function(obj, prefix) {
        var result = {}, regex = new RegExp("^" + prefix + "([A-Z])(.*)");
        for (var key in obj) {
            var match = key.match(regex);
            if (match) {
                var dasherized = (match[1] + match[2].replace(/([A-Z])/g, "-$1")).toLowerCase();
                result[dasherized] = obj[key];
            }
        }
        return result;
    };
    var eventMap = {
        keyup: "onKeyUp",
        resize: "onResize"
    };
    var globalEventHandler = function(event) {
        $.each(Featherlight.opened().reverse(), function() {
            if (!event.isDefaultPrevented()) {
                if (false === this[eventMap[event.type]](event)) {
                    event.preventDefault();
                    event.stopPropagation();
                    return false;
                }
            }
        });
    };
    var toggleGlobalEvents = function(set) {
        if (set !== Featherlight._globalHandlerInstalled) {
            Featherlight._globalHandlerInstalled = set;
            var events = $.map(eventMap, function(_, name) {
                return name + "." + Featherlight.prototype.namespace;
            }).join(" ");
            $(window)[set ? "on" : "off"](events, globalEventHandler);
        }
    };
    Featherlight.prototype = {
        constructor: Featherlight,
        namespace: "featherlight",
        targetAttr: "data-featherlight",
        variant: null,
        resetCss: false,
        background: null,
        openTrigger: "click",
        closeTrigger: "click",
        filter: null,
        root: "body",
        openSpeed: 250,
        closeSpeed: 250,
        closeOnClick: "background",
        closeOnEsc: true,
        closeIcon: "&#10005;",
        loading: "",
        persist: false,
        otherClose: null,
        beforeOpen: $.noop,
        beforeContent: $.noop,
        beforeClose: $.noop,
        afterOpen: $.noop,
        afterContent: $.noop,
        afterClose: $.noop,
        onKeyUp: $.noop,
        onResize: $.noop,
        type: null,
        contentFilters: [ "jquery", "image", "html", "ajax", "iframe", "text" ],
        setup: function(target, config) {
            if (typeof target === "object" && target instanceof $ === false && !config) {
                config = target;
                target = undefined;
            }
            var self = $.extend(this, config, {
                target: target
            }), css = !self.resetCss ? self.namespace : self.namespace + "-reset", $background = $(self.background || [ '<div class="' + css + "-loading " + css + '">', '<div class="' + css + '-content">', '<span class="' + css + "-close-icon " + self.namespace + '-close">', self.closeIcon, "</span>", '<div class="' + self.namespace + '-inner">' + self.loading + "</div>", "</div>", "</div>" ].join("")), closeButtonSelector = "." + self.namespace + "-close" + (self.otherClose ? "," + self.otherClose : "");
            self.$instance = $background.clone().addClass(self.variant);
            self.$instance.on(self.closeTrigger + "." + self.namespace, function(event) {
                var $target = $(event.target);
                if ("background" === self.closeOnClick && $target.is("." + self.namespace) || "anywhere" === self.closeOnClick || $target.closest(closeButtonSelector).length) {
                    self.close(event);
                    event.preventDefault();
                }
            });
            return this;
        },
        getContent: function() {
            if (this.persist !== false && this.$content) {
                return this.$content;
            }
            var self = this, filters = this.constructor.contentFilters, readTargetAttr = function(name) {
                return self.$currentTarget && self.$currentTarget.attr(name);
            }, targetValue = readTargetAttr(self.targetAttr), data = self.target || targetValue || "";
            var filter = filters[self.type];
            if (!filter && data in filters) {
                filter = filters[data];
                data = self.target && targetValue;
            }
            data = data || readTargetAttr("href") || "";
            if (!filter) {
                for (var filterName in filters) {
                    if (self[filterName]) {
                        filter = filters[filterName];
                        data = self[filterName];
                    }
                }
            }
            if (!filter) {
                var target = data;
                data = null;
                $.each(self.contentFilters, function() {
                    filter = filters[this];
                    if (filter.test) {
                        data = filter.test(target);
                    }
                    if (!data && filter.regex && target.match && target.match(filter.regex)) {
                        data = target;
                    }
                    return !data;
                });
                if (!data) {
                    if ("console" in window) {
                        window.console.error("Featherlight: no content filter found " + (target ? ' for "' + target + '"' : " (no target specified)"));
                    }
                    return false;
                }
            }
            return filter.process.call(self, data);
        },
        setContent: function($content) {
            var self = this;
            if ($content.is("iframe") || $("iframe", $content).length > 0) {
                self.$instance.addClass(self.namespace + "-iframe");
            }
            self.$instance.removeClass(self.namespace + "-loading");
            self.$instance.find("." + self.namespace + "-inner").not($content).slice(1).remove().end().replaceWith($.contains(self.$instance[0], $content[0]) ? "" : $content);
            self.$content = $content.addClass(self.namespace + "-inner");
            return self;
        },
        open: function(event) {
            var self = this;
            self.$instance.hide().appendTo(self.root);
            if ((!event || !event.isDefaultPrevented()) && self.beforeOpen(event) !== false) {
                if (event) {
                    event.preventDefault();
                }
                var $content = self.getContent();
                if ($content) {
                    opened.push(self);
                    toggleGlobalEvents(true);
                    self.$instance.fadeIn(self.openSpeed);
                    self.beforeContent(event);
                    return $.when($content).always(function($content) {
                        self.setContent($content);
                        self.afterContent(event);
                    }).then(self.$instance.promise()).done(function() {
                        self.afterOpen(event);
                    });
                }
            }
            self.$instance.detach();
            return $.Deferred().reject().promise();
        },
        close: function(event) {
            var self = this, deferred = $.Deferred();
            if (self.beforeClose(event) === false) {
                deferred.reject();
            } else {
                if (0 === pruneOpened(self).length) {
                    toggleGlobalEvents(false);
                }
                self.$instance.fadeOut(self.closeSpeed, function() {
                    self.$instance.detach();
                    self.afterClose(event);
                    deferred.resolve();
                });
            }
            return deferred.promise();
        },
        resize: function(w, h) {
            if (w && h) {
                this.$content.css("width", "").css("height", "");
                var ratio = Math.max(w / (parseInt(this.$content.parent().css("width"), 10) - 1), h / (parseInt(this.$content.parent().css("height"), 10) - 1));
                if (ratio > 1) {
                    ratio = h / Math.floor(h / ratio);
                    this.$content.css("width", "" + w / ratio + "px").css("height", "" + h / ratio + "px");
                }
            }
        },
        chainCallbacks: function(chain) {
            for (var name in chain) {
                this[name] = $.proxy(chain[name], this, $.proxy(this[name], this));
            }
        }
    };
    $.extend(Featherlight, {
        id: 0,
        autoBind: "[data-featherlight]",
        defaults: Featherlight.prototype,
        contentFilters: {
            jquery: {
                regex: /^[#.]\w/,
                test: function(elem) {
                    return elem instanceof $ && elem;
                },
                process: function(elem) {
                    return this.persist !== false ? $(elem) : $(elem).clone(true);
                }
            },
            image: {
                regex: /\.(png|jpg|jpeg|gif|tiff|bmp|svg)(\?\S*)?$/i,
                process: function(url) {
                    var self = this, deferred = $.Deferred(), img = new Image(), $img = $('<img src="' + url + '" alt="" class="' + self.namespace + '-image" />');
                    img.onload = function() {
                        $img.naturalWidth = img.width;
                        $img.naturalHeight = img.height;
                        deferred.resolve($img);
                    };
                    img.onerror = function() {
                        deferred.reject($img);
                    };
                    img.src = url;
                    return deferred.promise();
                }
            },
            html: {
                regex: /^\s*<[\w!][^<]*>/,
                process: function(html) {
                    return $(html);
                }
            },
            ajax: {
                regex: /./,
                process: function(url) {
                    var self = this, deferred = $.Deferred();
                    var $container = $("<div></div>").load(url, function(response, status) {
                        if (status !== "error") {
                            deferred.resolve($container.contents());
                        }
                        deferred.fail();
                    });
                    return deferred.promise();
                }
            },
            iframe: {
                process: function(url) {
                    var deferred = new $.Deferred();
                    var $content = $("<iframe/>").hide().attr("src", url).css(structure(this, "iframe")).on("load", function() {
                        deferred.resolve($content.show());
                    }).appendTo(this.$instance.find("." + this.namespace + "-content"));
                    return deferred.promise();
                }
            },
            text: {
                process: function(text) {
                    return $("<div>", {
                        text: text
                    });
                }
            }
        },
        functionAttributes: [ "beforeOpen", "afterOpen", "beforeContent", "afterContent", "beforeClose", "afterClose" ],
        readElementConfig: function(element, namespace) {
            var Klass = this, regexp = new RegExp("^data-" + namespace + "-(.*)"), config = {};
            if (element && element.attributes) {
                $.each(element.attributes, function() {
                    var match = this.name.match(regexp);
                    if (match) {
                        var val = this.value, name = $.camelCase(match[1]);
                        if ($.inArray(name, Klass.functionAttributes) >= 0) {
                            val = new Function(val);
                        } else {
                            try {
                                val = $.parseJSON(val);
                            } catch (e) {}
                        }
                        config[name] = val;
                    }
                });
            }
            return config;
        },
        extend: function(child, defaults) {
            var Ctor = function() {
                this.constructor = child;
            };
            Ctor.prototype = this.prototype;
            child.prototype = new Ctor();
            child.__super__ = this.prototype;
            $.extend(child, this, defaults);
            child.defaults = child.prototype;
            return child;
        },
        attach: function($source, $content, config) {
            var Klass = this;
            if (typeof $content === "object" && $content instanceof $ === false && !config) {
                config = $content;
                $content = undefined;
            }
            config = $.extend({}, config);
            var namespace = config.namespace || Klass.defaults.namespace, tempConfig = $.extend({}, Klass.defaults, Klass.readElementConfig($source[0], namespace), config), sharedPersist;
            $source.on(tempConfig.openTrigger + "." + tempConfig.namespace, tempConfig.filter, function(event) {
                var elemConfig = $.extend({
                    $source: $source,
                    $currentTarget: $(this)
                }, Klass.readElementConfig($source[0], tempConfig.namespace), Klass.readElementConfig(this, tempConfig.namespace), config);
                var fl = sharedPersist || $(this).data("featherlight-persisted") || new Klass($content, elemConfig);
                if (fl.persist === "shared") {
                    sharedPersist = fl;
                } else if (fl.persist !== false) {
                    $(this).data("featherlight-persisted", fl);
                }
                elemConfig.$currentTarget.blur();
                fl.open(event);
            });
            return $source;
        },
        current: function() {
            var all = this.opened();
            return all[all.length - 1] || null;
        },
        opened: function() {
            var klass = this;
            pruneOpened();
            return $.grep(opened, function(fl) {
                return fl instanceof klass;
            });
        },
        close: function(event) {
            var cur = this.current();
            if (cur) {
                return cur.close(event);
            }
        },
        _onReady: function() {
            var Klass = this;
            if (Klass.autoBind) {
                $(Klass.autoBind).each(function() {
                    Klass.attach($(this));
                });
                $(document).on("click", Klass.autoBind, function(evt) {
                    if (evt.isDefaultPrevented() || evt.namespace === "featherlight") {
                        return;
                    }
                    evt.preventDefault();
                    Klass.attach($(evt.currentTarget));
                    $(evt.target).trigger("click.featherlight");
                });
            }
        },
        _callbackChain: {
            onKeyUp: function(_super, event) {
                if (27 === event.keyCode) {
                    if (this.closeOnEsc) {
                        $.featherlight.close(event);
                    }
                    return false;
                } else {
                    return _super(event);
                }
            },
            onResize: function(_super, event) {
                this.resize(this.$content.naturalWidth, this.$content.naturalHeight);
                return _super(event);
            },
            afterContent: function(_super, event) {
                var r = _super(event);
                this.onResize(event);
                return r;
            }
        }
    });
    $.featherlight = Featherlight;
    $.fn.featherlight = function($content, config) {
        return Featherlight.attach(this, $content, config);
    };
    $(document).ready(function() {
        Featherlight._onReady();
    });
})(jQuery);

(function($, window, undefined) {
    var defaults = {
        active: null,
        event: "click",
        disabled: [],
        collapsible: "accordion",
        startCollapsed: false,
        rotate: false,
        setHash: false,
        animation: "default",
        animationQueue: false,
        duration: 500,
        fluidHeight: true,
        scrollToAccordion: false,
        scrollToAccordionOnLoad: true,
        scrollToAccordionOffset: 0,
        accordionTabElement: "<div></div>",
        navigationContainer: "",
        click: function() {},
        activate: function() {},
        deactivate: function() {},
        load: function() {},
        activateState: function() {},
        classes: {
            stateDefault: "r-tabs-state-default",
            stateActive: "r-tabs-state-active",
            stateDisabled: "r-tabs-state-disabled",
            stateExcluded: "r-tabs-state-excluded",
            container: "r-tabs",
            ul: "r-tabs-nav",
            tab: "r-tabs-tab",
            anchor: "r-tabs-anchor",
            panel: "r-tabs-panel",
            accordionTitle: "r-tabs-accordion-title"
        }
    };
    function ResponsiveTabs(element, options) {
        this.element = element;
        this.$element = $(element);
        this.tabs = [];
        this.state = "";
        this.rotateInterval = 0;
        this.$queue = $({});
        this.options = $.extend({}, defaults, options);
        this.init();
    }
    ResponsiveTabs.prototype.init = function() {
        var _this = this;
        this.tabs = this._loadElements();
        this._loadClasses();
        this._loadEvents();
        $(window).on("resize", function(e) {
            _this._setState(e);
            if (_this.options.fluidHeight !== true) {
                _this._equaliseHeights();
            }
        });
        $(window).on("hashchange", function(e) {
            var tabRef = _this._getTabRefBySelector(window.location.hash);
            var oTab = _this._getTab(tabRef);
            if (tabRef >= 0 && !oTab._ignoreHashChange && !oTab.disabled) {
                _this._openTab(e, _this._getTab(tabRef), true);
            }
        });
        if (this.options.rotate !== false) {
            this.startRotation();
        }
        if (this.options.fluidHeight !== true) {
            _this._equaliseHeights();
        }
        this.$element.bind("tabs-click", function(e, oTab) {
            _this.options.click.call(this, e, oTab);
        });
        this.$element.bind("tabs-activate", function(e, oTab) {
            _this.options.activate.call(this, e, oTab);
        });
        this.$element.bind("tabs-deactivate", function(e, oTab) {
            _this.options.deactivate.call(this, e, oTab);
        });
        this.$element.bind("tabs-activate-state", function(e, state) {
            _this.options.activateState.call(this, e, state);
        });
        this.$element.bind("tabs-load", function(e) {
            var startTab;
            _this._setState(e);
            if (_this.options.startCollapsed !== true && !(_this.options.startCollapsed === "accordion" && _this.state === "accordion")) {
                startTab = _this._getStartTab();
                _this._openTab(e, startTab);
                _this.options.load.call(this, e, startTab);
            }
        });
        this.$element.trigger("tabs-load");
    };
    ResponsiveTabs.prototype._loadElements = function() {
        var _this = this;
        var $ul = _this.options.navigationContainer === "" ? this.$element.children("ul:first") : this.$element.find(_this.options.navigationContainer).children("ul:first");
        var tabs = [];
        var id = 0;
        this.$element.addClass(_this.options.classes.container);
        $ul.addClass(_this.options.classes.ul);
        $("li", $ul).each(function() {
            var $tab = $(this);
            var isExcluded = $tab.hasClass(_this.options.classes.stateExcluded);
            var $anchor, $panel, $accordionTab, $accordionAnchor, panelSelector;
            if (!isExcluded) {
                $anchor = $("a", $tab);
                panelSelector = $anchor.attr("href");
                $panel = $(panelSelector);
                $accordionTab = $(_this.options.accordionTabElement).insertBefore($panel);
                $accordionAnchor = $("<a></a>").attr("href", panelSelector).html($anchor.html()).appendTo($accordionTab);
                var oTab = {
                    _ignoreHashChange: false,
                    id: id,
                    disabled: $.inArray(id, _this.options.disabled) !== -1,
                    tab: $(this),
                    anchor: $("a", $tab),
                    panel: $panel,
                    selector: panelSelector,
                    accordionTab: $accordionTab,
                    accordionAnchor: $accordionAnchor,
                    active: false
                };
                id++;
                tabs.push(oTab);
            }
        });
        return tabs;
    };
    ResponsiveTabs.prototype._loadClasses = function() {
        for (var i = 0; i < this.tabs.length; i++) {
            this.tabs[i].tab.addClass(this.options.classes.stateDefault).addClass(this.options.classes.tab);
            this.tabs[i].anchor.addClass(this.options.classes.anchor);
            this.tabs[i].panel.addClass(this.options.classes.stateDefault).addClass(this.options.classes.panel);
            this.tabs[i].accordionTab.addClass(this.options.classes.accordionTitle);
            this.tabs[i].accordionAnchor.addClass(this.options.classes.anchor);
            if (this.tabs[i].disabled) {
                this.tabs[i].tab.removeClass(this.options.classes.stateDefault).addClass(this.options.classes.stateDisabled);
                this.tabs[i].accordionTab.removeClass(this.options.classes.stateDefault).addClass(this.options.classes.stateDisabled);
            }
        }
    };
    ResponsiveTabs.prototype._loadEvents = function() {
        var _this = this;
        var fActivate = function(e) {
            var current = _this._getCurrentTab();
            var activatedTab = e.data.tab;
            e.preventDefault();
            activatedTab.tab.trigger("tabs-click", activatedTab);
            if (!activatedTab.disabled) {
                if (_this.options.setHash) {
                    if (history.pushState) {
                        if (!window.location.origin) {
                            window.location.origin = window.location.protocol + "//" + window.location.hostname + (window.location.port ? ":" + window.location.port : "");
                        }
                        history.pushState(null, null, window.location.origin + window.location.pathname + window.location.search + activatedTab.selector);
                    } else {
                        window.location.hash = activatedTab.selector;
                    }
                }
                e.data.tab._ignoreHashChange = true;
                if (current !== activatedTab || _this._isCollapisble()) {
                    _this._closeTab(e, current);
                    if (current !== activatedTab || !_this._isCollapisble()) {
                        _this._openTab(e, activatedTab, false, true);
                    }
                }
            }
        };
        for (var i = 0; i < this.tabs.length; i++) {
            this.tabs[i].anchor.on(_this.options.event, {
                tab: _this.tabs[i]
            }, fActivate);
            this.tabs[i].accordionAnchor.on(_this.options.event, {
                tab: _this.tabs[i]
            }, fActivate);
        }
    };
    ResponsiveTabs.prototype._getStartTab = function() {
        var tabRef = this._getTabRefBySelector(window.location.hash);
        var startTab;
        if (tabRef >= 0 && !this._getTab(tabRef).disabled) {
            startTab = this._getTab(tabRef);
        } else if (this.options.active > 0 && !this._getTab(this.options.active).disabled) {
            startTab = this._getTab(this.options.active);
        } else {
            startTab = this._getTab(0);
        }
        return startTab;
    };
    ResponsiveTabs.prototype._setState = function(e) {
        var $ul = $("ul:first", this.$element);
        var oldState = this.state;
        var startCollapsedIsState = typeof this.options.startCollapsed === "string";
        var startTab;
        if ($ul.is(":visible")) {
            this.state = "tabs";
        } else {
            this.state = "accordion";
        }
        if (this.state !== oldState) {
            this.$element.trigger("tabs-activate-state", {
                oldState: oldState,
                newState: this.state
            });
            if (oldState && startCollapsedIsState && this.options.startCollapsed !== this.state && this._getCurrentTab() === undefined) {
                startTab = this._getStartTab(e);
                this._openTab(e, startTab);
            }
        }
    };
    ResponsiveTabs.prototype._openTab = function(e, oTab, closeCurrent, stopRotation) {
        var _this = this;
        var scrollOffset;
        if (closeCurrent) {
            this._closeTab(e, this._getCurrentTab());
        }
        if (stopRotation && this.rotateInterval > 0) {
            this.stopRotation();
        }
        oTab.active = true;
        oTab.tab.removeClass(_this.options.classes.stateDefault).addClass(_this.options.classes.stateActive);
        oTab.accordionTab.removeClass(_this.options.classes.stateDefault).addClass(_this.options.classes.stateActive);
        _this._doTransition(oTab.panel, _this.options.animation, "open", function() {
            var scrollOnLoad = e.type !== "tabs-load" || _this.options.scrollToAccordionOnLoad;
            oTab.panel.removeClass(_this.options.classes.stateDefault).addClass(_this.options.classes.stateActive);
            if (_this.getState() === "accordion" && _this.options.scrollToAccordion && (!_this._isInView(oTab.accordionTab) || _this.options.animation !== "default") && scrollOnLoad) {
                scrollOffset = oTab.accordionTab.offset().top - _this.options.scrollToAccordionOffset;
                if (_this.options.animation !== "default" && _this.options.duration > 0) {
                    $("html, body").animate({
                        scrollTop: scrollOffset
                    }, _this.options.duration);
                } else {
                    $("html, body").scrollTop(scrollOffset);
                }
            }
        });
        this.$element.trigger("tabs-activate", oTab);
    };
    ResponsiveTabs.prototype._closeTab = function(e, oTab) {
        var _this = this;
        var doQueueOnState = typeof _this.options.animationQueue === "string";
        var doQueue;
        if (oTab !== undefined) {
            if (doQueueOnState && _this.getState() === _this.options.animationQueue) {
                doQueue = true;
            } else if (doQueueOnState) {
                doQueue = false;
            } else {
                doQueue = _this.options.animationQueue;
            }
            oTab.active = false;
            oTab.tab.removeClass(_this.options.classes.stateActive).addClass(_this.options.classes.stateDefault);
            _this._doTransition(oTab.panel, _this.options.animation, "close", function() {
                oTab.accordionTab.removeClass(_this.options.classes.stateActive).addClass(_this.options.classes.stateDefault);
                oTab.panel.removeClass(_this.options.classes.stateActive).addClass(_this.options.classes.stateDefault);
            }, !doQueue);
            this.$element.trigger("tabs-deactivate", oTab);
        }
    };
    ResponsiveTabs.prototype._doTransition = function(panel, method, state, callback, dequeue) {
        var effect;
        var _this = this;
        switch (method) {
          case "slide":
            effect = state === "open" ? "slideDown" : "slideUp";
            break;

          case "fade":
            effect = state === "open" ? "fadeIn" : "fadeOut";
            break;

          default:
            effect = state === "open" ? "show" : "hide";
            _this.options.duration = 0;
            break;
        }
        this.$queue.queue("responsive-tabs", function(next) {
            panel[effect]({
                duration: _this.options.duration,
                complete: function() {
                    callback.call(panel, method, state);
                    next();
                }
            });
        });
        if (state === "open" || dequeue) {
            this.$queue.dequeue("responsive-tabs");
        }
    };
    ResponsiveTabs.prototype._isCollapisble = function() {
        return typeof this.options.collapsible === "boolean" && this.options.collapsible || typeof this.options.collapsible === "string" && this.options.collapsible === this.getState();
    };
    ResponsiveTabs.prototype._getTab = function(numRef) {
        return this.tabs[numRef];
    };
    ResponsiveTabs.prototype._getTabRefBySelector = function(selector) {
        for (var i = 0; i < this.tabs.length; i++) {
            if (this.tabs[i].selector === selector) {
                return i;
            }
        }
        return -1;
    };
    ResponsiveTabs.prototype._getCurrentTab = function() {
        return this._getTab(this._getCurrentTabRef());
    };
    ResponsiveTabs.prototype._getNextTabRef = function(currentTabRef) {
        var tabRef = currentTabRef || this._getCurrentTabRef();
        var nextTabRef = tabRef === this.tabs.length - 1 ? 0 : tabRef + 1;
        return this._getTab(nextTabRef).disabled ? this._getNextTabRef(nextTabRef) : nextTabRef;
    };
    ResponsiveTabs.prototype._getPreviousTabRef = function() {
        return this._getCurrentTabRef() === 0 ? this.tabs.length - 1 : this._getCurrentTabRef() - 1;
    };
    ResponsiveTabs.prototype._getCurrentTabRef = function() {
        for (var i = 0; i < this.tabs.length; i++) {
            if (this.tabs[i].active) {
                return i;
            }
        }
        return -1;
    };
    ResponsiveTabs.prototype._equaliseHeights = function() {
        var maxHeight = 0;
        $.each($.map(this.tabs, function(tab) {
            maxHeight = Math.max(maxHeight, tab.panel.css("minHeight", "").height());
            return tab.panel;
        }), function() {
            this.css("minHeight", maxHeight);
        });
    };
    ResponsiveTabs.prototype._isInView = function($element) {
        var docViewTop = $(window).scrollTop(), docViewBottom = docViewTop + $(window).height(), elemTop = $element.offset().top, elemBottom = elemTop + $element.height();
        return elemBottom <= docViewBottom && elemTop >= docViewTop;
    };
    ResponsiveTabs.prototype.activate = function(tabRef, stopRotation) {
        var e = jQuery.Event("tabs-activate");
        var oTab = this._getTab(tabRef);
        if (!oTab.disabled) {
            this._openTab(e, oTab, true, stopRotation || true);
        }
    };
    ResponsiveTabs.prototype.deactivate = function(tabRef) {
        var e = jQuery.Event("tabs-dectivate");
        var oTab = this._getTab(tabRef);
        if (!oTab.disabled) {
            this._closeTab(e, oTab);
        }
    };
    ResponsiveTabs.prototype.enable = function(tabRef) {
        var oTab = this._getTab(tabRef);
        if (oTab) {
            oTab.disabled = false;
            oTab.tab.addClass(this.options.classes.stateDefault).removeClass(this.options.classes.stateDisabled);
            oTab.accordionTab.addClass(this.options.classes.stateDefault).removeClass(this.options.classes.stateDisabled);
        }
    };
    ResponsiveTabs.prototype.disable = function(tabRef) {
        var oTab = this._getTab(tabRef);
        if (oTab) {
            oTab.disabled = true;
            oTab.tab.removeClass(this.options.classes.stateDefault).addClass(this.options.classes.stateDisabled);
            oTab.accordionTab.removeClass(this.options.classes.stateDefault).addClass(this.options.classes.stateDisabled);
        }
    };
    ResponsiveTabs.prototype.getState = function() {
        return this.state;
    };
    ResponsiveTabs.prototype.startRotation = function(speed) {
        var _this = this;
        if (this.tabs.length > this.options.disabled.length) {
            this.rotateInterval = setInterval(function() {
                var e = jQuery.Event("rotate");
                _this._openTab(e, _this._getTab(_this._getNextTabRef()), true);
            }, speed || ($.isNumeric(_this.options.rotate) ? _this.options.rotate : 4e3));
        } else {
            throw new Error("Rotation is not possible if all tabs are disabled");
        }
    };
    ResponsiveTabs.prototype.stopRotation = function() {
        window.clearInterval(this.rotateInterval);
        this.rotateInterval = 0;
    };
    ResponsiveTabs.prototype.option = function(key, value) {
        if (value) {
            this.options[key] = value;
        }
        return this.options[key];
    };
    $.fn.responsiveTabs = function(options) {
        var args = arguments;
        var instance;
        if (options === undefined || typeof options === "object") {
            return this.each(function() {
                if (!$.data(this, "responsivetabs")) {
                    $.data(this, "responsivetabs", new ResponsiveTabs(this, options));
                }
            });
        } else if (typeof options === "string" && options[0] !== "_" && options !== "init") {
            instance = $.data(this[0], "responsivetabs");
            if (options === "destroy") {
                $.data(this, "responsivetabs", null);
            }
            if (instance instanceof ResponsiveTabs && typeof instance[options] === "function") {
                return instance[options].apply(instance, Array.prototype.slice.call(args, 1));
            } else {
                return this;
            }
        }
    };
})(jQuery, window);

$(function() {
    if ($(".newpathways").length > 0) {
        $(".newpathways .skill-icons a").on("click", function() {
            if (!$(this).hasClass("active")) {
                $(".skill-icons a").removeClass("active");
                $(".more-information").hide();
                $(".side-text").hide();
                if ($(window).width() <= 500) {
                    $(this)[0].scrollIntoView({
                        inline: "center"
                    });
                }
                var certclicked = $(this).attr("id");
                $(this).addClass("active");
                $(this).css("opacity", "1");
                var moreinfo = $(".more-information-holder #" + certclicked).html();
                $(".more-information .content").html(moreinfo);
                $(".more-information").fadeIn();
                $(".skill-icons a:not(.active)").css("opacity", ".2");
                $(".skill-icons img").css("opacity", ".2");
                $(".skill-icons .tag").css("opacity", ".2");
                $(".side-text").fadeIn();
            }
        });
        $(".newpathways .nav-item").on("click", function() {
            $(".skill-icons a").removeClass("active");
            $(".skill-icons a").css("opacity", "1");
            $(".skill-icons img").css("opacity", "1");
            $(".skill-icons .tag").css("opacity", "1");
            $(".more-information").hide();
            $(".side-text").hide();
        });
        $(".newpathways .exit").on("click", function() {
            $(".skill-icons a").removeClass("active");
            $(".skill-icons a").css("opacity", "1");
            $(".skill-icons img").css("opacity", "1");
            $(".skill-icons .tag").css("opacity", "1");
            $(".more-information").fadeOut();
            $(".side-text").fadeOut();
        });
        if ($(".newpathways").parent().hasClass("newcore")) {
            $(".nav-link.newcore").click();
        }
        if ($(".newpathways").parent().hasClass("newinfrastructure")) {
            $(".nav-link.newinfrastructure").click();
        }
        if ($(".newpathways").parent().hasClass("newcybersecurity")) {
            $(".nav-link.newcybersecurity").click();
        }
        if ($(".newpathways").parent().hasClass("newprofessional")) {
            $(".nav-link.newprofessional").click();
        }
    }
});

$(document).ready(function() {
    $(".image-lazy").each(function(index, element) {
        $(element).attr("src", $(element).data("src"));
    });
});

(function(factory) {
    if (typeof define === "function" && define.amd) {
        define([ "jquery" ], factory);
    } else {
        factory(jQuery);
    }
})(function($) {
    $.ui = $.ui || {};
    var version = $.ui.version = "1.12.1";
    var widgetUuid = 0;
    var widgetSlice = Array.prototype.slice;
    $.cleanData = function(orig) {
        return function(elems) {
            var events, elem, i;
            for (i = 0; (elem = elems[i]) != null; i++) {
                try {
                    events = $._data(elem, "events");
                    if (events && events.remove) {
                        $(elem).triggerHandler("remove");
                    }
                } catch (e) {}
            }
            orig(elems);
        };
    }($.cleanData);
    $.widget = function(name, base, prototype) {
        var existingConstructor, constructor, basePrototype;
        var proxiedPrototype = {};
        var namespace = name.split(".")[0];
        name = name.split(".")[1];
        var fullName = namespace + "-" + name;
        if (!prototype) {
            prototype = base;
            base = $.Widget;
        }
        if ($.isArray(prototype)) {
            prototype = $.extend.apply(null, [ {} ].concat(prototype));
        }
        $.expr[":"][fullName.toLowerCase()] = function(elem) {
            return !!$.data(elem, fullName);
        };
        $[namespace] = $[namespace] || {};
        existingConstructor = $[namespace][name];
        constructor = $[namespace][name] = function(options, element) {
            if (!this._createWidget) {
                return new constructor(options, element);
            }
            if (arguments.length) {
                this._createWidget(options, element);
            }
        };
        $.extend(constructor, existingConstructor, {
            version: prototype.version,
            _proto: $.extend({}, prototype),
            _childConstructors: []
        });
        basePrototype = new base();
        basePrototype.options = $.widget.extend({}, basePrototype.options);
        $.each(prototype, function(prop, value) {
            if (!$.isFunction(value)) {
                proxiedPrototype[prop] = value;
                return;
            }
            proxiedPrototype[prop] = function() {
                function _super() {
                    return base.prototype[prop].apply(this, arguments);
                }
                function _superApply(args) {
                    return base.prototype[prop].apply(this, args);
                }
                return function() {
                    var __super = this._super;
                    var __superApply = this._superApply;
                    var returnValue;
                    this._super = _super;
                    this._superApply = _superApply;
                    returnValue = value.apply(this, arguments);
                    this._super = __super;
                    this._superApply = __superApply;
                    return returnValue;
                };
            }();
        });
        constructor.prototype = $.widget.extend(basePrototype, {
            widgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix || name : name
        }, proxiedPrototype, {
            constructor: constructor,
            namespace: namespace,
            widgetName: name,
            widgetFullName: fullName
        });
        if (existingConstructor) {
            $.each(existingConstructor._childConstructors, function(i, child) {
                var childPrototype = child.prototype;
                $.widget(childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto);
            });
            delete existingConstructor._childConstructors;
        } else {
            base._childConstructors.push(constructor);
        }
        $.widget.bridge(name, constructor);
        return constructor;
    };
    $.widget.extend = function(target) {
        var input = widgetSlice.call(arguments, 1);
        var inputIndex = 0;
        var inputLength = input.length;
        var key;
        var value;
        for (;inputIndex < inputLength; inputIndex++) {
            for (key in input[inputIndex]) {
                value = input[inputIndex][key];
                if (input[inputIndex].hasOwnProperty(key) && value !== undefined) {
                    if ($.isPlainObject(value)) {
                        target[key] = $.isPlainObject(target[key]) ? $.widget.extend({}, target[key], value) : $.widget.extend({}, value);
                    } else {
                        target[key] = value;
                    }
                }
            }
        }
        return target;
    };
    $.widget.bridge = function(name, object) {
        var fullName = object.prototype.widgetFullName || name;
        $.fn[name] = function(options) {
            var isMethodCall = typeof options === "string";
            var args = widgetSlice.call(arguments, 1);
            var returnValue = this;
            if (isMethodCall) {
                if (!this.length && options === "instance") {
                    returnValue = undefined;
                } else {
                    this.each(function() {
                        var methodValue;
                        var instance = $.data(this, fullName);
                        if (options === "instance") {
                            returnValue = instance;
                            return false;
                        }
                        if (!instance) {
                            return $.error("cannot call methods on " + name + " prior to initialization; " + "attempted to call method '" + options + "'");
                        }
                        if (!$.isFunction(instance[options]) || options.charAt(0) === "_") {
                            return $.error("no such method '" + options + "' for " + name + " widget instance");
                        }
                        methodValue = instance[options].apply(instance, args);
                        if (methodValue !== instance && methodValue !== undefined) {
                            returnValue = methodValue && methodValue.jquery ? returnValue.pushStack(methodValue.get()) : methodValue;
                            return false;
                        }
                    });
                }
            } else {
                if (args.length) {
                    options = $.widget.extend.apply(null, [ options ].concat(args));
                }
                this.each(function() {
                    var instance = $.data(this, fullName);
                    if (instance) {
                        instance.option(options || {});
                        if (instance._init) {
                            instance._init();
                        }
                    } else {
                        $.data(this, fullName, new object(options, this));
                    }
                });
            }
            return returnValue;
        };
    };
    $.Widget = function() {};
    $.Widget._childConstructors = [];
    $.Widget.prototype = {
        widgetName: "widget",
        widgetEventPrefix: "",
        defaultElement: "<div>",
        options: {
            classes: {},
            disabled: false,
            create: null
        },
        _createWidget: function(options, element) {
            element = $(element || this.defaultElement || this)[0];
            this.element = $(element);
            this.uuid = widgetUuid++;
            this.eventNamespace = "." + this.widgetName + this.uuid;
            this.bindings = $();
            this.hoverable = $();
            this.focusable = $();
            this.classesElementLookup = {};
            if (element !== this) {
                $.data(element, this.widgetFullName, this);
                this._on(true, this.element, {
                    remove: function(event) {
                        if (event.target === element) {
                            this.destroy();
                        }
                    }
                });
                this.document = $(element.style ? element.ownerDocument : element.document || element);
                this.window = $(this.document[0].defaultView || this.document[0].parentWindow);
            }
            this.options = $.widget.extend({}, this.options, this._getCreateOptions(), options);
            this._create();
            if (this.options.disabled) {
                this._setOptionDisabled(this.options.disabled);
            }
            this._trigger("create", null, this._getCreateEventData());
            this._init();
        },
        _getCreateOptions: function() {
            return {};
        },
        _getCreateEventData: $.noop,
        _create: $.noop,
        _init: $.noop,
        destroy: function() {
            var that = this;
            this._destroy();
            $.each(this.classesElementLookup, function(key, value) {
                that._removeClass(value, key);
            });
            this.element.off(this.eventNamespace).removeData(this.widgetFullName);
            this.widget().off(this.eventNamespace).removeAttr("aria-disabled");
            this.bindings.off(this.eventNamespace);
        },
        _destroy: $.noop,
        widget: function() {
            return this.element;
        },
        option: function(key, value) {
            var options = key;
            var parts;
            var curOption;
            var i;
            if (arguments.length === 0) {
                return $.widget.extend({}, this.options);
            }
            if (typeof key === "string") {
                options = {};
                parts = key.split(".");
                key = parts.shift();
                if (parts.length) {
                    curOption = options[key] = $.widget.extend({}, this.options[key]);
                    for (i = 0; i < parts.length - 1; i++) {
                        curOption[parts[i]] = curOption[parts[i]] || {};
                        curOption = curOption[parts[i]];
                    }
                    key = parts.pop();
                    if (arguments.length === 1) {
                        return curOption[key] === undefined ? null : curOption[key];
                    }
                    curOption[key] = value;
                } else {
                    if (arguments.length === 1) {
                        return this.options[key] === undefined ? null : this.options[key];
                    }
                    options[key] = value;
                }
            }
            this._setOptions(options);
            return this;
        },
        _setOptions: function(options) {
            var key;
            for (key in options) {
                this._setOption(key, options[key]);
            }
            return this;
        },
        _setOption: function(key, value) {
            if (key === "classes") {
                this._setOptionClasses(value);
            }
            this.options[key] = value;
            if (key === "disabled") {
                this._setOptionDisabled(value);
            }
            return this;
        },
        _setOptionClasses: function(value) {
            var classKey, elements, currentElements;
            for (classKey in value) {
                currentElements = this.classesElementLookup[classKey];
                if (value[classKey] === this.options.classes[classKey] || !currentElements || !currentElements.length) {
                    continue;
                }
                elements = $(currentElements.get());
                this._removeClass(currentElements, classKey);
                elements.addClass(this._classes({
                    element: elements,
                    keys: classKey,
                    classes: value,
                    add: true
                }));
            }
        },
        _setOptionDisabled: function(value) {
            this._toggleClass(this.widget(), this.widgetFullName + "-disabled", null, !!value);
            if (value) {
                this._removeClass(this.hoverable, null, "ui-state-hover");
                this._removeClass(this.focusable, null, "ui-state-focus");
            }
        },
        enable: function() {
            return this._setOptions({
                disabled: false
            });
        },
        disable: function() {
            return this._setOptions({
                disabled: true
            });
        },
        _classes: function(options) {
            var full = [];
            var that = this;
            options = $.extend({
                element: this.element,
                classes: this.options.classes || {}
            }, options);
            function processClassString(classes, checkOption) {
                var current, i;
                for (i = 0; i < classes.length; i++) {
                    current = that.classesElementLookup[classes[i]] || $();
                    if (options.add) {
                        current = $($.unique(current.get().concat(options.element.get())));
                    } else {
                        current = $(current.not(options.element).get());
                    }
                    that.classesElementLookup[classes[i]] = current;
                    full.push(classes[i]);
                    if (checkOption && options.classes[classes[i]]) {
                        full.push(options.classes[classes[i]]);
                    }
                }
            }
            this._on(options.element, {
                remove: "_untrackClassesElement"
            });
            if (options.keys) {
                processClassString(options.keys.match(/\S+/g) || [], true);
            }
            if (options.extra) {
                processClassString(options.extra.match(/\S+/g) || []);
            }
            return full.join(" ");
        },
        _untrackClassesElement: function(event) {
            var that = this;
            $.each(that.classesElementLookup, function(key, value) {
                if ($.inArray(event.target, value) !== -1) {
                    that.classesElementLookup[key] = $(value.not(event.target).get());
                }
            });
        },
        _removeClass: function(element, keys, extra) {
            return this._toggleClass(element, keys, extra, false);
        },
        _addClass: function(element, keys, extra) {
            return this._toggleClass(element, keys, extra, true);
        },
        _toggleClass: function(element, keys, extra, add) {
            add = typeof add === "boolean" ? add : extra;
            var shift = typeof element === "string" || element === null, options = {
                extra: shift ? keys : extra,
                keys: shift ? element : keys,
                element: shift ? this.element : element,
                add: add
            };
            options.element.toggleClass(this._classes(options), add);
            return this;
        },
        _on: function(suppressDisabledCheck, element, handlers) {
            var delegateElement;
            var instance = this;
            if (typeof suppressDisabledCheck !== "boolean") {
                handlers = element;
                element = suppressDisabledCheck;
                suppressDisabledCheck = false;
            }
            if (!handlers) {
                handlers = element;
                element = this.element;
                delegateElement = this.widget();
            } else {
                element = delegateElement = $(element);
                this.bindings = this.bindings.add(element);
            }
            $.each(handlers, function(event, handler) {
                function handlerProxy() {
                    if (!suppressDisabledCheck && (instance.options.disabled === true || $(this).hasClass("ui-state-disabled"))) {
                        return;
                    }
                    return (typeof handler === "string" ? instance[handler] : handler).apply(instance, arguments);
                }
                if (typeof handler !== "string") {
                    handlerProxy.guid = handler.guid = handler.guid || handlerProxy.guid || $.guid++;
                }
                var match = event.match(/^([\w:-]*)\s*(.*)$/);
                var eventName = match[1] + instance.eventNamespace;
                var selector = match[2];
                if (selector) {
                    delegateElement.on(eventName, selector, handlerProxy);
                } else {
                    element.on(eventName, handlerProxy);
                }
            });
        },
        _off: function(element, eventName) {
            eventName = (eventName || "").split(" ").join(this.eventNamespace + " ") + this.eventNamespace;
            element.off(eventName).off(eventName);
            this.bindings = $(this.bindings.not(element).get());
            this.focusable = $(this.focusable.not(element).get());
            this.hoverable = $(this.hoverable.not(element).get());
        },
        _delay: function(handler, delay) {
            function handlerProxy() {
                return (typeof handler === "string" ? instance[handler] : handler).apply(instance, arguments);
            }
            var instance = this;
            return setTimeout(handlerProxy, delay || 0);
        },
        _hoverable: function(element) {
            this.hoverable = this.hoverable.add(element);
            this._on(element, {
                mouseenter: function(event) {
                    this._addClass($(event.currentTarget), null, "ui-state-hover");
                },
                mouseleave: function(event) {
                    this._removeClass($(event.currentTarget), null, "ui-state-hover");
                }
            });
        },
        _focusable: function(element) {
            this.focusable = this.focusable.add(element);
            this._on(element, {
                focusin: function(event) {
                    this._addClass($(event.currentTarget), null, "ui-state-focus");
                },
                focusout: function(event) {
                    this._removeClass($(event.currentTarget), null, "ui-state-focus");
                }
            });
        },
        _trigger: function(type, event, data) {
            var prop, orig;
            var callback = this.options[type];
            data = data || {};
            event = $.Event(event);
            event.type = (type === this.widgetEventPrefix ? type : this.widgetEventPrefix + type).toLowerCase();
            event.target = this.element[0];
            orig = event.originalEvent;
            if (orig) {
                for (prop in orig) {
                    if (!(prop in event)) {
                        event[prop] = orig[prop];
                    }
                }
            }
            this.element.trigger(event, data);
            return !($.isFunction(callback) && callback.apply(this.element[0], [ event ].concat(data)) === false || event.isDefaultPrevented());
        }
    };
    $.each({
        show: "fadeIn",
        hide: "fadeOut"
    }, function(method, defaultEffect) {
        $.Widget.prototype["_" + method] = function(element, options, callback) {
            if (typeof options === "string") {
                options = {
                    effect: options
                };
            }
            var hasOptions;
            var effectName = !options ? method : options === true || typeof options === "number" ? defaultEffect : options.effect || defaultEffect;
            options = options || {};
            if (typeof options === "number") {
                options = {
                    duration: options
                };
            }
            hasOptions = !$.isEmptyObject(options);
            options.complete = callback;
            if (options.delay) {
                element.delay(options.delay);
            }
            if (hasOptions && $.effects && $.effects.effect[effectName]) {
                element[method](options);
            } else if (effectName !== method && element[effectName]) {
                element[effectName](options.duration, options.easing, callback);
            } else {
                element.queue(function(next) {
                    $(this)[method]();
                    if (callback) {
                        callback.call(element[0]);
                    }
                    next();
                });
            }
        };
    });
    var widget = $.widget;
    (function() {
        var cachedScrollbarWidth, max = Math.max, abs = Math.abs, rhorizontal = /left|center|right/, rvertical = /top|center|bottom/, roffset = /[\+\-]\d+(\.[\d]+)?%?/, rposition = /^\w+/, rpercent = /%$/, _position = $.fn.position;
        function getOffsets(offsets, width, height) {
            return [ parseFloat(offsets[0]) * (rpercent.test(offsets[0]) ? width / 100 : 1), parseFloat(offsets[1]) * (rpercent.test(offsets[1]) ? height / 100 : 1) ];
        }
        function parseCss(element, property) {
            return parseInt($.css(element, property), 10) || 0;
        }
        function getDimensions(elem) {
            var raw = elem[0];
            if (raw.nodeType === 9) {
                return {
                    width: elem.width(),
                    height: elem.height(),
                    offset: {
                        top: 0,
                        left: 0
                    }
                };
            }
            if ($.isWindow(raw)) {
                return {
                    width: elem.width(),
                    height: elem.height(),
                    offset: {
                        top: elem.scrollTop(),
                        left: elem.scrollLeft()
                    }
                };
            }
            if (raw.preventDefault) {
                return {
                    width: 0,
                    height: 0,
                    offset: {
                        top: raw.pageY,
                        left: raw.pageX
                    }
                };
            }
            return {
                width: elem.outerWidth(),
                height: elem.outerHeight(),
                offset: elem.offset()
            };
        }
        $.position = {
            scrollbarWidth: function() {
                if (cachedScrollbarWidth !== undefined) {
                    return cachedScrollbarWidth;
                }
                var w1, w2, div = $("<div " + "style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'>" + "<div style='height:100px;width:auto;'></div></div>"), innerDiv = div.children()[0];
                $("body").append(div);
                w1 = innerDiv.offsetWidth;
                div.css("overflow", "scroll");
                w2 = innerDiv.offsetWidth;
                if (w1 === w2) {
                    w2 = div[0].clientWidth;
                }
                div.remove();
                return cachedScrollbarWidth = w1 - w2;
            },
            getScrollInfo: function(within) {
                var overflowX = within.isWindow || within.isDocument ? "" : within.element.css("overflow-x"), overflowY = within.isWindow || within.isDocument ? "" : within.element.css("overflow-y"), hasOverflowX = overflowX === "scroll" || overflowX === "auto" && within.width < within.element[0].scrollWidth, hasOverflowY = overflowY === "scroll" || overflowY === "auto" && within.height < within.element[0].scrollHeight;
                return {
                    width: hasOverflowY ? $.position.scrollbarWidth() : 0,
                    height: hasOverflowX ? $.position.scrollbarWidth() : 0
                };
            },
            getWithinInfo: function(element) {
                var withinElement = $(element || window), isWindow = $.isWindow(withinElement[0]), isDocument = !!withinElement[0] && withinElement[0].nodeType === 9, hasOffset = !isWindow && !isDocument;
                return {
                    element: withinElement,
                    isWindow: isWindow,
                    isDocument: isDocument,
                    offset: hasOffset ? $(element).offset() : {
                        left: 0,
                        top: 0
                    },
                    scrollLeft: withinElement.scrollLeft(),
                    scrollTop: withinElement.scrollTop(),
                    width: withinElement.outerWidth(),
                    height: withinElement.outerHeight()
                };
            }
        };
        $.fn.position = function(options) {
            if (!options || !options.of) {
                return _position.apply(this, arguments);
            }
            options = $.extend({}, options);
            var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions, target = $(options.of), within = $.position.getWithinInfo(options.within), scrollInfo = $.position.getScrollInfo(within), collision = (options.collision || "flip").split(" "), offsets = {};
            dimensions = getDimensions(target);
            if (target[0].preventDefault) {
                options.at = "left top";
            }
            targetWidth = dimensions.width;
            targetHeight = dimensions.height;
            targetOffset = dimensions.offset;
            basePosition = $.extend({}, targetOffset);
            $.each([ "my", "at" ], function() {
                var pos = (options[this] || "").split(" "), horizontalOffset, verticalOffset;
                if (pos.length === 1) {
                    pos = rhorizontal.test(pos[0]) ? pos.concat([ "center" ]) : rvertical.test(pos[0]) ? [ "center" ].concat(pos) : [ "center", "center" ];
                }
                pos[0] = rhorizontal.test(pos[0]) ? pos[0] : "center";
                pos[1] = rvertical.test(pos[1]) ? pos[1] : "center";
                horizontalOffset = roffset.exec(pos[0]);
                verticalOffset = roffset.exec(pos[1]);
                offsets[this] = [ horizontalOffset ? horizontalOffset[0] : 0, verticalOffset ? verticalOffset[0] : 0 ];
                options[this] = [ rposition.exec(pos[0])[0], rposition.exec(pos[1])[0] ];
            });
            if (collision.length === 1) {
                collision[1] = collision[0];
            }
            if (options.at[0] === "right") {
                basePosition.left += targetWidth;
            } else if (options.at[0] === "center") {
                basePosition.left += targetWidth / 2;
            }
            if (options.at[1] === "bottom") {
                basePosition.top += targetHeight;
            } else if (options.at[1] === "center") {
                basePosition.top += targetHeight / 2;
            }
            atOffset = getOffsets(offsets.at, targetWidth, targetHeight);
            basePosition.left += atOffset[0];
            basePosition.top += atOffset[1];
            return this.each(function() {
                var collisionPosition, using, elem = $(this), elemWidth = elem.outerWidth(), elemHeight = elem.outerHeight(), marginLeft = parseCss(this, "marginLeft"), marginTop = parseCss(this, "marginTop"), collisionWidth = elemWidth + marginLeft + parseCss(this, "marginRight") + scrollInfo.width, collisionHeight = elemHeight + marginTop + parseCss(this, "marginBottom") + scrollInfo.height, position = $.extend({}, basePosition), myOffset = getOffsets(offsets.my, elem.outerWidth(), elem.outerHeight());
                if (options.my[0] === "right") {
                    position.left -= elemWidth;
                } else if (options.my[0] === "center") {
                    position.left -= elemWidth / 2;
                }
                if (options.my[1] === "bottom") {
                    position.top -= elemHeight;
                } else if (options.my[1] === "center") {
                    position.top -= elemHeight / 2;
                }
                position.left += myOffset[0];
                position.top += myOffset[1];
                collisionPosition = {
                    marginLeft: marginLeft,
                    marginTop: marginTop
                };
                $.each([ "left", "top" ], function(i, dir) {
                    if ($.ui.position[collision[i]]) {
                        $.ui.position[collision[i]][dir](position, {
                            targetWidth: targetWidth,
                            targetHeight: targetHeight,
                            elemWidth: elemWidth,
                            elemHeight: elemHeight,
                            collisionPosition: collisionPosition,
                            collisionWidth: collisionWidth,
                            collisionHeight: collisionHeight,
                            offset: [ atOffset[0] + myOffset[0], atOffset[1] + myOffset[1] ],
                            my: options.my,
                            at: options.at,
                            within: within,
                            elem: elem
                        });
                    }
                });
                if (options.using) {
                    using = function(props) {
                        var left = targetOffset.left - position.left, right = left + targetWidth - elemWidth, top = targetOffset.top - position.top, bottom = top + targetHeight - elemHeight, feedback = {
                            target: {
                                element: target,
                                left: targetOffset.left,
                                top: targetOffset.top,
                                width: targetWidth,
                                height: targetHeight
                            },
                            element: {
                                element: elem,
                                left: position.left,
                                top: position.top,
                                width: elemWidth,
                                height: elemHeight
                            },
                            horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
                            vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
                        };
                        if (targetWidth < elemWidth && abs(left + right) < targetWidth) {
                            feedback.horizontal = "center";
                        }
                        if (targetHeight < elemHeight && abs(top + bottom) < targetHeight) {
                            feedback.vertical = "middle";
                        }
                        if (max(abs(left), abs(right)) > max(abs(top), abs(bottom))) {
                            feedback.important = "horizontal";
                        } else {
                            feedback.important = "vertical";
                        }
                        options.using.call(this, props, feedback);
                    };
                }
                elem.offset($.extend(position, {
                    using: using
                }));
            });
        };
        $.ui.position = {
            fit: {
                left: function(position, data) {
                    var within = data.within, withinOffset = within.isWindow ? within.scrollLeft : within.offset.left, outerWidth = within.width, collisionPosLeft = position.left - data.collisionPosition.marginLeft, overLeft = withinOffset - collisionPosLeft, overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset, newOverRight;
                    if (data.collisionWidth > outerWidth) {
                        if (overLeft > 0 && overRight <= 0) {
                            newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
                            position.left += overLeft - newOverRight;
                        } else if (overRight > 0 && overLeft <= 0) {
                            position.left = withinOffset;
                        } else {
                            if (overLeft > overRight) {
                                position.left = withinOffset + outerWidth - data.collisionWidth;
                            } else {
                                position.left = withinOffset;
                            }
                        }
                    } else if (overLeft > 0) {
                        position.left += overLeft;
                    } else if (overRight > 0) {
                        position.left -= overRight;
                    } else {
                        position.left = max(position.left - collisionPosLeft, position.left);
                    }
                },
                top: function(position, data) {
                    var within = data.within, withinOffset = within.isWindow ? within.scrollTop : within.offset.top, outerHeight = data.within.height, collisionPosTop = position.top - data.collisionPosition.marginTop, overTop = withinOffset - collisionPosTop, overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset, newOverBottom;
                    if (data.collisionHeight > outerHeight) {
                        if (overTop > 0 && overBottom <= 0) {
                            newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
                            position.top += overTop - newOverBottom;
                        } else if (overBottom > 0 && overTop <= 0) {
                            position.top = withinOffset;
                        } else {
                            if (overTop > overBottom) {
                                position.top = withinOffset + outerHeight - data.collisionHeight;
                            } else {
                                position.top = withinOffset;
                            }
                        }
                    } else if (overTop > 0) {
                        position.top += overTop;
                    } else if (overBottom > 0) {
                        position.top -= overBottom;
                    } else {
                        position.top = max(position.top - collisionPosTop, position.top);
                    }
                }
            },
            flip: {
                left: function(position, data) {
                    var within = data.within, withinOffset = within.offset.left + within.scrollLeft, outerWidth = within.width, offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left, collisionPosLeft = position.left - data.collisionPosition.marginLeft, overLeft = collisionPosLeft - offsetLeft, overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft, myOffset = data.my[0] === "left" ? -data.elemWidth : data.my[0] === "right" ? data.elemWidth : 0, atOffset = data.at[0] === "left" ? data.targetWidth : data.at[0] === "right" ? -data.targetWidth : 0, offset = -2 * data.offset[0], newOverRight, newOverLeft;
                    if (overLeft < 0) {
                        newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
                        if (newOverRight < 0 || newOverRight < abs(overLeft)) {
                            position.left += myOffset + atOffset + offset;
                        }
                    } else if (overRight > 0) {
                        newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
                        if (newOverLeft > 0 || abs(newOverLeft) < overRight) {
                            position.left += myOffset + atOffset + offset;
                        }
                    }
                },
                top: function(position, data) {
                    var within = data.within, withinOffset = within.offset.top + within.scrollTop, outerHeight = within.height, offsetTop = within.isWindow ? within.scrollTop : within.offset.top, collisionPosTop = position.top - data.collisionPosition.marginTop, overTop = collisionPosTop - offsetTop, overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop, top = data.my[1] === "top", myOffset = top ? -data.elemHeight : data.my[1] === "bottom" ? data.elemHeight : 0, atOffset = data.at[1] === "top" ? data.targetHeight : data.at[1] === "bottom" ? -data.targetHeight : 0, offset = -2 * data.offset[1], newOverTop, newOverBottom;
                    if (overTop < 0) {
                        newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
                        if (newOverBottom < 0 || newOverBottom < abs(overTop)) {
                            position.top += myOffset + atOffset + offset;
                        }
                    } else if (overBottom > 0) {
                        newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
                        if (newOverTop > 0 || abs(newOverTop) < overBottom) {
                            position.top += myOffset + atOffset + offset;
                        }
                    }
                }
            },
            flipfit: {
                left: function() {
                    $.ui.position.flip.left.apply(this, arguments);
                    $.ui.position.fit.left.apply(this, arguments);
                },
                top: function() {
                    $.ui.position.flip.top.apply(this, arguments);
                    $.ui.position.fit.top.apply(this, arguments);
                }
            }
        };
    })();
    var position = $.ui.position;
    var data = $.extend($.expr[":"], {
        data: $.expr.createPseudo ? $.expr.createPseudo(function(dataName) {
            return function(elem) {
                return !!$.data(elem, dataName);
            };
        }) : function(elem, i, match) {
            return !!$.data(elem, match[3]);
        }
    });
    var disableSelection = $.fn.extend({
        disableSelection: function() {
            var eventType = "onselectstart" in document.createElement("div") ? "selectstart" : "mousedown";
            return function() {
                return this.on(eventType + ".ui-disableSelection", function(event) {
                    event.preventDefault();
                });
            };
        }(),
        enableSelection: function() {
            return this.off(".ui-disableSelection");
        }
    });
    var dataSpace = "ui-effects-", dataSpaceStyle = "ui-effects-style", dataSpaceAnimated = "ui-effects-animated", jQuery = $;
    $.effects = {
        effect: {}
    };
    (function(jQuery, undefined) {
        var stepHooks = "backgroundColor borderBottomColor borderLeftColor borderRightColor " + "borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor", rplusequals = /^([\-+])=\s*(\d+\.?\d*)/, stringParsers = [ {
            re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
            parse: function(execResult) {
                return [ execResult[1], execResult[2], execResult[3], execResult[4] ];
            }
        }, {
            re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
            parse: function(execResult) {
                return [ execResult[1] * 2.55, execResult[2] * 2.55, execResult[3] * 2.55, execResult[4] ];
            }
        }, {
            re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,
            parse: function(execResult) {
                return [ parseInt(execResult[1], 16), parseInt(execResult[2], 16), parseInt(execResult[3], 16) ];
            }
        }, {
            re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,
            parse: function(execResult) {
                return [ parseInt(execResult[1] + execResult[1], 16), parseInt(execResult[2] + execResult[2], 16), parseInt(execResult[3] + execResult[3], 16) ];
            }
        }, {
            re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
            space: "hsla",
            parse: function(execResult) {
                return [ execResult[1], execResult[2] / 100, execResult[3] / 100, execResult[4] ];
            }
        } ], color = jQuery.Color = function(color, green, blue, alpha) {
            return new jQuery.Color.fn.parse(color, green, blue, alpha);
        }, spaces = {
            rgba: {
                props: {
                    red: {
                        idx: 0,
                        type: "byte"
                    },
                    green: {
                        idx: 1,
                        type: "byte"
                    },
                    blue: {
                        idx: 2,
                        type: "byte"
                    }
                }
            },
            hsla: {
                props: {
                    hue: {
                        idx: 0,
                        type: "degrees"
                    },
                    saturation: {
                        idx: 1,
                        type: "percent"
                    },
                    lightness: {
                        idx: 2,
                        type: "percent"
                    }
                }
            }
        }, propTypes = {
            "byte": {
                floor: true,
                max: 255
            },
            percent: {
                max: 1
            },
            degrees: {
                mod: 360,
                floor: true
            }
        }, support = color.support = {}, supportElem = jQuery("<p>")[0], colors, each = jQuery.each;
        supportElem.style.cssText = "background-color:rgba(1,1,1,.5)";
        support.rgba = supportElem.style.backgroundColor.indexOf("rgba") > -1;
        each(spaces, function(spaceName, space) {
            space.cache = "_" + spaceName;
            space.props.alpha = {
                idx: 3,
                type: "percent",
                def: 1
            };
        });
        function clamp(value, prop, allowEmpty) {
            var type = propTypes[prop.type] || {};
            if (value == null) {
                return allowEmpty || !prop.def ? null : prop.def;
            }
            value = type.floor ? ~~value : parseFloat(value);
            if (isNaN(value)) {
                return prop.def;
            }
            if (type.mod) {
                return (value + type.mod) % type.mod;
            }
            return 0 > value ? 0 : type.max < value ? type.max : value;
        }
        function stringParse(string) {
            var inst = color(), rgba = inst._rgba = [];
            string = string.toLowerCase();
            each(stringParsers, function(i, parser) {
                var parsed, match = parser.re.exec(string), values = match && parser.parse(match), spaceName = parser.space || "rgba";
                if (values) {
                    parsed = inst[spaceName](values);
                    inst[spaces[spaceName].cache] = parsed[spaces[spaceName].cache];
                    rgba = inst._rgba = parsed._rgba;
                    return false;
                }
            });
            if (rgba.length) {
                if (rgba.join() === "0,0,0,0") {
                    jQuery.extend(rgba, colors.transparent);
                }
                return inst;
            }
            return colors[string];
        }
        color.fn = jQuery.extend(color.prototype, {
            parse: function(red, green, blue, alpha) {
                if (red === undefined) {
                    this._rgba = [ null, null, null, null ];
                    return this;
                }
                if (red.jquery || red.nodeType) {
                    red = jQuery(red).css(green);
                    green = undefined;
                }
                var inst = this, type = jQuery.type(red), rgba = this._rgba = [];
                if (green !== undefined) {
                    red = [ red, green, blue, alpha ];
                    type = "array";
                }
                if (type === "string") {
                    return this.parse(stringParse(red) || colors._default);
                }
                if (type === "array") {
                    each(spaces.rgba.props, function(key, prop) {
                        rgba[prop.idx] = clamp(red[prop.idx], prop);
                    });
                    return this;
                }
                if (type === "object") {
                    if (red instanceof color) {
                        each(spaces, function(spaceName, space) {
                            if (red[space.cache]) {
                                inst[space.cache] = red[space.cache].slice();
                            }
                        });
                    } else {
                        each(spaces, function(spaceName, space) {
                            var cache = space.cache;
                            each(space.props, function(key, prop) {
                                if (!inst[cache] && space.to) {
                                    if (key === "alpha" || red[key] == null) {
                                        return;
                                    }
                                    inst[cache] = space.to(inst._rgba);
                                }
                                inst[cache][prop.idx] = clamp(red[key], prop, true);
                            });
                            if (inst[cache] && jQuery.inArray(null, inst[cache].slice(0, 3)) < 0) {
                                inst[cache][3] = 1;
                                if (space.from) {
                                    inst._rgba = space.from(inst[cache]);
                                }
                            }
                        });
                    }
                    return this;
                }
            },
            is: function(compare) {
                var is = color(compare), same = true, inst = this;
                each(spaces, function(_, space) {
                    var localCache, isCache = is[space.cache];
                    if (isCache) {
                        localCache = inst[space.cache] || space.to && space.to(inst._rgba) || [];
                        each(space.props, function(_, prop) {
                            if (isCache[prop.idx] != null) {
                                same = isCache[prop.idx] === localCache[prop.idx];
                                return same;
                            }
                        });
                    }
                    return same;
                });
                return same;
            },
            _space: function() {
                var used = [], inst = this;
                each(spaces, function(spaceName, space) {
                    if (inst[space.cache]) {
                        used.push(spaceName);
                    }
                });
                return used.pop();
            },
            transition: function(other, distance) {
                var end = color(other), spaceName = end._space(), space = spaces[spaceName], startColor = this.alpha() === 0 ? color("transparent") : this, start = startColor[space.cache] || space.to(startColor._rgba), result = start.slice();
                end = end[space.cache];
                each(space.props, function(key, prop) {
                    var index = prop.idx, startValue = start[index], endValue = end[index], type = propTypes[prop.type] || {};
                    if (endValue === null) {
                        return;
                    }
                    if (startValue === null) {
                        result[index] = endValue;
                    } else {
                        if (type.mod) {
                            if (endValue - startValue > type.mod / 2) {
                                startValue += type.mod;
                            } else if (startValue - endValue > type.mod / 2) {
                                startValue -= type.mod;
                            }
                        }
                        result[index] = clamp((endValue - startValue) * distance + startValue, prop);
                    }
                });
                return this[spaceName](result);
            },
            blend: function(opaque) {
                if (this._rgba[3] === 1) {
                    return this;
                }
                var rgb = this._rgba.slice(), a = rgb.pop(), blend = color(opaque)._rgba;
                return color(jQuery.map(rgb, function(v, i) {
                    return (1 - a) * blend[i] + a * v;
                }));
            },
            toRgbaString: function() {
                var prefix = "rgba(", rgba = jQuery.map(this._rgba, function(v, i) {
                    return v == null ? i > 2 ? 1 : 0 : v;
                });
                if (rgba[3] === 1) {
                    rgba.pop();
                    prefix = "rgb(";
                }
                return prefix + rgba.join() + ")";
            },
            toHslaString: function() {
                var prefix = "hsla(", hsla = jQuery.map(this.hsla(), function(v, i) {
                    if (v == null) {
                        v = i > 2 ? 1 : 0;
                    }
                    if (i && i < 3) {
                        v = Math.round(v * 100) + "%";
                    }
                    return v;
                });
                if (hsla[3] === 1) {
                    hsla.pop();
                    prefix = "hsl(";
                }
                return prefix + hsla.join() + ")";
            },
            toHexString: function(includeAlpha) {
                var rgba = this._rgba.slice(), alpha = rgba.pop();
                if (includeAlpha) {
                    rgba.push(~~(alpha * 255));
                }
                return "#" + jQuery.map(rgba, function(v) {
                    v = (v || 0).toString(16);
                    return v.length === 1 ? "0" + v : v;
                }).join("");
            },
            toString: function() {
                return this._rgba[3] === 0 ? "transparent" : this.toRgbaString();
            }
        });
        color.fn.parse.prototype = color.fn;
        function hue2rgb(p, q, h) {
            h = (h + 1) % 1;
            if (h * 6 < 1) {
                return p + (q - p) * h * 6;
            }
            if (h * 2 < 1) {
                return q;
            }
            if (h * 3 < 2) {
                return p + (q - p) * (2 / 3 - h) * 6;
            }
            return p;
        }
        spaces.hsla.to = function(rgba) {
            if (rgba[0] == null || rgba[1] == null || rgba[2] == null) {
                return [ null, null, null, rgba[3] ];
            }
            var r = rgba[0] / 255, g = rgba[1] / 255, b = rgba[2] / 255, a = rgba[3], max = Math.max(r, g, b), min = Math.min(r, g, b), diff = max - min, add = max + min, l = add * .5, h, s;
            if (min === max) {
                h = 0;
            } else if (r === max) {
                h = 60 * (g - b) / diff + 360;
            } else if (g === max) {
                h = 60 * (b - r) / diff + 120;
            } else {
                h = 60 * (r - g) / diff + 240;
            }
            if (diff === 0) {
                s = 0;
            } else if (l <= .5) {
                s = diff / add;
            } else {
                s = diff / (2 - add);
            }
            return [ Math.round(h) % 360, s, l, a == null ? 1 : a ];
        };
        spaces.hsla.from = function(hsla) {
            if (hsla[0] == null || hsla[1] == null || hsla[2] == null) {
                return [ null, null, null, hsla[3] ];
            }
            var h = hsla[0] / 360, s = hsla[1], l = hsla[2], a = hsla[3], q = l <= .5 ? l * (1 + s) : l + s - l * s, p = 2 * l - q;
            return [ Math.round(hue2rgb(p, q, h + 1 / 3) * 255), Math.round(hue2rgb(p, q, h) * 255), Math.round(hue2rgb(p, q, h - 1 / 3) * 255), a ];
        };
        each(spaces, function(spaceName, space) {
            var props = space.props, cache = space.cache, to = space.to, from = space.from;
            color.fn[spaceName] = function(value) {
                if (to && !this[cache]) {
                    this[cache] = to(this._rgba);
                }
                if (value === undefined) {
                    return this[cache].slice();
                }
                var ret, type = jQuery.type(value), arr = type === "array" || type === "object" ? value : arguments, local = this[cache].slice();
                each(props, function(key, prop) {
                    var val = arr[type === "object" ? key : prop.idx];
                    if (val == null) {
                        val = local[prop.idx];
                    }
                    local[prop.idx] = clamp(val, prop);
                });
                if (from) {
                    ret = color(from(local));
                    ret[cache] = local;
                    return ret;
                } else {
                    return color(local);
                }
            };
            each(props, function(key, prop) {
                if (color.fn[key]) {
                    return;
                }
                color.fn[key] = function(value) {
                    var vtype = jQuery.type(value), fn = key === "alpha" ? this._hsla ? "hsla" : "rgba" : spaceName, local = this[fn](), cur = local[prop.idx], match;
                    if (vtype === "undefined") {
                        return cur;
                    }
                    if (vtype === "function") {
                        value = value.call(this, cur);
                        vtype = jQuery.type(value);
                    }
                    if (value == null && prop.empty) {
                        return this;
                    }
                    if (vtype === "string") {
                        match = rplusequals.exec(value);
                        if (match) {
                            value = cur + parseFloat(match[2]) * (match[1] === "+" ? 1 : -1);
                        }
                    }
                    local[prop.idx] = value;
                    return this[fn](local);
                };
            });
        });
        color.hook = function(hook) {
            var hooks = hook.split(" ");
            each(hooks, function(i, hook) {
                jQuery.cssHooks[hook] = {
                    set: function(elem, value) {
                        var parsed, curElem, backgroundColor = "";
                        if (value !== "transparent" && (jQuery.type(value) !== "string" || (parsed = stringParse(value)))) {
                            value = color(parsed || value);
                            if (!support.rgba && value._rgba[3] !== 1) {
                                curElem = hook === "backgroundColor" ? elem.parentNode : elem;
                                while ((backgroundColor === "" || backgroundColor === "transparent") && curElem && curElem.style) {
                                    try {
                                        backgroundColor = jQuery.css(curElem, "backgroundColor");
                                        curElem = curElem.parentNode;
                                    } catch (e) {}
                                }
                                value = value.blend(backgroundColor && backgroundColor !== "transparent" ? backgroundColor : "_default");
                            }
                            value = value.toRgbaString();
                        }
                        try {
                            elem.style[hook] = value;
                        } catch (e) {}
                    }
                };
                jQuery.fx.step[hook] = function(fx) {
                    if (!fx.colorInit) {
                        fx.start = color(fx.elem, hook);
                        fx.end = color(fx.end);
                        fx.colorInit = true;
                    }
                    jQuery.cssHooks[hook].set(fx.elem, fx.start.transition(fx.end, fx.pos));
                };
            });
        };
        color.hook(stepHooks);
        jQuery.cssHooks.borderColor = {
            expand: function(value) {
                var expanded = {};
                each([ "Top", "Right", "Bottom", "Left" ], function(i, part) {
                    expanded["border" + part + "Color"] = value;
                });
                return expanded;
            }
        };
        colors = jQuery.Color.names = {
            aqua: "#00ffff",
            black: "#000000",
            blue: "#0000ff",
            fuchsia: "#ff00ff",
            gray: "#808080",
            green: "#008000",
            lime: "#00ff00",
            maroon: "#800000",
            navy: "#000080",
            olive: "#808000",
            purple: "#800080",
            red: "#ff0000",
            silver: "#c0c0c0",
            teal: "#008080",
            white: "#ffffff",
            yellow: "#ffff00",
            transparent: [ null, null, null, 0 ],
            _default: "#ffffff"
        };
    })(jQuery);
    (function() {
        var classAnimationActions = [ "add", "remove", "toggle" ], shorthandStyles = {
            border: 1,
            borderBottom: 1,
            borderColor: 1,
            borderLeft: 1,
            borderRight: 1,
            borderTop: 1,
            borderWidth: 1,
            margin: 1,
            padding: 1
        };
        $.each([ "borderLeftStyle", "borderRightStyle", "borderBottomStyle", "borderTopStyle" ], function(_, prop) {
            $.fx.step[prop] = function(fx) {
                if (fx.end !== "none" && !fx.setAttr || fx.pos === 1 && !fx.setAttr) {
                    jQuery.style(fx.elem, prop, fx.end);
                    fx.setAttr = true;
                }
            };
        });
        function getElementStyles(elem) {
            var key, len, style = elem.ownerDocument.defaultView ? elem.ownerDocument.defaultView.getComputedStyle(elem, null) : elem.currentStyle, styles = {};
            if (style && style.length && style[0] && style[style[0]]) {
                len = style.length;
                while (len--) {
                    key = style[len];
                    if (typeof style[key] === "string") {
                        styles[$.camelCase(key)] = style[key];
                    }
                }
            } else {
                for (key in style) {
                    if (typeof style[key] === "string") {
                        styles[key] = style[key];
                    }
                }
            }
            return styles;
        }
        function styleDifference(oldStyle, newStyle) {
            var diff = {}, name, value;
            for (name in newStyle) {
                value = newStyle[name];
                if (oldStyle[name] !== value) {
                    if (!shorthandStyles[name]) {
                        if ($.fx.step[name] || !isNaN(parseFloat(value))) {
                            diff[name] = value;
                        }
                    }
                }
            }
            return diff;
        }
        if (!$.fn.addBack) {
            $.fn.addBack = function(selector) {
                return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
            };
        }
        $.effects.animateClass = function(value, duration, easing, callback) {
            var o = $.speed(duration, easing, callback);
            return this.queue(function() {
                var animated = $(this), baseClass = animated.attr("class") || "", applyClassChange, allAnimations = o.children ? animated.find("*").addBack() : animated;
                allAnimations = allAnimations.map(function() {
                    var el = $(this);
                    return {
                        el: el,
                        start: getElementStyles(this)
                    };
                });
                applyClassChange = function() {
                    $.each(classAnimationActions, function(i, action) {
                        if (value[action]) {
                            animated[action + "Class"](value[action]);
                        }
                    });
                };
                applyClassChange();
                allAnimations = allAnimations.map(function() {
                    this.end = getElementStyles(this.el[0]);
                    this.diff = styleDifference(this.start, this.end);
                    return this;
                });
                animated.attr("class", baseClass);
                allAnimations = allAnimations.map(function() {
                    var styleInfo = this, dfd = $.Deferred(), opts = $.extend({}, o, {
                        queue: false,
                        complete: function() {
                            dfd.resolve(styleInfo);
                        }
                    });
                    this.el.animate(this.diff, opts);
                    return dfd.promise();
                });
                $.when.apply($, allAnimations.get()).done(function() {
                    applyClassChange();
                    $.each(arguments, function() {
                        var el = this.el;
                        $.each(this.diff, function(key) {
                            el.css(key, "");
                        });
                    });
                    o.complete.call(animated[0]);
                });
            });
        };
        $.fn.extend({
            addClass: function(orig) {
                return function(classNames, speed, easing, callback) {
                    return speed ? $.effects.animateClass.call(this, {
                        add: classNames
                    }, speed, easing, callback) : orig.apply(this, arguments);
                };
            }($.fn.addClass),
            removeClass: function(orig) {
                return function(classNames, speed, easing, callback) {
                    return arguments.length > 1 ? $.effects.animateClass.call(this, {
                        remove: classNames
                    }, speed, easing, callback) : orig.apply(this, arguments);
                };
            }($.fn.removeClass),
            toggleClass: function(orig) {
                return function(classNames, force, speed, easing, callback) {
                    if (typeof force === "boolean" || force === undefined) {
                        if (!speed) {
                            return orig.apply(this, arguments);
                        } else {
                            return $.effects.animateClass.call(this, force ? {
                                add: classNames
                            } : {
                                remove: classNames
                            }, speed, easing, callback);
                        }
                    } else {
                        return $.effects.animateClass.call(this, {
                            toggle: classNames
                        }, force, speed, easing);
                    }
                };
            }($.fn.toggleClass),
            switchClass: function(remove, add, speed, easing, callback) {
                return $.effects.animateClass.call(this, {
                    add: add,
                    remove: remove
                }, speed, easing, callback);
            }
        });
    })();
    (function() {
        if ($.expr && $.expr.filters && $.expr.filters.animated) {
            $.expr.filters.animated = function(orig) {
                return function(elem) {
                    return !!$(elem).data(dataSpaceAnimated) || orig(elem);
                };
            }($.expr.filters.animated);
        }
        if ($.uiBackCompat !== false) {
            $.extend($.effects, {
                save: function(element, set) {
                    var i = 0, length = set.length;
                    for (;i < length; i++) {
                        if (set[i] !== null) {
                            element.data(dataSpace + set[i], element[0].style[set[i]]);
                        }
                    }
                },
                restore: function(element, set) {
                    var val, i = 0, length = set.length;
                    for (;i < length; i++) {
                        if (set[i] !== null) {
                            val = element.data(dataSpace + set[i]);
                            element.css(set[i], val);
                        }
                    }
                },
                setMode: function(el, mode) {
                    if (mode === "toggle") {
                        mode = el.is(":hidden") ? "show" : "hide";
                    }
                    return mode;
                },
                createWrapper: function(element) {
                    if (element.parent().is(".ui-effects-wrapper")) {
                        return element.parent();
                    }
                    var props = {
                        width: element.outerWidth(true),
                        height: element.outerHeight(true),
                        "float": element.css("float")
                    }, wrapper = $("<div></div>").addClass("ui-effects-wrapper").css({
                        fontSize: "100%",
                        background: "transparent",
                        border: "none",
                        margin: 0,
                        padding: 0
                    }), size = {
                        width: element.width(),
                        height: element.height()
                    }, active = document.activeElement;
                    try {
                        active.id;
                    } catch (e) {
                        active = document.body;
                    }
                    element.wrap(wrapper);
                    if (element[0] === active || $.contains(element[0], active)) {
                        $(active).trigger("focus");
                    }
                    wrapper = element.parent();
                    if (element.css("position") === "static") {
                        wrapper.css({
                            position: "relative"
                        });
                        element.css({
                            position: "relative"
                        });
                    } else {
                        $.extend(props, {
                            position: element.css("position"),
                            zIndex: element.css("z-index")
                        });
                        $.each([ "top", "left", "bottom", "right" ], function(i, pos) {
                            props[pos] = element.css(pos);
                            if (isNaN(parseInt(props[pos], 10))) {
                                props[pos] = "auto";
                            }
                        });
                        element.css({
                            position: "relative",
                            top: 0,
                            left: 0,
                            right: "auto",
                            bottom: "auto"
                        });
                    }
                    element.css(size);
                    return wrapper.css(props).show();
                },
                removeWrapper: function(element) {
                    var active = document.activeElement;
                    if (element.parent().is(".ui-effects-wrapper")) {
                        element.parent().replaceWith(element);
                        if (element[0] === active || $.contains(element[0], active)) {
                            $(active).trigger("focus");
                        }
                    }
                    return element;
                }
            });
        }
        $.extend($.effects, {
            version: "1.12.1",
            define: function(name, mode, effect) {
                if (!effect) {
                    effect = mode;
                    mode = "effect";
                }
                $.effects.effect[name] = effect;
                $.effects.effect[name].mode = mode;
                return effect;
            },
            scaledDimensions: function(element, percent, direction) {
                if (percent === 0) {
                    return {
                        height: 0,
                        width: 0,
                        outerHeight: 0,
                        outerWidth: 0
                    };
                }
                var x = direction !== "horizontal" ? (percent || 100) / 100 : 1, y = direction !== "vertical" ? (percent || 100) / 100 : 1;
                return {
                    height: element.height() * y,
                    width: element.width() * x,
                    outerHeight: element.outerHeight() * y,
                    outerWidth: element.outerWidth() * x
                };
            },
            clipToBox: function(animation) {
                return {
                    width: animation.clip.right - animation.clip.left,
                    height: animation.clip.bottom - animation.clip.top,
                    left: animation.clip.left,
                    top: animation.clip.top
                };
            },
            unshift: function(element, queueLength, count) {
                var queue = element.queue();
                if (queueLength > 1) {
                    queue.splice.apply(queue, [ 1, 0 ].concat(queue.splice(queueLength, count)));
                }
                element.dequeue();
            },
            saveStyle: function(element) {
                element.data(dataSpaceStyle, element[0].style.cssText);
            },
            restoreStyle: function(element) {
                element[0].style.cssText = element.data(dataSpaceStyle) || "";
                element.removeData(dataSpaceStyle);
            },
            mode: function(element, mode) {
                var hidden = element.is(":hidden");
                if (mode === "toggle") {
                    mode = hidden ? "show" : "hide";
                }
                if (hidden ? mode === "hide" : mode === "show") {
                    mode = "none";
                }
                return mode;
            },
            getBaseline: function(origin, original) {
                var y, x;
                switch (origin[0]) {
                  case "top":
                    y = 0;
                    break;

                  case "middle":
                    y = .5;
                    break;

                  case "bottom":
                    y = 1;
                    break;

                  default:
                    y = origin[0] / original.height;
                }
                switch (origin[1]) {
                  case "left":
                    x = 0;
                    break;

                  case "center":
                    x = .5;
                    break;

                  case "right":
                    x = 1;
                    break;

                  default:
                    x = origin[1] / original.width;
                }
                return {
                    x: x,
                    y: y
                };
            },
            createPlaceholder: function(element) {
                var placeholder, cssPosition = element.css("position"), position = element.position();
                element.css({
                    marginTop: element.css("marginTop"),
                    marginBottom: element.css("marginBottom"),
                    marginLeft: element.css("marginLeft"),
                    marginRight: element.css("marginRight")
                }).outerWidth(element.outerWidth()).outerHeight(element.outerHeight());
                if (/^(static|relative)/.test(cssPosition)) {
                    cssPosition = "absolute";
                    placeholder = $("<" + element[0].nodeName + ">").insertAfter(element).css({
                        display: /^(inline|ruby)/.test(element.css("display")) ? "inline-block" : "block",
                        visibility: "hidden",
                        marginTop: element.css("marginTop"),
                        marginBottom: element.css("marginBottom"),
                        marginLeft: element.css("marginLeft"),
                        marginRight: element.css("marginRight"),
                        "float": element.css("float")
                    }).outerWidth(element.outerWidth()).outerHeight(element.outerHeight()).addClass("ui-effects-placeholder");
                    element.data(dataSpace + "placeholder", placeholder);
                }
                element.css({
                    position: cssPosition,
                    left: position.left,
                    top: position.top
                });
                return placeholder;
            },
            removePlaceholder: function(element) {
                var dataKey = dataSpace + "placeholder", placeholder = element.data(dataKey);
                if (placeholder) {
                    placeholder.remove();
                    element.removeData(dataKey);
                }
            },
            cleanUp: function(element) {
                $.effects.restoreStyle(element);
                $.effects.removePlaceholder(element);
            },
            setTransition: function(element, list, factor, value) {
                value = value || {};
                $.each(list, function(i, x) {
                    var unit = element.cssUnit(x);
                    if (unit[0] > 0) {
                        value[x] = unit[0] * factor + unit[1];
                    }
                });
                return value;
            }
        });
        function _normalizeArguments(effect, options, speed, callback) {
            if ($.isPlainObject(effect)) {
                options = effect;
                effect = effect.effect;
            }
            effect = {
                effect: effect
            };
            if (options == null) {
                options = {};
            }
            if ($.isFunction(options)) {
                callback = options;
                speed = null;
                options = {};
            }
            if (typeof options === "number" || $.fx.speeds[options]) {
                callback = speed;
                speed = options;
                options = {};
            }
            if ($.isFunction(speed)) {
                callback = speed;
                speed = null;
            }
            if (options) {
                $.extend(effect, options);
            }
            speed = speed || options.duration;
            effect.duration = $.fx.off ? 0 : typeof speed === "number" ? speed : speed in $.fx.speeds ? $.fx.speeds[speed] : $.fx.speeds._default;
            effect.complete = callback || options.complete;
            return effect;
        }
        function standardAnimationOption(option) {
            if (!option || typeof option === "number" || $.fx.speeds[option]) {
                return true;
            }
            if (typeof option === "string" && !$.effects.effect[option]) {
                return true;
            }
            if ($.isFunction(option)) {
                return true;
            }
            if (typeof option === "object" && !option.effect) {
                return true;
            }
            return false;
        }
        $.fn.extend({
            effect: function() {
                var args = _normalizeArguments.apply(this, arguments), effectMethod = $.effects.effect[args.effect], defaultMode = effectMethod.mode, queue = args.queue, queueName = queue || "fx", complete = args.complete, mode = args.mode, modes = [], prefilter = function(next) {
                    var el = $(this), normalizedMode = $.effects.mode(el, mode) || defaultMode;
                    el.data(dataSpaceAnimated, true);
                    modes.push(normalizedMode);
                    if (defaultMode && (normalizedMode === "show" || normalizedMode === defaultMode && normalizedMode === "hide")) {
                        el.show();
                    }
                    if (!defaultMode || normalizedMode !== "none") {
                        $.effects.saveStyle(el);
                    }
                    if ($.isFunction(next)) {
                        next();
                    }
                };
                if ($.fx.off || !effectMethod) {
                    if (mode) {
                        return this[mode](args.duration, complete);
                    } else {
                        return this.each(function() {
                            if (complete) {
                                complete.call(this);
                            }
                        });
                    }
                }
                function run(next) {
                    var elem = $(this);
                    function cleanup() {
                        elem.removeData(dataSpaceAnimated);
                        $.effects.cleanUp(elem);
                        if (args.mode === "hide") {
                            elem.hide();
                        }
                        done();
                    }
                    function done() {
                        if ($.isFunction(complete)) {
                            complete.call(elem[0]);
                        }
                        if ($.isFunction(next)) {
                            next();
                        }
                    }
                    args.mode = modes.shift();
                    if ($.uiBackCompat !== false && !defaultMode) {
                        if (elem.is(":hidden") ? mode === "hide" : mode === "show") {
                            elem[mode]();
                            done();
                        } else {
                            effectMethod.call(elem[0], args, done);
                        }
                    } else {
                        if (args.mode === "none") {
                            elem[mode]();
                            done();
                        } else {
                            effectMethod.call(elem[0], args, cleanup);
                        }
                    }
                }
                return queue === false ? this.each(prefilter).each(run) : this.queue(queueName, prefilter).queue(queueName, run);
            },
            show: function(orig) {
                return function(option) {
                    if (standardAnimationOption(option)) {
                        return orig.apply(this, arguments);
                    } else {
                        var args = _normalizeArguments.apply(this, arguments);
                        args.mode = "show";
                        return this.effect.call(this, args);
                    }
                };
            }($.fn.show),
            hide: function(orig) {
                return function(option) {
                    if (standardAnimationOption(option)) {
                        return orig.apply(this, arguments);
                    } else {
                        var args = _normalizeArguments.apply(this, arguments);
                        args.mode = "hide";
                        return this.effect.call(this, args);
                    }
                };
            }($.fn.hide),
            toggle: function(orig) {
                return function(option) {
                    if (standardAnimationOption(option) || typeof option === "boolean") {
                        return orig.apply(this, arguments);
                    } else {
                        var args = _normalizeArguments.apply(this, arguments);
                        args.mode = "toggle";
                        return this.effect.call(this, args);
                    }
                };
            }($.fn.toggle),
            cssUnit: function(key) {
                var style = this.css(key), val = [];
                $.each([ "em", "px", "%", "pt" ], function(i, unit) {
                    if (style.indexOf(unit) > 0) {
                        val = [ parseFloat(style), unit ];
                    }
                });
                return val;
            },
            cssClip: function(clipObj) {
                if (clipObj) {
                    return this.css("clip", "rect(" + clipObj.top + "px " + clipObj.right + "px " + clipObj.bottom + "px " + clipObj.left + "px)");
                }
                return parseClip(this.css("clip"), this);
            },
            transfer: function(options, done) {
                var element = $(this), target = $(options.to), targetFixed = target.css("position") === "fixed", body = $("body"), fixTop = targetFixed ? body.scrollTop() : 0, fixLeft = targetFixed ? body.scrollLeft() : 0, endPosition = target.offset(), animation = {
                    top: endPosition.top - fixTop,
                    left: endPosition.left - fixLeft,
                    height: target.innerHeight(),
                    width: target.innerWidth()
                }, startPosition = element.offset(), transfer = $("<div class='ui-effects-transfer'></div>").appendTo("body").addClass(options.className).css({
                    top: startPosition.top - fixTop,
                    left: startPosition.left - fixLeft,
                    height: element.innerHeight(),
                    width: element.innerWidth(),
                    position: targetFixed ? "fixed" : "absolute"
                }).animate(animation, options.duration, options.easing, function() {
                    transfer.remove();
                    if ($.isFunction(done)) {
                        done();
                    }
                });
            }
        });
        function parseClip(str, element) {
            var outerWidth = element.outerWidth(), outerHeight = element.outerHeight(), clipRegex = /^rect\((-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto)\)$/, values = clipRegex.exec(str) || [ "", 0, outerWidth, outerHeight, 0 ];
            return {
                top: parseFloat(values[1]) || 0,
                right: values[2] === "auto" ? outerWidth : parseFloat(values[2]),
                bottom: values[3] === "auto" ? outerHeight : parseFloat(values[3]),
                left: parseFloat(values[4]) || 0
            };
        }
        $.fx.step.clip = function(fx) {
            if (!fx.clipInit) {
                fx.start = $(fx.elem).cssClip();
                if (typeof fx.end === "string") {
                    fx.end = parseClip(fx.end, fx.elem);
                }
                fx.clipInit = true;
            }
            $(fx.elem).cssClip({
                top: fx.pos * (fx.end.top - fx.start.top) + fx.start.top,
                right: fx.pos * (fx.end.right - fx.start.right) + fx.start.right,
                bottom: fx.pos * (fx.end.bottom - fx.start.bottom) + fx.start.bottom,
                left: fx.pos * (fx.end.left - fx.start.left) + fx.start.left
            });
        };
    })();
    (function() {
        var baseEasings = {};
        $.each([ "Quad", "Cubic", "Quart", "Quint", "Expo" ], function(i, name) {
            baseEasings[name] = function(p) {
                return Math.pow(p, i + 2);
            };
        });
        $.extend(baseEasings, {
            Sine: function(p) {
                return 1 - Math.cos(p * Math.PI / 2);
            },
            Circ: function(p) {
                return 1 - Math.sqrt(1 - p * p);
            },
            Elastic: function(p) {
                return p === 0 || p === 1 ? p : -Math.pow(2, 8 * (p - 1)) * Math.sin(((p - 1) * 80 - 7.5) * Math.PI / 15);
            },
            Back: function(p) {
                return p * p * (3 * p - 2);
            },
            Bounce: function(p) {
                var pow2, bounce = 4;
                while (p < ((pow2 = Math.pow(2, --bounce)) - 1) / 11) {}
                return 1 / Math.pow(4, 3 - bounce) - 7.5625 * Math.pow((pow2 * 3 - 2) / 22 - p, 2);
            }
        });
        $.each(baseEasings, function(name, easeIn) {
            $.easing["easeIn" + name] = easeIn;
            $.easing["easeOut" + name] = function(p) {
                return 1 - easeIn(1 - p);
            };
            $.easing["easeInOut" + name] = function(p) {
                return p < .5 ? easeIn(p * 2) / 2 : 1 - easeIn(p * -2 + 2) / 2;
            };
        });
    })();
    var effect = $.effects;
    var effectsEffectBlind = $.effects.define("blind", "hide", function(options, done) {
        var map = {
            up: [ "bottom", "top" ],
            vertical: [ "bottom", "top" ],
            down: [ "top", "bottom" ],
            left: [ "right", "left" ],
            horizontal: [ "right", "left" ],
            right: [ "left", "right" ]
        }, element = $(this), direction = options.direction || "up", start = element.cssClip(), animate = {
            clip: $.extend({}, start)
        }, placeholder = $.effects.createPlaceholder(element);
        animate.clip[map[direction][0]] = animate.clip[map[direction][1]];
        if (options.mode === "show") {
            element.cssClip(animate.clip);
            if (placeholder) {
                placeholder.css($.effects.clipToBox(animate));
            }
            animate.clip = start;
        }
        if (placeholder) {
            placeholder.animate($.effects.clipToBox(animate), options.duration, options.easing);
        }
        element.animate(animate, {
            queue: false,
            duration: options.duration,
            easing: options.easing,
            complete: done
        });
    });
    var effectsEffectBounce = $.effects.define("bounce", function(options, done) {
        var upAnim, downAnim, refValue, element = $(this), mode = options.mode, hide = mode === "hide", show = mode === "show", direction = options.direction || "up", distance = options.distance, times = options.times || 5, anims = times * 2 + (show || hide ? 1 : 0), speed = options.duration / anims, easing = options.easing, ref = direction === "up" || direction === "down" ? "top" : "left", motion = direction === "up" || direction === "left", i = 0, queuelen = element.queue().length;
        $.effects.createPlaceholder(element);
        refValue = element.css(ref);
        if (!distance) {
            distance = element[ref === "top" ? "outerHeight" : "outerWidth"]() / 3;
        }
        if (show) {
            downAnim = {
                opacity: 1
            };
            downAnim[ref] = refValue;
            element.css("opacity", 0).css(ref, motion ? -distance * 2 : distance * 2).animate(downAnim, speed, easing);
        }
        if (hide) {
            distance = distance / Math.pow(2, times - 1);
        }
        downAnim = {};
        downAnim[ref] = refValue;
        for (;i < times; i++) {
            upAnim = {};
            upAnim[ref] = (motion ? "-=" : "+=") + distance;
            element.animate(upAnim, speed, easing).animate(downAnim, speed, easing);
            distance = hide ? distance * 2 : distance / 2;
        }
        if (hide) {
            upAnim = {
                opacity: 0
            };
            upAnim[ref] = (motion ? "-=" : "+=") + distance;
            element.animate(upAnim, speed, easing);
        }
        element.queue(done);
        $.effects.unshift(element, queuelen, anims + 1);
    });
    var effectsEffectClip = $.effects.define("clip", "hide", function(options, done) {
        var start, animate = {}, element = $(this), direction = options.direction || "vertical", both = direction === "both", horizontal = both || direction === "horizontal", vertical = both || direction === "vertical";
        start = element.cssClip();
        animate.clip = {
            top: vertical ? (start.bottom - start.top) / 2 : start.top,
            right: horizontal ? (start.right - start.left) / 2 : start.right,
            bottom: vertical ? (start.bottom - start.top) / 2 : start.bottom,
            left: horizontal ? (start.right - start.left) / 2 : start.left
        };
        $.effects.createPlaceholder(element);
        if (options.mode === "show") {
            element.cssClip(animate.clip);
            animate.clip = start;
        }
        element.animate(animate, {
            queue: false,
            duration: options.duration,
            easing: options.easing,
            complete: done
        });
    });
    var effectsEffectDrop = $.effects.define("drop", "hide", function(options, done) {
        var distance, element = $(this), mode = options.mode, show = mode === "show", direction = options.direction || "left", ref = direction === "up" || direction === "down" ? "top" : "left", motion = direction === "up" || direction === "left" ? "-=" : "+=", oppositeMotion = motion === "+=" ? "-=" : "+=", animation = {
            opacity: 0
        };
        $.effects.createPlaceholder(element);
        distance = options.distance || element[ref === "top" ? "outerHeight" : "outerWidth"](true) / 2;
        animation[ref] = motion + distance;
        if (show) {
            element.css(animation);
            animation[ref] = oppositeMotion + distance;
            animation.opacity = 1;
        }
        element.animate(animation, {
            queue: false,
            duration: options.duration,
            easing: options.easing,
            complete: done
        });
    });
    var effectsEffectExplode = $.effects.define("explode", "hide", function(options, done) {
        var i, j, left, top, mx, my, rows = options.pieces ? Math.round(Math.sqrt(options.pieces)) : 3, cells = rows, element = $(this), mode = options.mode, show = mode === "show", offset = element.show().css("visibility", "hidden").offset(), width = Math.ceil(element.outerWidth() / cells), height = Math.ceil(element.outerHeight() / rows), pieces = [];
        function childComplete() {
            pieces.push(this);
            if (pieces.length === rows * cells) {
                animComplete();
            }
        }
        for (i = 0; i < rows; i++) {
            top = offset.top + i * height;
            my = i - (rows - 1) / 2;
            for (j = 0; j < cells; j++) {
                left = offset.left + j * width;
                mx = j - (cells - 1) / 2;
                element.clone().appendTo("body").wrap("<div></div>").css({
                    position: "absolute",
                    visibility: "visible",
                    left: -j * width,
                    top: -i * height
                }).parent().addClass("ui-effects-explode").css({
                    position: "absolute",
                    overflow: "hidden",
                    width: width,
                    height: height,
                    left: left + (show ? mx * width : 0),
                    top: top + (show ? my * height : 0),
                    opacity: show ? 0 : 1
                }).animate({
                    left: left + (show ? 0 : mx * width),
                    top: top + (show ? 0 : my * height),
                    opacity: show ? 1 : 0
                }, options.duration || 500, options.easing, childComplete);
            }
        }
        function animComplete() {
            element.css({
                visibility: "visible"
            });
            $(pieces).remove();
            done();
        }
    });
    var effectsEffectFade = $.effects.define("fade", "toggle", function(options, done) {
        var show = options.mode === "show";
        $(this).css("opacity", show ? 0 : 1).animate({
            opacity: show ? 1 : 0
        }, {
            queue: false,
            duration: options.duration,
            easing: options.easing,
            complete: done
        });
    });
    var effectsEffectFold = $.effects.define("fold", "hide", function(options, done) {
        var element = $(this), mode = options.mode, show = mode === "show", hide = mode === "hide", size = options.size || 15, percent = /([0-9]+)%/.exec(size), horizFirst = !!options.horizFirst, ref = horizFirst ? [ "right", "bottom" ] : [ "bottom", "right" ], duration = options.duration / 2, placeholder = $.effects.createPlaceholder(element), start = element.cssClip(), animation1 = {
            clip: $.extend({}, start)
        }, animation2 = {
            clip: $.extend({}, start)
        }, distance = [ start[ref[0]], start[ref[1]] ], queuelen = element.queue().length;
        if (percent) {
            size = parseInt(percent[1], 10) / 100 * distance[hide ? 0 : 1];
        }
        animation1.clip[ref[0]] = size;
        animation2.clip[ref[0]] = size;
        animation2.clip[ref[1]] = 0;
        if (show) {
            element.cssClip(animation2.clip);
            if (placeholder) {
                placeholder.css($.effects.clipToBox(animation2));
            }
            animation2.clip = start;
        }
        element.queue(function(next) {
            if (placeholder) {
                placeholder.animate($.effects.clipToBox(animation1), duration, options.easing).animate($.effects.clipToBox(animation2), duration, options.easing);
            }
            next();
        }).animate(animation1, duration, options.easing).animate(animation2, duration, options.easing).queue(done);
        $.effects.unshift(element, queuelen, 4);
    });
    var effectsEffectHighlight = $.effects.define("highlight", "show", function(options, done) {
        var element = $(this), animation = {
            backgroundColor: element.css("backgroundColor")
        };
        if (options.mode === "hide") {
            animation.opacity = 0;
        }
        $.effects.saveStyle(element);
        element.css({
            backgroundImage: "none",
            backgroundColor: options.color || "#ffff99"
        }).animate(animation, {
            queue: false,
            duration: options.duration,
            easing: options.easing,
            complete: done
        });
    });
    var effectsEffectSize = $.effects.define("size", function(options, done) {
        var baseline, factor, temp, element = $(this), cProps = [ "fontSize" ], vProps = [ "borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom" ], hProps = [ "borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight" ], mode = options.mode, restore = mode !== "effect", scale = options.scale || "both", origin = options.origin || [ "middle", "center" ], position = element.css("position"), pos = element.position(), original = $.effects.scaledDimensions(element), from = options.from || original, to = options.to || $.effects.scaledDimensions(element, 0);
        $.effects.createPlaceholder(element);
        if (mode === "show") {
            temp = from;
            from = to;
            to = temp;
        }
        factor = {
            from: {
                y: from.height / original.height,
                x: from.width / original.width
            },
            to: {
                y: to.height / original.height,
                x: to.width / original.width
            }
        };
        if (scale === "box" || scale === "both") {
            if (factor.from.y !== factor.to.y) {
                from = $.effects.setTransition(element, vProps, factor.from.y, from);
                to = $.effects.setTransition(element, vProps, factor.to.y, to);
            }
            if (factor.from.x !== factor.to.x) {
                from = $.effects.setTransition(element, hProps, factor.from.x, from);
                to = $.effects.setTransition(element, hProps, factor.to.x, to);
            }
        }
        if (scale === "content" || scale === "both") {
            if (factor.from.y !== factor.to.y) {
                from = $.effects.setTransition(element, cProps, factor.from.y, from);
                to = $.effects.setTransition(element, cProps, factor.to.y, to);
            }
        }
        if (origin) {
            baseline = $.effects.getBaseline(origin, original);
            from.top = (original.outerHeight - from.outerHeight) * baseline.y + pos.top;
            from.left = (original.outerWidth - from.outerWidth) * baseline.x + pos.left;
            to.top = (original.outerHeight - to.outerHeight) * baseline.y + pos.top;
            to.left = (original.outerWidth - to.outerWidth) * baseline.x + pos.left;
        }
        element.css(from);
        if (scale === "content" || scale === "both") {
            vProps = vProps.concat([ "marginTop", "marginBottom" ]).concat(cProps);
            hProps = hProps.concat([ "marginLeft", "marginRight" ]);
            element.find("*[width]").each(function() {
                var child = $(this), childOriginal = $.effects.scaledDimensions(child), childFrom = {
                    height: childOriginal.height * factor.from.y,
                    width: childOriginal.width * factor.from.x,
                    outerHeight: childOriginal.outerHeight * factor.from.y,
                    outerWidth: childOriginal.outerWidth * factor.from.x
                }, childTo = {
                    height: childOriginal.height * factor.to.y,
                    width: childOriginal.width * factor.to.x,
                    outerHeight: childOriginal.height * factor.to.y,
                    outerWidth: childOriginal.width * factor.to.x
                };
                if (factor.from.y !== factor.to.y) {
                    childFrom = $.effects.setTransition(child, vProps, factor.from.y, childFrom);
                    childTo = $.effects.setTransition(child, vProps, factor.to.y, childTo);
                }
                if (factor.from.x !== factor.to.x) {
                    childFrom = $.effects.setTransition(child, hProps, factor.from.x, childFrom);
                    childTo = $.effects.setTransition(child, hProps, factor.to.x, childTo);
                }
                if (restore) {
                    $.effects.saveStyle(child);
                }
                child.css(childFrom);
                child.animate(childTo, options.duration, options.easing, function() {
                    if (restore) {
                        $.effects.restoreStyle(child);
                    }
                });
            });
        }
        element.animate(to, {
            queue: false,
            duration: options.duration,
            easing: options.easing,
            complete: function() {
                var offset = element.offset();
                if (to.opacity === 0) {
                    element.css("opacity", from.opacity);
                }
                if (!restore) {
                    element.css("position", position === "static" ? "relative" : position).offset(offset);
                    $.effects.saveStyle(element);
                }
                done();
            }
        });
    });
    var effectsEffectScale = $.effects.define("scale", function(options, done) {
        var el = $(this), mode = options.mode, percent = parseInt(options.percent, 10) || (parseInt(options.percent, 10) === 0 ? 0 : mode !== "effect" ? 0 : 100), newOptions = $.extend(true, {
            from: $.effects.scaledDimensions(el),
            to: $.effects.scaledDimensions(el, percent, options.direction || "both"),
            origin: options.origin || [ "middle", "center" ]
        }, options);
        if (options.fade) {
            newOptions.from.opacity = 1;
            newOptions.to.opacity = 0;
        }
        $.effects.effect.size.call(this, newOptions, done);
    });
    var effectsEffectPuff = $.effects.define("puff", "hide", function(options, done) {
        var newOptions = $.extend(true, {}, options, {
            fade: true,
            percent: parseInt(options.percent, 10) || 150
        });
        $.effects.effect.scale.call(this, newOptions, done);
    });
    var effectsEffectPulsate = $.effects.define("pulsate", "show", function(options, done) {
        var element = $(this), mode = options.mode, show = mode === "show", hide = mode === "hide", showhide = show || hide, anims = (options.times || 5) * 2 + (showhide ? 1 : 0), duration = options.duration / anims, animateTo = 0, i = 1, queuelen = element.queue().length;
        if (show || !element.is(":visible")) {
            element.css("opacity", 0).show();
            animateTo = 1;
        }
        for (;i < anims; i++) {
            element.animate({
                opacity: animateTo
            }, duration, options.easing);
            animateTo = 1 - animateTo;
        }
        element.animate({
            opacity: animateTo
        }, duration, options.easing);
        element.queue(done);
        $.effects.unshift(element, queuelen, anims + 1);
    });
    var effectsEffectShake = $.effects.define("shake", function(options, done) {
        var i = 1, element = $(this), direction = options.direction || "left", distance = options.distance || 20, times = options.times || 3, anims = times * 2 + 1, speed = Math.round(options.duration / anims), ref = direction === "up" || direction === "down" ? "top" : "left", positiveMotion = direction === "up" || direction === "left", animation = {}, animation1 = {}, animation2 = {}, queuelen = element.queue().length;
        $.effects.createPlaceholder(element);
        animation[ref] = (positiveMotion ? "-=" : "+=") + distance;
        animation1[ref] = (positiveMotion ? "+=" : "-=") + distance * 2;
        animation2[ref] = (positiveMotion ? "-=" : "+=") + distance * 2;
        element.animate(animation, speed, options.easing);
        for (;i < times; i++) {
            element.animate(animation1, speed, options.easing).animate(animation2, speed, options.easing);
        }
        element.animate(animation1, speed, options.easing).animate(animation, speed / 2, options.easing).queue(done);
        $.effects.unshift(element, queuelen, anims + 1);
    });
    var effectsEffectSlide = $.effects.define("slide", "show", function(options, done) {
        var startClip, startRef, element = $(this), map = {
            up: [ "bottom", "top" ],
            down: [ "top", "bottom" ],
            left: [ "right", "left" ],
            right: [ "left", "right" ]
        }, mode = options.mode, direction = options.direction || "left", ref = direction === "up" || direction === "down" ? "top" : "left", positiveMotion = direction === "up" || direction === "left", distance = options.distance || element[ref === "top" ? "outerHeight" : "outerWidth"](true), animation = {};
        $.effects.createPlaceholder(element);
        startClip = element.cssClip();
        startRef = element.position()[ref];
        animation[ref] = (positiveMotion ? -1 : 1) * distance + startRef;
        animation.clip = element.cssClip();
        animation.clip[map[direction][1]] = animation.clip[map[direction][0]];
        if (mode === "show") {
            element.cssClip(animation.clip);
            element.css(ref, animation[ref]);
            animation.clip = startClip;
            animation[ref] = startRef;
        }
        element.animate(animation, {
            queue: false,
            duration: options.duration,
            easing: options.easing,
            complete: done
        });
    });
    var effect;
    if ($.uiBackCompat !== false) {
        effect = $.effects.define("transfer", function(options, done) {
            $(this).transfer(options, done);
        });
    }
    var effectsEffectTransfer = effect;
    $.ui.focusable = function(element, hasTabindex) {
        var map, mapName, img, focusableIfVisible, fieldset, nodeName = element.nodeName.toLowerCase();
        if ("area" === nodeName) {
            map = element.parentNode;
            mapName = map.name;
            if (!element.href || !mapName || map.nodeName.toLowerCase() !== "map") {
                return false;
            }
            img = $("img[usemap='#" + mapName + "']");
            return img.length > 0 && img.is(":visible");
        }
        if (/^(input|select|textarea|button|object)$/.test(nodeName)) {
            focusableIfVisible = !element.disabled;
            if (focusableIfVisible) {
                fieldset = $(element).closest("fieldset")[0];
                if (fieldset) {
                    focusableIfVisible = !fieldset.disabled;
                }
            }
        } else if ("a" === nodeName) {
            focusableIfVisible = element.href || hasTabindex;
        } else {
            focusableIfVisible = hasTabindex;
        }
        return focusableIfVisible && $(element).is(":visible") && visible($(element));
    };
    function visible(element) {
        var visibility = element.css("visibility");
        while (visibility === "inherit") {
            element = element.parent();
            visibility = element.css("visibility");
        }
        return visibility !== "hidden";
    }
    $.extend($.expr[":"], {
        focusable: function(element) {
            return $.ui.focusable(element, $.attr(element, "tabindex") != null);
        }
    });
    var focusable = $.ui.focusable;
    var form = $.fn.form = function() {
        return typeof this[0].form === "string" ? this.closest("form") : $(this[0].form);
    };
    var formResetMixin = $.ui.formResetMixin = {
        _formResetHandler: function() {
            var form = $(this);
            setTimeout(function() {
                var instances = form.data("ui-form-reset-instances");
                $.each(instances, function() {
                    this.refresh();
                });
            });
        },
        _bindFormResetHandler: function() {
            this.form = this.element.form();
            if (!this.form.length) {
                return;
            }
            var instances = this.form.data("ui-form-reset-instances") || [];
            if (!instances.length) {
                this.form.on("reset.ui-form-reset", this._formResetHandler);
            }
            instances.push(this);
            this.form.data("ui-form-reset-instances", instances);
        },
        _unbindFormResetHandler: function() {
            if (!this.form.length) {
                return;
            }
            var instances = this.form.data("ui-form-reset-instances");
            instances.splice($.inArray(this, instances), 1);
            if (instances.length) {
                this.form.data("ui-form-reset-instances", instances);
            } else {
                this.form.removeData("ui-form-reset-instances").off("reset.ui-form-reset");
            }
        }
    };
    if ($.fn.jquery.substring(0, 3) === "1.7") {
        $.each([ "Width", "Height" ], function(i, name) {
            var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ], type = name.toLowerCase(), orig = {
                innerWidth: $.fn.innerWidth,
                innerHeight: $.fn.innerHeight,
                outerWidth: $.fn.outerWidth,
                outerHeight: $.fn.outerHeight
            };
            function reduce(elem, size, border, margin) {
                $.each(side, function() {
                    size -= parseFloat($.css(elem, "padding" + this)) || 0;
                    if (border) {
                        size -= parseFloat($.css(elem, "border" + this + "Width")) || 0;
                    }
                    if (margin) {
                        size -= parseFloat($.css(elem, "margin" + this)) || 0;
                    }
                });
                return size;
            }
            $.fn["inner" + name] = function(size) {
                if (size === undefined) {
                    return orig["inner" + name].call(this);
                }
                return this.each(function() {
                    $(this).css(type, reduce(this, size) + "px");
                });
            };
            $.fn["outer" + name] = function(size, margin) {
                if (typeof size !== "number") {
                    return orig["outer" + name].call(this, size);
                }
                return this.each(function() {
                    $(this).css(type, reduce(this, size, true, margin) + "px");
                });
            };
        });
        $.fn.addBack = function(selector) {
            return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
        };
    }
    var keycode = $.ui.keyCode = {
        BACKSPACE: 8,
        COMMA: 188,
        DELETE: 46,
        DOWN: 40,
        END: 35,
        ENTER: 13,
        ESCAPE: 27,
        HOME: 36,
        LEFT: 37,
        PAGE_DOWN: 34,
        PAGE_UP: 33,
        PERIOD: 190,
        RIGHT: 39,
        SPACE: 32,
        TAB: 9,
        UP: 38
    };
    var escapeSelector = $.ui.escapeSelector = function() {
        var selectorEscape = /([!"#$%&'()*+,.\/:;<=>?@[\]^`{|}~])/g;
        return function(selector) {
            return selector.replace(selectorEscape, "\\$1");
        };
    }();
    var labels = $.fn.labels = function() {
        var ancestor, selector, id, labels, ancestors;
        if (this[0].labels && this[0].labels.length) {
            return this.pushStack(this[0].labels);
        }
        labels = this.eq(0).parents("label");
        id = this.attr("id");
        if (id) {
            ancestor = this.eq(0).parents().last();
            ancestors = ancestor.add(ancestor.length ? ancestor.siblings() : this.siblings());
            selector = "label[for='" + $.ui.escapeSelector(id) + "']";
            labels = labels.add(ancestors.find(selector).addBack(selector));
        }
        return this.pushStack(labels);
    };
    var scrollParent = $.fn.scrollParent = function(includeHidden) {
        var position = this.css("position"), excludeStaticParent = position === "absolute", overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/, scrollParent = this.parents().filter(function() {
            var parent = $(this);
            if (excludeStaticParent && parent.css("position") === "static") {
                return false;
            }
            return overflowRegex.test(parent.css("overflow") + parent.css("overflow-y") + parent.css("overflow-x"));
        }).eq(0);
        return position === "fixed" || !scrollParent.length ? $(this[0].ownerDocument || document) : scrollParent;
    };
    var tabbable = $.extend($.expr[":"], {
        tabbable: function(element) {
            var tabIndex = $.attr(element, "tabindex"), hasTabindex = tabIndex != null;
            return (!hasTabindex || tabIndex >= 0) && $.ui.focusable(element, hasTabindex);
        }
    });
    var uniqueId = $.fn.extend({
        uniqueId: function() {
            var uuid = 0;
            return function() {
                return this.each(function() {
                    if (!this.id) {
                        this.id = "ui-id-" + ++uuid;
                    }
                });
            };
        }(),
        removeUniqueId: function() {
            return this.each(function() {
                if (/^ui-id-\d+$/.test(this.id)) {
                    $(this).removeAttr("id");
                }
            });
        }
    });
    var widgetsAccordion = $.widget("ui.accordion", {
        version: "1.12.1",
        options: {
            active: 0,
            animate: {},
            classes: {
                "ui-accordion-header": "ui-corner-top",
                "ui-accordion-header-collapsed": "ui-corner-all",
                "ui-accordion-content": "ui-corner-bottom"
            },
            collapsible: false,
            event: "click",
            header: "> li > :first-child, > :not(li):even",
            heightStyle: "auto",
            icons: {
                activeHeader: "ui-icon-triangle-1-s",
                header: "ui-icon-triangle-1-e"
            },
            activate: null,
            beforeActivate: null
        },
        hideProps: {
            borderTopWidth: "hide",
            borderBottomWidth: "hide",
            paddingTop: "hide",
            paddingBottom: "hide",
            height: "hide"
        },
        showProps: {
            borderTopWidth: "show",
            borderBottomWidth: "show",
            paddingTop: "show",
            paddingBottom: "show",
            height: "show"
        },
        _create: function() {
            var options = this.options;
            this.prevShow = this.prevHide = $();
            this._addClass("ui-accordion", "ui-widget ui-helper-reset");
            this.element.attr("role", "tablist");
            if (!options.collapsible && (options.active === false || options.active == null)) {
                options.active = 0;
            }
            this._processPanels();
            if (options.active < 0) {
                options.active += this.headers.length;
            }
            this._refresh();
        },
        _getCreateEventData: function() {
            return {
                header: this.active,
                panel: !this.active.length ? $() : this.active.next()
            };
        },
        _createIcons: function() {
            var icon, children, icons = this.options.icons;
            if (icons) {
                icon = $("<span>");
                this._addClass(icon, "ui-accordion-header-icon", "ui-icon " + icons.header);
                icon.prependTo(this.headers);
                children = this.active.children(".ui-accordion-header-icon");
                this._removeClass(children, icons.header)._addClass(children, null, icons.activeHeader)._addClass(this.headers, "ui-accordion-icons");
            }
        },
        _destroyIcons: function() {
            this._removeClass(this.headers, "ui-accordion-icons");
            this.headers.children(".ui-accordion-header-icon").remove();
        },
        _destroy: function() {
            var contents;
            this.element.removeAttr("role");
            this.headers.removeAttr("role aria-expanded aria-selected aria-controls tabIndex").removeUniqueId();
            this._destroyIcons();
            contents = this.headers.next().css("display", "").removeAttr("role aria-hidden aria-labelledby").removeUniqueId();
            if (this.options.heightStyle !== "content") {
                contents.css("height", "");
            }
        },
        _setOption: function(key, value) {
            if (key === "active") {
                this._activate(value);
                return;
            }
            if (key === "event") {
                if (this.options.event) {
                    this._off(this.headers, this.options.event);
                }
                this._setupEvents(value);
            }
            this._super(key, value);
            if (key === "collapsible" && !value && this.options.active === false) {
                this._activate(0);
            }
            if (key === "icons") {
                this._destroyIcons();
                if (value) {
                    this._createIcons();
                }
            }
        },
        _setOptionDisabled: function(value) {
            this._super(value);
            this.element.attr("aria-disabled", value);
            this._toggleClass(null, "ui-state-disabled", !!value);
            this._toggleClass(this.headers.add(this.headers.next()), null, "ui-state-disabled", !!value);
        },
        _keydown: function(event) {
            if (event.altKey || event.ctrlKey) {
                return;
            }
            var keyCode = $.ui.keyCode, length = this.headers.length, currentIndex = this.headers.index(event.target), toFocus = false;
            switch (event.keyCode) {
              case keyCode.RIGHT:
              case keyCode.DOWN:
                toFocus = this.headers[(currentIndex + 1) % length];
                break;

              case keyCode.LEFT:
              case keyCode.UP:
                toFocus = this.headers[(currentIndex - 1 + length) % length];
                break;

              case keyCode.SPACE:
              case keyCode.ENTER:
                this._eventHandler(event);
                break;

              case keyCode.HOME:
                toFocus = this.headers[0];
                break;

              case keyCode.END:
                toFocus = this.headers[length - 1];
                break;
            }
            if (toFocus) {
                $(event.target).attr("tabIndex", -1);
                $(toFocus).attr("tabIndex", 0);
                $(toFocus).trigger("focus");
                event.preventDefault();
            }
        },
        _panelKeyDown: function(event) {
            if (event.keyCode === $.ui.keyCode.UP && event.ctrlKey) {
                $(event.currentTarget).prev().trigger("focus");
            }
        },
        refresh: function() {
            var options = this.options;
            this._processPanels();
            if (options.active === false && options.collapsible === true || !this.headers.length) {
                options.active = false;
                this.active = $();
            } else if (options.active === false) {
                this._activate(0);
            } else if (this.active.length && !$.contains(this.element[0], this.active[0])) {
                if (this.headers.length === this.headers.find(".ui-state-disabled").length) {
                    options.active = false;
                    this.active = $();
                } else {
                    this._activate(Math.max(0, options.active - 1));
                }
            } else {
                options.active = this.headers.index(this.active);
            }
            this._destroyIcons();
            this._refresh();
        },
        _processPanels: function() {
            var prevHeaders = this.headers, prevPanels = this.panels;
            this.headers = this.element.find(this.options.header);
            this._addClass(this.headers, "ui-accordion-header ui-accordion-header-collapsed", "ui-state-default");
            this.panels = this.headers.next().filter(":not(.ui-accordion-content-active)").hide();
            this._addClass(this.panels, "ui-accordion-content", "ui-helper-reset ui-widget-content");
            if (prevPanels) {
                this._off(prevHeaders.not(this.headers));
                this._off(prevPanels.not(this.panels));
            }
        },
        _refresh: function() {
            var maxHeight, options = this.options, heightStyle = options.heightStyle, parent = this.element.parent();
            this.active = this._findActive(options.active);
            this._addClass(this.active, "ui-accordion-header-active", "ui-state-active")._removeClass(this.active, "ui-accordion-header-collapsed");
            this._addClass(this.active.next(), "ui-accordion-content-active");
            this.active.next().show();
            this.headers.attr("role", "tab").each(function() {
                var header = $(this), headerId = header.uniqueId().attr("id"), panel = header.next(), panelId = panel.uniqueId().attr("id");
                header.attr("aria-controls", panelId);
                panel.attr("aria-labelledby", headerId);
            }).next().attr("role", "tabpanel");
            this.headers.not(this.active).attr({
                "aria-selected": "false",
                "aria-expanded": "false",
                tabIndex: -1
            }).next().attr({
                "aria-hidden": "true"
            }).hide();
            if (!this.active.length) {
                this.headers.eq(0).attr("tabIndex", 0);
            } else {
                this.active.attr({
                    "aria-selected": "true",
                    "aria-expanded": "true",
                    tabIndex: 0
                }).next().attr({
                    "aria-hidden": "false"
                });
            }
            this._createIcons();
            this._setupEvents(options.event);
            if (heightStyle === "fill") {
                maxHeight = parent.height();
                this.element.siblings(":visible").each(function() {
                    var elem = $(this), position = elem.css("position");
                    if (position === "absolute" || position === "fixed") {
                        return;
                    }
                    maxHeight -= elem.outerHeight(true);
                });
                this.headers.each(function() {
                    maxHeight -= $(this).outerHeight(true);
                });
                this.headers.next().each(function() {
                    $(this).height(Math.max(0, maxHeight - $(this).innerHeight() + $(this).height()));
                }).css("overflow", "auto");
            } else if (heightStyle === "auto") {
                maxHeight = 0;
                this.headers.next().each(function() {
                    var isVisible = $(this).is(":visible");
                    if (!isVisible) {
                        $(this).show();
                    }
                    maxHeight = Math.max(maxHeight, $(this).css("height", "").height());
                    if (!isVisible) {
                        $(this).hide();
                    }
                }).height(maxHeight);
            }
        },
        _activate: function(index) {
            var active = this._findActive(index)[0];
            if (active === this.active[0]) {
                return;
            }
            active = active || this.active[0];
            this._eventHandler({
                target: active,
                currentTarget: active,
                preventDefault: $.noop
            });
        },
        _findActive: function(selector) {
            return typeof selector === "number" ? this.headers.eq(selector) : $();
        },
        _setupEvents: function(event) {
            var events = {
                keydown: "_keydown"
            };
            if (event) {
                $.each(event.split(" "), function(index, eventName) {
                    events[eventName] = "_eventHandler";
                });
            }
            this._off(this.headers.add(this.headers.next()));
            this._on(this.headers, events);
            this._on(this.headers.next(), {
                keydown: "_panelKeyDown"
            });
            this._hoverable(this.headers);
            this._focusable(this.headers);
        },
        _eventHandler: function(event) {
            var activeChildren, clickedChildren, options = this.options, active = this.active, clicked = $(event.currentTarget), clickedIsActive = clicked[0] === active[0], collapsing = clickedIsActive && options.collapsible, toShow = collapsing ? $() : clicked.next(), toHide = active.next(), eventData = {
                oldHeader: active,
                oldPanel: toHide,
                newHeader: collapsing ? $() : clicked,
                newPanel: toShow
            };
            event.preventDefault();
            if (clickedIsActive && !options.collapsible || this._trigger("beforeActivate", event, eventData) === false) {
                return;
            }
            options.active = collapsing ? false : this.headers.index(clicked);
            this.active = clickedIsActive ? $() : clicked;
            this._toggle(eventData);
            this._removeClass(active, "ui-accordion-header-active", "ui-state-active");
            if (options.icons) {
                activeChildren = active.children(".ui-accordion-header-icon");
                this._removeClass(activeChildren, null, options.icons.activeHeader)._addClass(activeChildren, null, options.icons.header);
            }
            if (!clickedIsActive) {
                this._removeClass(clicked, "ui-accordion-header-collapsed")._addClass(clicked, "ui-accordion-header-active", "ui-state-active");
                if (options.icons) {
                    clickedChildren = clicked.children(".ui-accordion-header-icon");
                    this._removeClass(clickedChildren, null, options.icons.header)._addClass(clickedChildren, null, options.icons.activeHeader);
                }
                this._addClass(clicked.next(), "ui-accordion-content-active");
            }
        },
        _toggle: function(data) {
            var toShow = data.newPanel, toHide = this.prevShow.length ? this.prevShow : data.oldPanel;
            this.prevShow.add(this.prevHide).stop(true, true);
            this.prevShow = toShow;
            this.prevHide = toHide;
            if (this.options.animate) {
                this._animate(toShow, toHide, data);
            } else {
                toHide.hide();
                toShow.show();
                this._toggleComplete(data);
            }
            toHide.attr({
                "aria-hidden": "true"
            });
            toHide.prev().attr({
                "aria-selected": "false",
                "aria-expanded": "false"
            });
            if (toShow.length && toHide.length) {
                toHide.prev().attr({
                    tabIndex: -1,
                    "aria-expanded": "false"
                });
            } else if (toShow.length) {
                this.headers.filter(function() {
                    return parseInt($(this).attr("tabIndex"), 10) === 0;
                }).attr("tabIndex", -1);
            }
            toShow.attr("aria-hidden", "false").prev().attr({
                "aria-selected": "true",
                "aria-expanded": "true",
                tabIndex: 0
            });
        },
        _animate: function(toShow, toHide, data) {
            var total, easing, duration, that = this, adjust = 0, boxSizing = toShow.css("box-sizing"), down = toShow.length && (!toHide.length || toShow.index() < toHide.index()), animate = this.options.animate || {}, options = down && animate.down || animate, complete = function() {
                that._toggleComplete(data);
            };
            if (typeof options === "number") {
                duration = options;
            }
            if (typeof options === "string") {
                easing = options;
            }
            easing = easing || options.easing || animate.easing;
            duration = duration || options.duration || animate.duration;
            if (!toHide.length) {
                return toShow.animate(this.showProps, duration, easing, complete);
            }
            if (!toShow.length) {
                return toHide.animate(this.hideProps, duration, easing, complete);
            }
            total = toShow.show().outerHeight();
            toHide.animate(this.hideProps, {
                duration: duration,
                easing: easing,
                step: function(now, fx) {
                    fx.now = Math.round(now);
                }
            });
            toShow.hide().animate(this.showProps, {
                duration: duration,
                easing: easing,
                complete: complete,
                step: function(now, fx) {
                    fx.now = Math.round(now);
                    if (fx.prop !== "height") {
                        if (boxSizing === "content-box") {
                            adjust += fx.now;
                        }
                    } else if (that.options.heightStyle !== "content") {
                        fx.now = Math.round(total - toHide.outerHeight() - adjust);
                        adjust = 0;
                    }
                }
            });
        },
        _toggleComplete: function(data) {
            var toHide = data.oldPanel, prev = toHide.prev();
            this._removeClass(toHide, "ui-accordion-content-active");
            this._removeClass(prev, "ui-accordion-header-active")._addClass(prev, "ui-accordion-header-collapsed");
            if (toHide.length) {
                toHide.parent()[0].className = toHide.parent()[0].className;
            }
            this._trigger("activate", null, data);
        }
    });
    var safeActiveElement = $.ui.safeActiveElement = function(document) {
        var activeElement;
        try {
            activeElement = document.activeElement;
        } catch (error) {
            activeElement = document.body;
        }
        if (!activeElement) {
            activeElement = document.body;
        }
        if (!activeElement.nodeName) {
            activeElement = document.body;
        }
        return activeElement;
    };
    var widgetsMenu = $.widget("ui.menu", {
        version: "1.12.1",
        defaultElement: "<ul>",
        delay: 300,
        options: {
            icons: {
                submenu: "ui-icon-caret-1-e"
            },
            items: "> *",
            menus: "ul",
            position: {
                my: "left top",
                at: "right top"
            },
            role: "menu",
            blur: null,
            focus: null,
            select: null
        },
        _create: function() {
            this.activeMenu = this.element;
            this.mouseHandled = false;
            this.element.uniqueId().attr({
                role: this.options.role,
                tabIndex: 0
            });
            this._addClass("ui-menu", "ui-widget ui-widget-content");
            this._on({
                "mousedown .ui-menu-item": function(event) {
                    event.preventDefault();
                },
                "click .ui-menu-item": function(event) {
                    var target = $(event.target);
                    var active = $($.ui.safeActiveElement(this.document[0]));
                    if (!this.mouseHandled && target.not(".ui-state-disabled").length) {
                        this.select(event);
                        if (!event.isPropagationStopped()) {
                            this.mouseHandled = true;
                        }
                        if (target.has(".ui-menu").length) {
                            this.expand(event);
                        } else if (!this.element.is(":focus") && active.closest(".ui-menu").length) {
                            this.element.trigger("focus", [ true ]);
                            if (this.active && this.active.parents(".ui-menu").length === 1) {
                                clearTimeout(this.timer);
                            }
                        }
                    }
                },
                "mouseenter .ui-menu-item": function(event) {
                    if (this.previousFilter) {
                        return;
                    }
                    var actualTarget = $(event.target).closest(".ui-menu-item"), target = $(event.currentTarget);
                    if (actualTarget[0] !== target[0]) {
                        return;
                    }
                    this._removeClass(target.siblings().children(".ui-state-active"), null, "ui-state-active");
                    this.focus(event, target);
                },
                mouseleave: "collapseAll",
                "mouseleave .ui-menu": "collapseAll",
                focus: function(event, keepActiveItem) {
                    var item = this.active || this.element.find(this.options.items).eq(0);
                    if (!keepActiveItem) {
                        this.focus(event, item);
                    }
                },
                blur: function(event) {
                    this._delay(function() {
                        var notContained = !$.contains(this.element[0], $.ui.safeActiveElement(this.document[0]));
                        if (notContained) {
                            this.collapseAll(event);
                        }
                    });
                },
                keydown: "_keydown"
            });
            this.refresh();
            this._on(this.document, {
                click: function(event) {
                    if (this._closeOnDocumentClick(event)) {
                        this.collapseAll(event);
                    }
                    this.mouseHandled = false;
                }
            });
        },
        _destroy: function() {
            var items = this.element.find(".ui-menu-item").removeAttr("role aria-disabled"), submenus = items.children(".ui-menu-item-wrapper").removeUniqueId().removeAttr("tabIndex role aria-haspopup");
            this.element.removeAttr("aria-activedescendant").find(".ui-menu").addBack().removeAttr("role aria-labelledby aria-expanded aria-hidden aria-disabled " + "tabIndex").removeUniqueId().show();
            submenus.children().each(function() {
                var elem = $(this);
                if (elem.data("ui-menu-submenu-caret")) {
                    elem.remove();
                }
            });
        },
        _keydown: function(event) {
            var match, prev, character, skip, preventDefault = true;
            switch (event.keyCode) {
              case $.ui.keyCode.PAGE_UP:
                this.previousPage(event);
                break;

              case $.ui.keyCode.PAGE_DOWN:
                this.nextPage(event);
                break;

              case $.ui.keyCode.HOME:
                this._move("first", "first", event);
                break;

              case $.ui.keyCode.END:
                this._move("last", "last", event);
                break;

              case $.ui.keyCode.UP:
                this.previous(event);
                break;

              case $.ui.keyCode.DOWN:
                this.next(event);
                break;

              case $.ui.keyCode.LEFT:
                this.collapse(event);
                break;

              case $.ui.keyCode.RIGHT:
                if (this.active && !this.active.is(".ui-state-disabled")) {
                    this.expand(event);
                }
                break;

              case $.ui.keyCode.ENTER:
              case $.ui.keyCode.SPACE:
                this._activate(event);
                break;

              case $.ui.keyCode.ESCAPE:
                this.collapse(event);
                break;

              default:
                preventDefault = false;
                prev = this.previousFilter || "";
                skip = false;
                character = event.keyCode >= 96 && event.keyCode <= 105 ? (event.keyCode - 96).toString() : String.fromCharCode(event.keyCode);
                clearTimeout(this.filterTimer);
                if (character === prev) {
                    skip = true;
                } else {
                    character = prev + character;
                }
                match = this._filterMenuItems(character);
                match = skip && match.index(this.active.next()) !== -1 ? this.active.nextAll(".ui-menu-item") : match;
                if (!match.length) {
                    character = String.fromCharCode(event.keyCode);
                    match = this._filterMenuItems(character);
                }
                if (match.length) {
                    this.focus(event, match);
                    this.previousFilter = character;
                    this.filterTimer = this._delay(function() {
                        delete this.previousFilter;
                    }, 1e3);
                } else {
                    delete this.previousFilter;
                }
            }
            if (preventDefault) {
                event.preventDefault();
            }
        },
        _activate: function(event) {
            if (this.active && !this.active.is(".ui-state-disabled")) {
                if (this.active.children("[aria-haspopup='true']").length) {
                    this.expand(event);
                } else {
                    this.select(event);
                }
            }
        },
        refresh: function() {
            var menus, items, newSubmenus, newItems, newWrappers, that = this, icon = this.options.icons.submenu, submenus = this.element.find(this.options.menus);
            this._toggleClass("ui-menu-icons", null, !!this.element.find(".ui-icon").length);
            newSubmenus = submenus.filter(":not(.ui-menu)").hide().attr({
                role: this.options.role,
                "aria-hidden": "true",
                "aria-expanded": "false"
            }).each(function() {
                var menu = $(this), item = menu.prev(), submenuCaret = $("<span>").data("ui-menu-submenu-caret", true);
                that._addClass(submenuCaret, "ui-menu-icon", "ui-icon " + icon);
                item.attr("aria-haspopup", "true").prepend(submenuCaret);
                menu.attr("aria-labelledby", item.attr("id"));
            });
            this._addClass(newSubmenus, "ui-menu", "ui-widget ui-widget-content ui-front");
            menus = submenus.add(this.element);
            items = menus.find(this.options.items);
            items.not(".ui-menu-item").each(function() {
                var item = $(this);
                if (that._isDivider(item)) {
                    that._addClass(item, "ui-menu-divider", "ui-widget-content");
                }
            });
            newItems = items.not(".ui-menu-item, .ui-menu-divider");
            newWrappers = newItems.children().not(".ui-menu").uniqueId().attr({
                tabIndex: -1,
                role: this._itemRole()
            });
            this._addClass(newItems, "ui-menu-item")._addClass(newWrappers, "ui-menu-item-wrapper");
            items.filter(".ui-state-disabled").attr("aria-disabled", "true");
            if (this.active && !$.contains(this.element[0], this.active[0])) {
                this.blur();
            }
        },
        _itemRole: function() {
            return {
                menu: "menuitem",
                listbox: "option"
            }[this.options.role];
        },
        _setOption: function(key, value) {
            if (key === "icons") {
                var icons = this.element.find(".ui-menu-icon");
                this._removeClass(icons, null, this.options.icons.submenu)._addClass(icons, null, value.submenu);
            }
            this._super(key, value);
        },
        _setOptionDisabled: function(value) {
            this._super(value);
            this.element.attr("aria-disabled", String(value));
            this._toggleClass(null, "ui-state-disabled", !!value);
        },
        focus: function(event, item) {
            var nested, focused, activeParent;
            this.blur(event, event && event.type === "focus");
            this._scrollIntoView(item);
            this.active = item.first();
            focused = this.active.children(".ui-menu-item-wrapper");
            this._addClass(focused, null, "ui-state-active");
            if (this.options.role) {
                this.element.attr("aria-activedescendant", focused.attr("id"));
            }
            activeParent = this.active.parent().closest(".ui-menu-item").children(".ui-menu-item-wrapper");
            this._addClass(activeParent, null, "ui-state-active");
            if (event && event.type === "keydown") {
                this._close();
            } else {
                this.timer = this._delay(function() {
                    this._close();
                }, this.delay);
            }
            nested = item.children(".ui-menu");
            if (nested.length && event && /^mouse/.test(event.type)) {
                this._startOpening(nested);
            }
            this.activeMenu = item.parent();
            this._trigger("focus", event, {
                item: item
            });
        },
        _scrollIntoView: function(item) {
            var borderTop, paddingTop, offset, scroll, elementHeight, itemHeight;
            if (this._hasScroll()) {
                borderTop = parseFloat($.css(this.activeMenu[0], "borderTopWidth")) || 0;
                paddingTop = parseFloat($.css(this.activeMenu[0], "paddingTop")) || 0;
                offset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop;
                scroll = this.activeMenu.scrollTop();
                elementHeight = this.activeMenu.height();
                itemHeight = item.outerHeight();
                if (offset < 0) {
                    this.activeMenu.scrollTop(scroll + offset);
                } else if (offset + itemHeight > elementHeight) {
                    this.activeMenu.scrollTop(scroll + offset - elementHeight + itemHeight);
                }
            }
        },
        blur: function(event, fromFocus) {
            if (!fromFocus) {
                clearTimeout(this.timer);
            }
            if (!this.active) {
                return;
            }
            this._removeClass(this.active.children(".ui-menu-item-wrapper"), null, "ui-state-active");
            this._trigger("blur", event, {
                item: this.active
            });
            this.active = null;
        },
        _startOpening: function(submenu) {
            clearTimeout(this.timer);
            if (submenu.attr("aria-hidden") !== "true") {
                return;
            }
            this.timer = this._delay(function() {
                this._close();
                this._open(submenu);
            }, this.delay);
        },
        _open: function(submenu) {
            var position = $.extend({
                of: this.active
            }, this.options.position);
            clearTimeout(this.timer);
            this.element.find(".ui-menu").not(submenu.parents(".ui-menu")).hide().attr("aria-hidden", "true");
            submenu.show().removeAttr("aria-hidden").attr("aria-expanded", "true").position(position);
        },
        collapseAll: function(event, all) {
            clearTimeout(this.timer);
            this.timer = this._delay(function() {
                var currentMenu = all ? this.element : $(event && event.target).closest(this.element.find(".ui-menu"));
                if (!currentMenu.length) {
                    currentMenu = this.element;
                }
                this._close(currentMenu);
                this.blur(event);
                this._removeClass(currentMenu.find(".ui-state-active"), null, "ui-state-active");
                this.activeMenu = currentMenu;
            }, this.delay);
        },
        _close: function(startMenu) {
            if (!startMenu) {
                startMenu = this.active ? this.active.parent() : this.element;
            }
            startMenu.find(".ui-menu").hide().attr("aria-hidden", "true").attr("aria-expanded", "false");
        },
        _closeOnDocumentClick: function(event) {
            return !$(event.target).closest(".ui-menu").length;
        },
        _isDivider: function(item) {
            return !/[^\-\u2014\u2013\s]/.test(item.text());
        },
        collapse: function(event) {
            var newItem = this.active && this.active.parent().closest(".ui-menu-item", this.element);
            if (newItem && newItem.length) {
                this._close();
                this.focus(event, newItem);
            }
        },
        expand: function(event) {
            var newItem = this.active && this.active.children(".ui-menu ").find(this.options.items).first();
            if (newItem && newItem.length) {
                this._open(newItem.parent());
                this._delay(function() {
                    this.focus(event, newItem);
                });
            }
        },
        next: function(event) {
            this._move("next", "first", event);
        },
        previous: function(event) {
            this._move("prev", "last", event);
        },
        isFirstItem: function() {
            return this.active && !this.active.prevAll(".ui-menu-item").length;
        },
        isLastItem: function() {
            return this.active && !this.active.nextAll(".ui-menu-item").length;
        },
        _move: function(direction, filter, event) {
            var next;
            if (this.active) {
                if (direction === "first" || direction === "last") {
                    next = this.active[direction === "first" ? "prevAll" : "nextAll"](".ui-menu-item").eq(-1);
                } else {
                    next = this.active[direction + "All"](".ui-menu-item").eq(0);
                }
            }
            if (!next || !next.length || !this.active) {
                next = this.activeMenu.find(this.options.items)[filter]();
            }
            this.focus(event, next);
        },
        nextPage: function(event) {
            var item, base, height;
            if (!this.active) {
                this.next(event);
                return;
            }
            if (this.isLastItem()) {
                return;
            }
            if (this._hasScroll()) {
                base = this.active.offset().top;
                height = this.element.height();
                this.active.nextAll(".ui-menu-item").each(function() {
                    item = $(this);
                    return item.offset().top - base - height < 0;
                });
                this.focus(event, item);
            } else {
                this.focus(event, this.activeMenu.find(this.options.items)[!this.active ? "first" : "last"]());
            }
        },
        previousPage: function(event) {
            var item, base, height;
            if (!this.active) {
                this.next(event);
                return;
            }
            if (this.isFirstItem()) {
                return;
            }
            if (this._hasScroll()) {
                base = this.active.offset().top;
                height = this.element.height();
                this.active.prevAll(".ui-menu-item").each(function() {
                    item = $(this);
                    return item.offset().top - base + height > 0;
                });
                this.focus(event, item);
            } else {
                this.focus(event, this.activeMenu.find(this.options.items).first());
            }
        },
        _hasScroll: function() {
            return this.element.outerHeight() < this.element.prop("scrollHeight");
        },
        select: function(event) {
            this.active = this.active || $(event.target).closest(".ui-menu-item");
            var ui = {
                item: this.active
            };
            if (!this.active.has(".ui-menu").length) {
                this.collapseAll(event, true);
            }
            this._trigger("select", event, ui);
        },
        _filterMenuItems: function(character) {
            var escapedCharacter = character.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&"), regex = new RegExp("^" + escapedCharacter, "i");
            return this.activeMenu.find(this.options.items).filter(".ui-menu-item").filter(function() {
                return regex.test($.trim($(this).children(".ui-menu-item-wrapper").text()));
            });
        }
    });
    $.widget("ui.autocomplete", {
        version: "1.12.1",
        defaultElement: "<input>",
        options: {
            appendTo: null,
            autoFocus: false,
            delay: 300,
            minLength: 1,
            position: {
                my: "left top",
                at: "left bottom",
                collision: "none"
            },
            source: null,
            change: null,
            close: null,
            focus: null,
            open: null,
            response: null,
            search: null,
            select: null
        },
        requestIndex: 0,
        pending: 0,
        _create: function() {
            var suppressKeyPress, suppressKeyPressRepeat, suppressInput, nodeName = this.element[0].nodeName.toLowerCase(), isTextarea = nodeName === "textarea", isInput = nodeName === "input";
            this.isMultiLine = isTextarea || !isInput && this._isContentEditable(this.element);
            this.valueMethod = this.element[isTextarea || isInput ? "val" : "text"];
            this.isNewMenu = true;
            this._addClass("ui-autocomplete-input");
            this.element.attr("autocomplete", "off");
            this._on(this.element, {
                keydown: function(event) {
                    if (this.element.prop("readOnly")) {
                        suppressKeyPress = true;
                        suppressInput = true;
                        suppressKeyPressRepeat = true;
                        return;
                    }
                    suppressKeyPress = false;
                    suppressInput = false;
                    suppressKeyPressRepeat = false;
                    var keyCode = $.ui.keyCode;
                    switch (event.keyCode) {
                      case keyCode.PAGE_UP:
                        suppressKeyPress = true;
                        this._move("previousPage", event);
                        break;

                      case keyCode.PAGE_DOWN:
                        suppressKeyPress = true;
                        this._move("nextPage", event);
                        break;

                      case keyCode.UP:
                        suppressKeyPress = true;
                        this._keyEvent("previous", event);
                        break;

                      case keyCode.DOWN:
                        suppressKeyPress = true;
                        this._keyEvent("next", event);
                        break;

                      case keyCode.ENTER:
                        if (this.menu.active) {
                            suppressKeyPress = true;
                            event.preventDefault();
                            this.menu.select(event);
                        }
                        break;

                      case keyCode.TAB:
                        if (this.menu.active) {
                            this.menu.select(event);
                        }
                        break;

                      case keyCode.ESCAPE:
                        if (this.menu.element.is(":visible")) {
                            if (!this.isMultiLine) {
                                this._value(this.term);
                            }
                            this.close(event);
                            event.preventDefault();
                        }
                        break;

                      default:
                        suppressKeyPressRepeat = true;
                        this._searchTimeout(event);
                        break;
                    }
                },
                keypress: function(event) {
                    if (suppressKeyPress) {
                        suppressKeyPress = false;
                        if (!this.isMultiLine || this.menu.element.is(":visible")) {
                            event.preventDefault();
                        }
                        return;
                    }
                    if (suppressKeyPressRepeat) {
                        return;
                    }
                    var keyCode = $.ui.keyCode;
                    switch (event.keyCode) {
                      case keyCode.PAGE_UP:
                        this._move("previousPage", event);
                        break;

                      case keyCode.PAGE_DOWN:
                        this._move("nextPage", event);
                        break;

                      case keyCode.UP:
                        this._keyEvent("previous", event);
                        break;

                      case keyCode.DOWN:
                        this._keyEvent("next", event);
                        break;
                    }
                },
                input: function(event) {
                    if (suppressInput) {
                        suppressInput = false;
                        event.preventDefault();
                        return;
                    }
                    this._searchTimeout(event);
                },
                focus: function() {
                    this.selectedItem = null;
                    this.previous = this._value();
                },
                blur: function(event) {
                    if (this.cancelBlur) {
                        delete this.cancelBlur;
                        return;
                    }
                    clearTimeout(this.searching);
                    this.close(event);
                    this._change(event);
                }
            });
            this._initSource();
            this.menu = $("<ul>").appendTo(this._appendTo()).menu({
                role: null
            }).hide().menu("instance");
            this._addClass(this.menu.element, "ui-autocomplete", "ui-front");
            this._on(this.menu.element, {
                mousedown: function(event) {
                    event.preventDefault();
                    this.cancelBlur = true;
                    this._delay(function() {
                        delete this.cancelBlur;
                        if (this.element[0] !== $.ui.safeActiveElement(this.document[0])) {
                            this.element.trigger("focus");
                        }
                    });
                },
                menufocus: function(event, ui) {
                    var label, item;
                    if (this.isNewMenu) {
                        this.isNewMenu = false;
                        if (event.originalEvent && /^mouse/.test(event.originalEvent.type)) {
                            this.menu.blur();
                            this.document.one("mousemove", function() {
                                $(event.target).trigger(event.originalEvent);
                            });
                            return;
                        }
                    }
                    item = ui.item.data("ui-autocomplete-item");
                    if (false !== this._trigger("focus", event, {
                        item: item
                    })) {
                        if (event.originalEvent && /^key/.test(event.originalEvent.type)) {
                            this._value(item.value);
                        }
                    }
                    label = ui.item.attr("aria-label") || item.value;
                    if (label && $.trim(label).length) {
                        this.liveRegion.children().hide();
                        $("<div>").text(label).appendTo(this.liveRegion);
                    }
                },
                menuselect: function(event, ui) {
                    var item = ui.item.data("ui-autocomplete-item"), previous = this.previous;
                    if (this.element[0] !== $.ui.safeActiveElement(this.document[0])) {
                        this.element.trigger("focus");
                        this.previous = previous;
                        this._delay(function() {
                            this.previous = previous;
                            this.selectedItem = item;
                        });
                    }
                    if (false !== this._trigger("select", event, {
                        item: item
                    })) {
                        this._value(item.value);
                    }
                    this.term = this._value();
                    this.close(event);
                    this.selectedItem = item;
                }
            });
            this.liveRegion = $("<div>", {
                role: "status",
                "aria-live": "assertive",
                "aria-relevant": "additions"
            }).appendTo(this.document[0].body);
            this._addClass(this.liveRegion, null, "ui-helper-hidden-accessible");
            this._on(this.window, {
                beforeunload: function() {
                    this.element.removeAttr("autocomplete");
                }
            });
        },
        _destroy: function() {
            clearTimeout(this.searching);
            this.element.removeAttr("autocomplete");
            this.menu.element.remove();
            this.liveRegion.remove();
        },
        _setOption: function(key, value) {
            this._super(key, value);
            if (key === "source") {
                this._initSource();
            }
            if (key === "appendTo") {
                this.menu.element.appendTo(this._appendTo());
            }
            if (key === "disabled" && value && this.xhr) {
                this.xhr.abort();
            }
        },
        _isEventTargetInWidget: function(event) {
            var menuElement = this.menu.element[0];
            return event.target === this.element[0] || event.target === menuElement || $.contains(menuElement, event.target);
        },
        _closeOnClickOutside: function(event) {
            if (!this._isEventTargetInWidget(event)) {
                this.close();
            }
        },
        _appendTo: function() {
            var element = this.options.appendTo;
            if (element) {
                element = element.jquery || element.nodeType ? $(element) : this.document.find(element).eq(0);
            }
            if (!element || !element[0]) {
                element = this.element.closest(".ui-front, dialog");
            }
            if (!element.length) {
                element = this.document[0].body;
            }
            return element;
        },
        _initSource: function() {
            var array, url, that = this;
            if ($.isArray(this.options.source)) {
                array = this.options.source;
                this.source = function(request, response) {
                    response($.ui.autocomplete.filter(array, request.term));
                };
            } else if (typeof this.options.source === "string") {
                url = this.options.source;
                this.source = function(request, response) {
                    if (that.xhr) {
                        that.xhr.abort();
                    }
                    that.xhr = $.ajax({
                        url: url,
                        data: request,
                        dataType: "json",
                        success: function(data) {
                            response(data);
                        },
                        error: function() {
                            response([]);
                        }
                    });
                };
            } else {
                this.source = this.options.source;
            }
        },
        _searchTimeout: function(event) {
            clearTimeout(this.searching);
            this.searching = this._delay(function() {
                var equalValues = this.term === this._value(), menuVisible = this.menu.element.is(":visible"), modifierKey = event.altKey || event.ctrlKey || event.metaKey || event.shiftKey;
                if (!equalValues || equalValues && !menuVisible && !modifierKey) {
                    this.selectedItem = null;
                    this.search(null, event);
                }
            }, this.options.delay);
        },
        search: function(value, event) {
            value = value != null ? value : this._value();
            this.term = this._value();
            if (value.length < this.options.minLength) {
                return this.close(event);
            }
            if (this._trigger("search", event) === false) {
                return;
            }
            return this._search(value);
        },
        _search: function(value) {
            this.pending++;
            this._addClass("ui-autocomplete-loading");
            this.cancelSearch = false;
            this.source({
                term: value
            }, this._response());
        },
        _response: function() {
            var index = ++this.requestIndex;
            return $.proxy(function(content) {
                if (index === this.requestIndex) {
                    this.__response(content);
                }
                this.pending--;
                if (!this.pending) {
                    this._removeClass("ui-autocomplete-loading");
                }
            }, this);
        },
        __response: function(content) {
            if (content) {
                content = this._normalize(content);
            }
            this._trigger("response", null, {
                content: content
            });
            if (!this.options.disabled && content && content.length && !this.cancelSearch) {
                this._suggest(content);
                this._trigger("open");
            } else {
                this._close();
            }
        },
        close: function(event) {
            this.cancelSearch = true;
            this._close(event);
        },
        _close: function(event) {
            this._off(this.document, "mousedown");
            if (this.menu.element.is(":visible")) {
                this.menu.element.hide();
                this.menu.blur();
                this.isNewMenu = true;
                this._trigger("close", event);
            }
        },
        _change: function(event) {
            if (this.previous !== this._value()) {
                this._trigger("change", event, {
                    item: this.selectedItem
                });
            }
        },
        _normalize: function(items) {
            if (items.length && items[0].label && items[0].value) {
                return items;
            }
            return $.map(items, function(item) {
                if (typeof item === "string") {
                    return {
                        label: item,
                        value: item
                    };
                }
                return $.extend({}, item, {
                    label: item.label || item.value,
                    value: item.value || item.label
                });
            });
        },
        _suggest: function(items) {
            var ul = this.menu.element.empty();
            this._renderMenu(ul, items);
            this.isNewMenu = true;
            this.menu.refresh();
            ul.show();
            this._resizeMenu();
            ul.position($.extend({
                of: this.element
            }, this.options.position));
            if (this.options.autoFocus) {
                this.menu.next();
            }
            this._on(this.document, {
                mousedown: "_closeOnClickOutside"
            });
        },
        _resizeMenu: function() {
            var ul = this.menu.element;
            ul.outerWidth(Math.max(ul.width("").outerWidth() + 1, this.element.outerWidth()));
        },
        _renderMenu: function(ul, items) {
            var that = this;
            $.each(items, function(index, item) {
                that._renderItemData(ul, item);
            });
        },
        _renderItemData: function(ul, item) {
            return this._renderItem(ul, item).data("ui-autocomplete-item", item);
        },
        _renderItem: function(ul, item) {
            return $("<li>").append($("<div>").text(item.label)).appendTo(ul);
        },
        _move: function(direction, event) {
            if (!this.menu.element.is(":visible")) {
                this.search(null, event);
                return;
            }
            if (this.menu.isFirstItem() && /^previous/.test(direction) || this.menu.isLastItem() && /^next/.test(direction)) {
                if (!this.isMultiLine) {
                    this._value(this.term);
                }
                this.menu.blur();
                return;
            }
            this.menu[direction](event);
        },
        widget: function() {
            return this.menu.element;
        },
        _value: function() {
            return this.valueMethod.apply(this.element, arguments);
        },
        _keyEvent: function(keyEvent, event) {
            if (!this.isMultiLine || this.menu.element.is(":visible")) {
                this._move(keyEvent, event);
                event.preventDefault();
            }
        },
        _isContentEditable: function(element) {
            if (!element.length) {
                return false;
            }
            var editable = element.prop("contentEditable");
            if (editable === "inherit") {
                return this._isContentEditable(element.parent());
            }
            return editable === "true";
        }
    });
    $.extend($.ui.autocomplete, {
        escapeRegex: function(value) {
            return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
        },
        filter: function(array, term) {
            var matcher = new RegExp($.ui.autocomplete.escapeRegex(term), "i");
            return $.grep(array, function(value) {
                return matcher.test(value.label || value.value || value);
            });
        }
    });
    $.widget("ui.autocomplete", $.ui.autocomplete, {
        options: {
            messages: {
                noResults: "No search results.",
                results: function(amount) {
                    return amount + (amount > 1 ? " results are" : " result is") + " available, use up and down arrow keys to navigate.";
                }
            }
        },
        __response: function(content) {
            var message;
            this._superApply(arguments);
            if (this.options.disabled || this.cancelSearch) {
                return;
            }
            if (content && content.length) {
                message = this.options.messages.results(content.length);
            } else {
                message = this.options.messages.noResults;
            }
            this.liveRegion.children().hide();
            $("<div>").text(message).appendTo(this.liveRegion);
        }
    });
    var widgetsAutocomplete = $.ui.autocomplete;
    var controlgroupCornerRegex = /ui-corner-([a-z]){2,6}/g;
    var widgetsControlgroup = $.widget("ui.controlgroup", {
        version: "1.12.1",
        defaultElement: "<div>",
        options: {
            direction: "horizontal",
            disabled: null,
            onlyVisible: true,
            items: {
                button: "input[type=button], input[type=submit], input[type=reset], button, a",
                controlgroupLabel: ".ui-controlgroup-label",
                checkboxradio: "input[type='checkbox'], input[type='radio']",
                selectmenu: "select",
                spinner: ".ui-spinner-input"
            }
        },
        _create: function() {
            this._enhance();
        },
        _enhance: function() {
            this.element.attr("role", "toolbar");
            this.refresh();
        },
        _destroy: function() {
            this._callChildMethod("destroy");
            this.childWidgets.removeData("ui-controlgroup-data");
            this.element.removeAttr("role");
            if (this.options.items.controlgroupLabel) {
                this.element.find(this.options.items.controlgroupLabel).find(".ui-controlgroup-label-contents").contents().unwrap();
            }
        },
        _initWidgets: function() {
            var that = this, childWidgets = [];
            $.each(this.options.items, function(widget, selector) {
                var labels;
                var options = {};
                if (!selector) {
                    return;
                }
                if (widget === "controlgroupLabel") {
                    labels = that.element.find(selector);
                    labels.each(function() {
                        var element = $(this);
                        if (element.children(".ui-controlgroup-label-contents").length) {
                            return;
                        }
                        element.contents().wrapAll("<span class='ui-controlgroup-label-contents'></span>");
                    });
                    that._addClass(labels, null, "ui-widget ui-widget-content ui-state-default");
                    childWidgets = childWidgets.concat(labels.get());
                    return;
                }
                if (!$.fn[widget]) {
                    return;
                }
                if (that["_" + widget + "Options"]) {
                    options = that["_" + widget + "Options"]("middle");
                } else {
                    options = {
                        classes: {}
                    };
                }
                that.element.find(selector).each(function() {
                    var element = $(this);
                    var instance = element[widget]("instance");
                    var instanceOptions = $.widget.extend({}, options);
                    if (widget === "button" && element.parent(".ui-spinner").length) {
                        return;
                    }
                    if (!instance) {
                        instance = element[widget]()[widget]("instance");
                    }
                    if (instance) {
                        instanceOptions.classes = that._resolveClassesValues(instanceOptions.classes, instance);
                    }
                    element[widget](instanceOptions);
                    var widgetElement = element[widget]("widget");
                    $.data(widgetElement[0], "ui-controlgroup-data", instance ? instance : element[widget]("instance"));
                    childWidgets.push(widgetElement[0]);
                });
            });
            this.childWidgets = $($.unique(childWidgets));
            this._addClass(this.childWidgets, "ui-controlgroup-item");
        },
        _callChildMethod: function(method) {
            this.childWidgets.each(function() {
                var element = $(this), data = element.data("ui-controlgroup-data");
                if (data && data[method]) {
                    data[method]();
                }
            });
        },
        _updateCornerClass: function(element, position) {
            var remove = "ui-corner-top ui-corner-bottom ui-corner-left ui-corner-right ui-corner-all";
            var add = this._buildSimpleOptions(position, "label").classes.label;
            this._removeClass(element, null, remove);
            this._addClass(element, null, add);
        },
        _buildSimpleOptions: function(position, key) {
            var direction = this.options.direction === "vertical";
            var result = {
                classes: {}
            };
            result.classes[key] = {
                middle: "",
                first: "ui-corner-" + (direction ? "top" : "left"),
                last: "ui-corner-" + (direction ? "bottom" : "right"),
                only: "ui-corner-all"
            }[position];
            return result;
        },
        _spinnerOptions: function(position) {
            var options = this._buildSimpleOptions(position, "ui-spinner");
            options.classes["ui-spinner-up"] = "";
            options.classes["ui-spinner-down"] = "";
            return options;
        },
        _buttonOptions: function(position) {
            return this._buildSimpleOptions(position, "ui-button");
        },
        _checkboxradioOptions: function(position) {
            return this._buildSimpleOptions(position, "ui-checkboxradio-label");
        },
        _selectmenuOptions: function(position) {
            var direction = this.options.direction === "vertical";
            return {
                width: direction ? "auto" : false,
                classes: {
                    middle: {
                        "ui-selectmenu-button-open": "",
                        "ui-selectmenu-button-closed": ""
                    },
                    first: {
                        "ui-selectmenu-button-open": "ui-corner-" + (direction ? "top" : "tl"),
                        "ui-selectmenu-button-closed": "ui-corner-" + (direction ? "top" : "left")
                    },
                    last: {
                        "ui-selectmenu-button-open": direction ? "" : "ui-corner-tr",
                        "ui-selectmenu-button-closed": "ui-corner-" + (direction ? "bottom" : "right")
                    },
                    only: {
                        "ui-selectmenu-button-open": "ui-corner-top",
                        "ui-selectmenu-button-closed": "ui-corner-all"
                    }
                }[position]
            };
        },
        _resolveClassesValues: function(classes, instance) {
            var result = {};
            $.each(classes, function(key) {
                var current = instance.options.classes[key] || "";
                current = $.trim(current.replace(controlgroupCornerRegex, ""));
                result[key] = (current + " " + classes[key]).replace(/\s+/g, " ");
            });
            return result;
        },
        _setOption: function(key, value) {
            if (key === "direction") {
                this._removeClass("ui-controlgroup-" + this.options.direction);
            }
            this._super(key, value);
            if (key === "disabled") {
                this._callChildMethod(value ? "disable" : "enable");
                return;
            }
            this.refresh();
        },
        refresh: function() {
            var children, that = this;
            this._addClass("ui-controlgroup ui-controlgroup-" + this.options.direction);
            if (this.options.direction === "horizontal") {
                this._addClass(null, "ui-helper-clearfix");
            }
            this._initWidgets();
            children = this.childWidgets;
            if (this.options.onlyVisible) {
                children = children.filter(":visible");
            }
            if (children.length) {
                $.each([ "first", "last" ], function(index, value) {
                    var instance = children[value]().data("ui-controlgroup-data");
                    if (instance && that["_" + instance.widgetName + "Options"]) {
                        var options = that["_" + instance.widgetName + "Options"](children.length === 1 ? "only" : value);
                        options.classes = that._resolveClassesValues(options.classes, instance);
                        instance.element[instance.widgetName](options);
                    } else {
                        that._updateCornerClass(children[value](), value);
                    }
                });
                this._callChildMethod("refresh");
            }
        }
    });
    $.widget("ui.checkboxradio", [ $.ui.formResetMixin, {
        version: "1.12.1",
        options: {
            disabled: null,
            label: null,
            icon: true,
            classes: {
                "ui-checkboxradio-label": "ui-corner-all",
                "ui-checkboxradio-icon": "ui-corner-all"
            }
        },
        _getCreateOptions: function() {
            var disabled, labels;
            var that = this;
            var options = this._super() || {};
            this._readType();
            labels = this.element.labels();
            this.label = $(labels[labels.length - 1]);
            if (!this.label.length) {
                $.error("No label found for checkboxradio widget");
            }
            this.originalLabel = "";
            this.label.contents().not(this.element[0]).each(function() {
                that.originalLabel += this.nodeType === 3 ? $(this).text() : this.outerHTML;
            });
            if (this.originalLabel) {
                options.label = this.originalLabel;
            }
            disabled = this.element[0].disabled;
            if (disabled != null) {
                options.disabled = disabled;
            }
            return options;
        },
        _create: function() {
            var checked = this.element[0].checked;
            this._bindFormResetHandler();
            if (this.options.disabled == null) {
                this.options.disabled = this.element[0].disabled;
            }
            this._setOption("disabled", this.options.disabled);
            this._addClass("ui-checkboxradio", "ui-helper-hidden-accessible");
            this._addClass(this.label, "ui-checkboxradio-label", "ui-button ui-widget");
            if (this.type === "radio") {
                this._addClass(this.label, "ui-checkboxradio-radio-label");
            }
            if (this.options.label && this.options.label !== this.originalLabel) {
                this._updateLabel();
            } else if (this.originalLabel) {
                this.options.label = this.originalLabel;
            }
            this._enhance();
            if (checked) {
                this._addClass(this.label, "ui-checkboxradio-checked", "ui-state-active");
                if (this.icon) {
                    this._addClass(this.icon, null, "ui-state-hover");
                }
            }
            this._on({
                change: "_toggleClasses",
                focus: function() {
                    this._addClass(this.label, null, "ui-state-focus ui-visual-focus");
                },
                blur: function() {
                    this._removeClass(this.label, null, "ui-state-focus ui-visual-focus");
                }
            });
        },
        _readType: function() {
            var nodeName = this.element[0].nodeName.toLowerCase();
            this.type = this.element[0].type;
            if (nodeName !== "input" || !/radio|checkbox/.test(this.type)) {
                $.error("Can't create checkboxradio on element.nodeName=" + nodeName + " and element.type=" + this.type);
            }
        },
        _enhance: function() {
            this._updateIcon(this.element[0].checked);
        },
        widget: function() {
            return this.label;
        },
        _getRadioGroup: function() {
            var group;
            var name = this.element[0].name;
            var nameSelector = "input[name='" + $.ui.escapeSelector(name) + "']";
            if (!name) {
                return $([]);
            }
            if (this.form.length) {
                group = $(this.form[0].elements).filter(nameSelector);
            } else {
                group = $(nameSelector).filter(function() {
                    return $(this).form().length === 0;
                });
            }
            return group.not(this.element);
        },
        _toggleClasses: function() {
            var checked = this.element[0].checked;
            this._toggleClass(this.label, "ui-checkboxradio-checked", "ui-state-active", checked);
            if (this.options.icon && this.type === "checkbox") {
                this._toggleClass(this.icon, null, "ui-icon-check ui-state-checked", checked)._toggleClass(this.icon, null, "ui-icon-blank", !checked);
            }
            if (this.type === "radio") {
                this._getRadioGroup().each(function() {
                    var instance = $(this).checkboxradio("instance");
                    if (instance) {
                        instance._removeClass(instance.label, "ui-checkboxradio-checked", "ui-state-active");
                    }
                });
            }
        },
        _destroy: function() {
            this._unbindFormResetHandler();
            if (this.icon) {
                this.icon.remove();
                this.iconSpace.remove();
            }
        },
        _setOption: function(key, value) {
            if (key === "label" && !value) {
                return;
            }
            this._super(key, value);
            if (key === "disabled") {
                this._toggleClass(this.label, null, "ui-state-disabled", value);
                this.element[0].disabled = value;
                return;
            }
            this.refresh();
        },
        _updateIcon: function(checked) {
            var toAdd = "ui-icon ui-icon-background ";
            if (this.options.icon) {
                if (!this.icon) {
                    this.icon = $("<span>");
                    this.iconSpace = $("<span> </span>");
                    this._addClass(this.iconSpace, "ui-checkboxradio-icon-space");
                }
                if (this.type === "checkbox") {
                    toAdd += checked ? "ui-icon-check ui-state-checked" : "ui-icon-blank";
                    this._removeClass(this.icon, null, checked ? "ui-icon-blank" : "ui-icon-check");
                } else {
                    toAdd += "ui-icon-blank";
                }
                this._addClass(this.icon, "ui-checkboxradio-icon", toAdd);
                if (!checked) {
                    this._removeClass(this.icon, null, "ui-icon-check ui-state-checked");
                }
                this.icon.prependTo(this.label).after(this.iconSpace);
            } else if (this.icon !== undefined) {
                this.icon.remove();
                this.iconSpace.remove();
                delete this.icon;
            }
        },
        _updateLabel: function() {
            var contents = this.label.contents().not(this.element[0]);
            if (this.icon) {
                contents = contents.not(this.icon[0]);
            }
            if (this.iconSpace) {
                contents = contents.not(this.iconSpace[0]);
            }
            contents.remove();
            this.label.append(this.options.label);
        },
        refresh: function() {
            var checked = this.element[0].checked, isDisabled = this.element[0].disabled;
            this._updateIcon(checked);
            this._toggleClass(this.label, "ui-checkboxradio-checked", "ui-state-active", checked);
            if (this.options.label !== null) {
                this._updateLabel();
            }
            if (isDisabled !== this.options.disabled) {
                this._setOptions({
                    disabled: isDisabled
                });
            }
        }
    } ]);
    var widgetsCheckboxradio = $.ui.checkboxradio;
    $.widget("ui.button", {
        version: "1.12.1",
        defaultElement: "<button>",
        options: {
            classes: {
                "ui-button": "ui-corner-all"
            },
            disabled: null,
            icon: null,
            iconPosition: "beginning",
            label: null,
            showLabel: true
        },
        _getCreateOptions: function() {
            var disabled, options = this._super() || {};
            this.isInput = this.element.is("input");
            disabled = this.element[0].disabled;
            if (disabled != null) {
                options.disabled = disabled;
            }
            this.originalLabel = this.isInput ? this.element.val() : this.element.html();
            if (this.originalLabel) {
                options.label = this.originalLabel;
            }
            return options;
        },
        _create: function() {
            if (!this.option.showLabel & !this.options.icon) {
                this.options.showLabel = true;
            }
            if (this.options.disabled == null) {
                this.options.disabled = this.element[0].disabled || false;
            }
            this.hasTitle = !!this.element.attr("title");
            if (this.options.label && this.options.label !== this.originalLabel) {
                if (this.isInput) {
                    this.element.val(this.options.label);
                } else {
                    this.element.html(this.options.label);
                }
            }
            this._addClass("ui-button", "ui-widget");
            this._setOption("disabled", this.options.disabled);
            this._enhance();
            if (this.element.is("a")) {
                this._on({
                    keyup: function(event) {
                        if (event.keyCode === $.ui.keyCode.SPACE) {
                            event.preventDefault();
                            if (this.element[0].click) {
                                this.element[0].click();
                            } else {
                                this.element.trigger("click");
                            }
                        }
                    }
                });
            }
        },
        _enhance: function() {
            if (!this.element.is("button")) {
                this.element.attr("role", "button");
            }
            if (this.options.icon) {
                this._updateIcon("icon", this.options.icon);
                this._updateTooltip();
            }
        },
        _updateTooltip: function() {
            this.title = this.element.attr("title");
            if (!this.options.showLabel && !this.title) {
                this.element.attr("title", this.options.label);
            }
        },
        _updateIcon: function(option, value) {
            var icon = option !== "iconPosition", position = icon ? this.options.iconPosition : value, displayBlock = position === "top" || position === "bottom";
            if (!this.icon) {
                this.icon = $("<span>");
                this._addClass(this.icon, "ui-button-icon", "ui-icon");
                if (!this.options.showLabel) {
                    this._addClass("ui-button-icon-only");
                }
            } else if (icon) {
                this._removeClass(this.icon, null, this.options.icon);
            }
            if (icon) {
                this._addClass(this.icon, null, value);
            }
            this._attachIcon(position);
            if (displayBlock) {
                this._addClass(this.icon, null, "ui-widget-icon-block");
                if (this.iconSpace) {
                    this.iconSpace.remove();
                }
            } else {
                if (!this.iconSpace) {
                    this.iconSpace = $("<span> </span>");
                    this._addClass(this.iconSpace, "ui-button-icon-space");
                }
                this._removeClass(this.icon, null, "ui-wiget-icon-block");
                this._attachIconSpace(position);
            }
        },
        _destroy: function() {
            this.element.removeAttr("role");
            if (this.icon) {
                this.icon.remove();
            }
            if (this.iconSpace) {
                this.iconSpace.remove();
            }
            if (!this.hasTitle) {
                this.element.removeAttr("title");
            }
        },
        _attachIconSpace: function(iconPosition) {
            this.icon[/^(?:end|bottom)/.test(iconPosition) ? "before" : "after"](this.iconSpace);
        },
        _attachIcon: function(iconPosition) {
            this.element[/^(?:end|bottom)/.test(iconPosition) ? "append" : "prepend"](this.icon);
        },
        _setOptions: function(options) {
            var newShowLabel = options.showLabel === undefined ? this.options.showLabel : options.showLabel, newIcon = options.icon === undefined ? this.options.icon : options.icon;
            if (!newShowLabel && !newIcon) {
                options.showLabel = true;
            }
            this._super(options);
        },
        _setOption: function(key, value) {
            if (key === "icon") {
                if (value) {
                    this._updateIcon(key, value);
                } else if (this.icon) {
                    this.icon.remove();
                    if (this.iconSpace) {
                        this.iconSpace.remove();
                    }
                }
            }
            if (key === "iconPosition") {
                this._updateIcon(key, value);
            }
            if (key === "showLabel") {
                this._toggleClass("ui-button-icon-only", null, !value);
                this._updateTooltip();
            }
            if (key === "label") {
                if (this.isInput) {
                    this.element.val(value);
                } else {
                    this.element.html(value);
                    if (this.icon) {
                        this._attachIcon(this.options.iconPosition);
                        this._attachIconSpace(this.options.iconPosition);
                    }
                }
            }
            this._super(key, value);
            if (key === "disabled") {
                this._toggleClass(null, "ui-state-disabled", value);
                this.element[0].disabled = value;
                if (value) {
                    this.element.blur();
                }
            }
        },
        refresh: function() {
            var isDisabled = this.element.is("input, button") ? this.element[0].disabled : this.element.hasClass("ui-button-disabled");
            if (isDisabled !== this.options.disabled) {
                this._setOptions({
                    disabled: isDisabled
                });
            }
            this._updateTooltip();
        }
    });
    if ($.uiBackCompat !== false) {
        $.widget("ui.button", $.ui.button, {
            options: {
                text: true,
                icons: {
                    primary: null,
                    secondary: null
                }
            },
            _create: function() {
                if (this.options.showLabel && !this.options.text) {
                    this.options.showLabel = this.options.text;
                }
                if (!this.options.showLabel && this.options.text) {
                    this.options.text = this.options.showLabel;
                }
                if (!this.options.icon && (this.options.icons.primary || this.options.icons.secondary)) {
                    if (this.options.icons.primary) {
                        this.options.icon = this.options.icons.primary;
                    } else {
                        this.options.icon = this.options.icons.secondary;
                        this.options.iconPosition = "end";
                    }
                } else if (this.options.icon) {
                    this.options.icons.primary = this.options.icon;
                }
                this._super();
            },
            _setOption: function(key, value) {
                if (key === "text") {
                    this._super("showLabel", value);
                    return;
                }
                if (key === "showLabel") {
                    this.options.text = value;
                }
                if (key === "icon") {
                    this.options.icons.primary = value;
                }
                if (key === "icons") {
                    if (value.primary) {
                        this._super("icon", value.primary);
                        this._super("iconPosition", "beginning");
                    } else if (value.secondary) {
                        this._super("icon", value.secondary);
                        this._super("iconPosition", "end");
                    }
                }
                this._superApply(arguments);
            }
        });
        $.fn.button = function(orig) {
            return function() {
                if (!this.length || this.length && this[0].tagName !== "INPUT" || this.length && this[0].tagName === "INPUT" && (this.attr("type") !== "checkbox" && this.attr("type") !== "radio")) {
                    return orig.apply(this, arguments);
                }
                if (!$.ui.checkboxradio) {
                    $.error("Checkboxradio widget missing");
                }
                if (arguments.length === 0) {
                    return this.checkboxradio({
                        icon: false
                    });
                }
                return this.checkboxradio.apply(this, arguments);
            };
        }($.fn.button);
        $.fn.buttonset = function() {
            if (!$.ui.controlgroup) {
                $.error("Controlgroup widget missing");
            }
            if (arguments[0] === "option" && arguments[1] === "items" && arguments[2]) {
                return this.controlgroup.apply(this, [ arguments[0], "items.button", arguments[2] ]);
            }
            if (arguments[0] === "option" && arguments[1] === "items") {
                return this.controlgroup.apply(this, [ arguments[0], "items.button" ]);
            }
            if (typeof arguments[0] === "object" && arguments[0].items) {
                arguments[0].items = {
                    button: arguments[0].items
                };
            }
            return this.controlgroup.apply(this, arguments);
        };
    }
    var widgetsButton = $.ui.button;
    $.extend($.ui, {
        datepicker: {
            version: "1.12.1"
        }
    });
    var datepicker_instActive;
    function datepicker_getZindex(elem) {
        var position, value;
        while (elem.length && elem[0] !== document) {
            position = elem.css("position");
            if (position === "absolute" || position === "relative" || position === "fixed") {
                value = parseInt(elem.css("zIndex"), 10);
                if (!isNaN(value) && value !== 0) {
                    return value;
                }
            }
            elem = elem.parent();
        }
        return 0;
    }
    function Datepicker() {
        this._curInst = null;
        this._keyEvent = false;
        this._disabledInputs = [];
        this._datepickerShowing = false;
        this._inDialog = false;
        this._mainDivId = "ui-datepicker-div";
        this._inlineClass = "ui-datepicker-inline";
        this._appendClass = "ui-datepicker-append";
        this._triggerClass = "ui-datepicker-trigger";
        this._dialogClass = "ui-datepicker-dialog";
        this._disableClass = "ui-datepicker-disabled";
        this._unselectableClass = "ui-datepicker-unselectable";
        this._currentClass = "ui-datepicker-current-day";
        this._dayOverClass = "ui-datepicker-days-cell-over";
        this.regional = [];
        this.regional[""] = {
            closeText: "Done",
            prevText: "Prev",
            nextText: "Next",
            currentText: "Today",
            monthNames: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
            monthNamesShort: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ],
            dayNames: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
            dayNamesShort: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
            dayNamesMin: [ "Su", "Mo", "Tu", "We", "Th", "Fr", "Sa" ],
            weekHeader: "Wk",
            dateFormat: "mm/dd/yy",
            firstDay: 0,
            isRTL: false,
            showMonthAfterYear: false,
            yearSuffix: ""
        };
        this._defaults = {
            showOn: "focus",
            showAnim: "fadeIn",
            showOptions: {},
            defaultDate: null,
            appendText: "",
            buttonText: "...",
            buttonImage: "",
            buttonImageOnly: false,
            hideIfNoPrevNext: false,
            navigationAsDateFormat: false,
            gotoCurrent: false,
            changeMonth: false,
            changeYear: false,
            yearRange: "c-10:c+10",
            showOtherMonths: false,
            selectOtherMonths: false,
            showWeek: false,
            calculateWeek: this.iso8601Week,
            shortYearCutoff: "+10",
            minDate: null,
            maxDate: null,
            duration: "fast",
            beforeShowDay: null,
            beforeShow: null,
            onSelect: null,
            onChangeMonthYear: null,
            onClose: null,
            numberOfMonths: 1,
            showCurrentAtPos: 0,
            stepMonths: 1,
            stepBigMonths: 12,
            altField: "",
            altFormat: "",
            constrainInput: true,
            showButtonPanel: false,
            autoSize: false,
            disabled: false
        };
        $.extend(this._defaults, this.regional[""]);
        this.regional.en = $.extend(true, {}, this.regional[""]);
        this.regional["en-US"] = $.extend(true, {}, this.regional.en);
        this.dpDiv = datepicker_bindHover($("<div id='" + this._mainDivId + "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"));
    }
    $.extend(Datepicker.prototype, {
        markerClassName: "hasDatepicker",
        maxRows: 4,
        _widgetDatepicker: function() {
            return this.dpDiv;
        },
        setDefaults: function(settings) {
            datepicker_extendRemove(this._defaults, settings || {});
            return this;
        },
        _attachDatepicker: function(target, settings) {
            var nodeName, inline, inst;
            nodeName = target.nodeName.toLowerCase();
            inline = nodeName === "div" || nodeName === "span";
            if (!target.id) {
                this.uuid += 1;
                target.id = "dp" + this.uuid;
            }
            inst = this._newInst($(target), inline);
            inst.settings = $.extend({}, settings || {});
            if (nodeName === "input") {
                this._connectDatepicker(target, inst);
            } else if (inline) {
                this._inlineDatepicker(target, inst);
            }
        },
        _newInst: function(target, inline) {
            var id = target[0].id.replace(/([^A-Za-z0-9_\-])/g, "\\\\$1");
            return {
                id: id,
                input: target,
                selectedDay: 0,
                selectedMonth: 0,
                selectedYear: 0,
                drawMonth: 0,
                drawYear: 0,
                inline: inline,
                dpDiv: !inline ? this.dpDiv : datepicker_bindHover($("<div class='" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"))
            };
        },
        _connectDatepicker: function(target, inst) {
            var input = $(target);
            inst.append = $([]);
            inst.trigger = $([]);
            if (input.hasClass(this.markerClassName)) {
                return;
            }
            this._attachments(input, inst);
            input.addClass(this.markerClassName).on("keydown", this._doKeyDown).on("keypress", this._doKeyPress).on("keyup", this._doKeyUp);
            this._autoSize(inst);
            $.data(target, "datepicker", inst);
            if (inst.settings.disabled) {
                this._disableDatepicker(target);
            }
        },
        _attachments: function(input, inst) {
            var showOn, buttonText, buttonImage, appendText = this._get(inst, "appendText"), isRTL = this._get(inst, "isRTL");
            if (inst.append) {
                inst.append.remove();
            }
            if (appendText) {
                inst.append = $("<span class='" + this._appendClass + "'>" + appendText + "</span>");
                input[isRTL ? "before" : "after"](inst.append);
            }
            input.off("focus", this._showDatepicker);
            if (inst.trigger) {
                inst.trigger.remove();
            }
            showOn = this._get(inst, "showOn");
            if (showOn === "focus" || showOn === "both") {
                input.on("focus", this._showDatepicker);
            }
            if (showOn === "button" || showOn === "both") {
                buttonText = this._get(inst, "buttonText");
                buttonImage = this._get(inst, "buttonImage");
                inst.trigger = $(this._get(inst, "buttonImageOnly") ? $("<img/>").addClass(this._triggerClass).attr({
                    src: buttonImage,
                    alt: buttonText,
                    title: buttonText
                }) : $("<button type='button'></button>").addClass(this._triggerClass).html(!buttonImage ? buttonText : $("<img/>").attr({
                    src: buttonImage,
                    alt: buttonText,
                    title: buttonText
                })));
                input[isRTL ? "before" : "after"](inst.trigger);
                inst.trigger.on("click", function() {
                    if ($.datepicker._datepickerShowing && $.datepicker._lastInput === input[0]) {
                        $.datepicker._hideDatepicker();
                    } else if ($.datepicker._datepickerShowing && $.datepicker._lastInput !== input[0]) {
                        $.datepicker._hideDatepicker();
                        $.datepicker._showDatepicker(input[0]);
                    } else {
                        $.datepicker._showDatepicker(input[0]);
                    }
                    return false;
                });
            }
        },
        _autoSize: function(inst) {
            if (this._get(inst, "autoSize") && !inst.inline) {
                var findMax, max, maxI, i, date = new Date(2009, 12 - 1, 20), dateFormat = this._get(inst, "dateFormat");
                if (dateFormat.match(/[DM]/)) {
                    findMax = function(names) {
                        max = 0;
                        maxI = 0;
                        for (i = 0; i < names.length; i++) {
                            if (names[i].length > max) {
                                max = names[i].length;
                                maxI = i;
                            }
                        }
                        return maxI;
                    };
                    date.setMonth(findMax(this._get(inst, dateFormat.match(/MM/) ? "monthNames" : "monthNamesShort")));
                    date.setDate(findMax(this._get(inst, dateFormat.match(/DD/) ? "dayNames" : "dayNamesShort")) + 20 - date.getDay());
                }
                inst.input.attr("size", this._formatDate(inst, date).length);
            }
        },
        _inlineDatepicker: function(target, inst) {
            var divSpan = $(target);
            if (divSpan.hasClass(this.markerClassName)) {
                return;
            }
            divSpan.addClass(this.markerClassName).append(inst.dpDiv);
            $.data(target, "datepicker", inst);
            this._setDate(inst, this._getDefaultDate(inst), true);
            this._updateDatepicker(inst);
            this._updateAlternate(inst);
            if (inst.settings.disabled) {
                this._disableDatepicker(target);
            }
            inst.dpDiv.css("display", "block");
        },
        _dialogDatepicker: function(input, date, onSelect, settings, pos) {
            var id, browserWidth, browserHeight, scrollX, scrollY, inst = this._dialogInst;
            if (!inst) {
                this.uuid += 1;
                id = "dp" + this.uuid;
                this._dialogInput = $("<input type='text' id='" + id + "' style='position: absolute; top: -100px; width: 0px;'/>");
                this._dialogInput.on("keydown", this._doKeyDown);
                $("body").append(this._dialogInput);
                inst = this._dialogInst = this._newInst(this._dialogInput, false);
                inst.settings = {};
                $.data(this._dialogInput[0], "datepicker", inst);
            }
            datepicker_extendRemove(inst.settings, settings || {});
            date = date && date.constructor === Date ? this._formatDate(inst, date) : date;
            this._dialogInput.val(date);
            this._pos = pos ? pos.length ? pos : [ pos.pageX, pos.pageY ] : null;
            if (!this._pos) {
                browserWidth = document.documentElement.clientWidth;
                browserHeight = document.documentElement.clientHeight;
                scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
                scrollY = document.documentElement.scrollTop || document.body.scrollTop;
                this._pos = [ browserWidth / 2 - 100 + scrollX, browserHeight / 2 - 150 + scrollY ];
            }
            this._dialogInput.css("left", this._pos[0] + 20 + "px").css("top", this._pos[1] + "px");
            inst.settings.onSelect = onSelect;
            this._inDialog = true;
            this.dpDiv.addClass(this._dialogClass);
            this._showDatepicker(this._dialogInput[0]);
            if ($.blockUI) {
                $.blockUI(this.dpDiv);
            }
            $.data(this._dialogInput[0], "datepicker", inst);
            return this;
        },
        _destroyDatepicker: function(target) {
            var nodeName, $target = $(target), inst = $.data(target, "datepicker");
            if (!$target.hasClass(this.markerClassName)) {
                return;
            }
            nodeName = target.nodeName.toLowerCase();
            $.removeData(target, "datepicker");
            if (nodeName === "input") {
                inst.append.remove();
                inst.trigger.remove();
                $target.removeClass(this.markerClassName).off("focus", this._showDatepicker).off("keydown", this._doKeyDown).off("keypress", this._doKeyPress).off("keyup", this._doKeyUp);
            } else if (nodeName === "div" || nodeName === "span") {
                $target.removeClass(this.markerClassName).empty();
            }
            if (datepicker_instActive === inst) {
                datepicker_instActive = null;
            }
        },
        _enableDatepicker: function(target) {
            var nodeName, inline, $target = $(target), inst = $.data(target, "datepicker");
            if (!$target.hasClass(this.markerClassName)) {
                return;
            }
            nodeName = target.nodeName.toLowerCase();
            if (nodeName === "input") {
                target.disabled = false;
                inst.trigger.filter("button").each(function() {
                    this.disabled = false;
                }).end().filter("img").css({
                    opacity: "1.0",
                    cursor: ""
                });
            } else if (nodeName === "div" || nodeName === "span") {
                inline = $target.children("." + this._inlineClass);
                inline.children().removeClass("ui-state-disabled");
                inline.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled", false);
            }
            this._disabledInputs = $.map(this._disabledInputs, function(value) {
                return value === target ? null : value;
            });
        },
        _disableDatepicker: function(target) {
            var nodeName, inline, $target = $(target), inst = $.data(target, "datepicker");
            if (!$target.hasClass(this.markerClassName)) {
                return;
            }
            nodeName = target.nodeName.toLowerCase();
            if (nodeName === "input") {
                target.disabled = true;
                inst.trigger.filter("button").each(function() {
                    this.disabled = true;
                }).end().filter("img").css({
                    opacity: "0.5",
                    cursor: "default"
                });
            } else if (nodeName === "div" || nodeName === "span") {
                inline = $target.children("." + this._inlineClass);
                inline.children().addClass("ui-state-disabled");
                inline.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled", true);
            }
            this._disabledInputs = $.map(this._disabledInputs, function(value) {
                return value === target ? null : value;
            });
            this._disabledInputs[this._disabledInputs.length] = target;
        },
        _isDisabledDatepicker: function(target) {
            if (!target) {
                return false;
            }
            for (var i = 0; i < this._disabledInputs.length; i++) {
                if (this._disabledInputs[i] === target) {
                    return true;
                }
            }
            return false;
        },
        _getInst: function(target) {
            try {
                return $.data(target, "datepicker");
            } catch (err) {
                throw "Missing instance data for this datepicker";
            }
        },
        _optionDatepicker: function(target, name, value) {
            var settings, date, minDate, maxDate, inst = this._getInst(target);
            if (arguments.length === 2 && typeof name === "string") {
                return name === "defaults" ? $.extend({}, $.datepicker._defaults) : inst ? name === "all" ? $.extend({}, inst.settings) : this._get(inst, name) : null;
            }
            settings = name || {};
            if (typeof name === "string") {
                settings = {};
                settings[name] = value;
            }
            if (inst) {
                if (this._curInst === inst) {
                    this._hideDatepicker();
                }
                date = this._getDateDatepicker(target, true);
                minDate = this._getMinMaxDate(inst, "min");
                maxDate = this._getMinMaxDate(inst, "max");
                datepicker_extendRemove(inst.settings, settings);
                if (minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined) {
                    inst.settings.minDate = this._formatDate(inst, minDate);
                }
                if (maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined) {
                    inst.settings.maxDate = this._formatDate(inst, maxDate);
                }
                if ("disabled" in settings) {
                    if (settings.disabled) {
                        this._disableDatepicker(target);
                    } else {
                        this._enableDatepicker(target);
                    }
                }
                this._attachments($(target), inst);
                this._autoSize(inst);
                this._setDate(inst, date);
                this._updateAlternate(inst);
                this._updateDatepicker(inst);
            }
        },
        _changeDatepicker: function(target, name, value) {
            this._optionDatepicker(target, name, value);
        },
        _refreshDatepicker: function(target) {
            var inst = this._getInst(target);
            if (inst) {
                this._updateDatepicker(inst);
            }
        },
        _setDateDatepicker: function(target, date) {
            var inst = this._getInst(target);
            if (inst) {
                this._setDate(inst, date);
                this._updateDatepicker(inst);
                this._updateAlternate(inst);
            }
        },
        _getDateDatepicker: function(target, noDefault) {
            var inst = this._getInst(target);
            if (inst && !inst.inline) {
                this._setDateFromField(inst, noDefault);
            }
            return inst ? this._getDate(inst) : null;
        },
        _doKeyDown: function(event) {
            var onSelect, dateStr, sel, inst = $.datepicker._getInst(event.target), handled = true, isRTL = inst.dpDiv.is(".ui-datepicker-rtl");
            inst._keyEvent = true;
            if ($.datepicker._datepickerShowing) {
                switch (event.keyCode) {
                  case 9:
                    $.datepicker._hideDatepicker();
                    handled = false;
                    break;

                  case 13:
                    sel = $("td." + $.datepicker._dayOverClass + ":not(." + $.datepicker._currentClass + ")", inst.dpDiv);
                    if (sel[0]) {
                        $.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);
                    }
                    onSelect = $.datepicker._get(inst, "onSelect");
                    if (onSelect) {
                        dateStr = $.datepicker._formatDate(inst);
                        onSelect.apply(inst.input ? inst.input[0] : null, [ dateStr, inst ]);
                    } else {
                        $.datepicker._hideDatepicker();
                    }
                    return false;

                  case 27:
                    $.datepicker._hideDatepicker();
                    break;

                  case 33:
                    $.datepicker._adjustDate(event.target, event.ctrlKey ? -$.datepicker._get(inst, "stepBigMonths") : -$.datepicker._get(inst, "stepMonths"), "M");
                    break;

                  case 34:
                    $.datepicker._adjustDate(event.target, event.ctrlKey ? +$.datepicker._get(inst, "stepBigMonths") : +$.datepicker._get(inst, "stepMonths"), "M");
                    break;

                  case 35:
                    if (event.ctrlKey || event.metaKey) {
                        $.datepicker._clearDate(event.target);
                    }
                    handled = event.ctrlKey || event.metaKey;
                    break;

                  case 36:
                    if (event.ctrlKey || event.metaKey) {
                        $.datepicker._gotoToday(event.target);
                    }
                    handled = event.ctrlKey || event.metaKey;
                    break;

                  case 37:
                    if (event.ctrlKey || event.metaKey) {
                        $.datepicker._adjustDate(event.target, isRTL ? +1 : -1, "D");
                    }
                    handled = event.ctrlKey || event.metaKey;
                    if (event.originalEvent.altKey) {
                        $.datepicker._adjustDate(event.target, event.ctrlKey ? -$.datepicker._get(inst, "stepBigMonths") : -$.datepicker._get(inst, "stepMonths"), "M");
                    }
                    break;

                  case 38:
                    if (event.ctrlKey || event.metaKey) {
                        $.datepicker._adjustDate(event.target, -7, "D");
                    }
                    handled = event.ctrlKey || event.metaKey;
                    break;

                  case 39:
                    if (event.ctrlKey || event.metaKey) {
                        $.datepicker._adjustDate(event.target, isRTL ? -1 : +1, "D");
                    }
                    handled = event.ctrlKey || event.metaKey;
                    if (event.originalEvent.altKey) {
                        $.datepicker._adjustDate(event.target, event.ctrlKey ? +$.datepicker._get(inst, "stepBigMonths") : +$.datepicker._get(inst, "stepMonths"), "M");
                    }
                    break;

                  case 40:
                    if (event.ctrlKey || event.metaKey) {
                        $.datepicker._adjustDate(event.target, +7, "D");
                    }
                    handled = event.ctrlKey || event.metaKey;
                    break;

                  default:
                    handled = false;
                }
            } else if (event.keyCode === 36 && event.ctrlKey) {
                $.datepicker._showDatepicker(this);
            } else {
                handled = false;
            }
            if (handled) {
                event.preventDefault();
                event.stopPropagation();
            }
        },
        _doKeyPress: function(event) {
            var chars, chr, inst = $.datepicker._getInst(event.target);
            if ($.datepicker._get(inst, "constrainInput")) {
                chars = $.datepicker._possibleChars($.datepicker._get(inst, "dateFormat"));
                chr = String.fromCharCode(event.charCode == null ? event.keyCode : event.charCode);
                return event.ctrlKey || event.metaKey || (chr < " " || !chars || chars.indexOf(chr) > -1);
            }
        },
        _doKeyUp: function(event) {
            var date, inst = $.datepicker._getInst(event.target);
            if (inst.input.val() !== inst.lastVal) {
                try {
                    date = $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"), inst.input ? inst.input.val() : null, $.datepicker._getFormatConfig(inst));
                    if (date) {
                        $.datepicker._setDateFromField(inst);
                        $.datepicker._updateAlternate(inst);
                        $.datepicker._updateDatepicker(inst);
                    }
                } catch (err) {}
            }
            return true;
        },
        _showDatepicker: function(input) {
            input = input.target || input;
            if (input.nodeName.toLowerCase() !== "input") {
                input = $("input", input.parentNode)[0];
            }
            if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput === input) {
                return;
            }
            var inst, beforeShow, beforeShowSettings, isFixed, offset, showAnim, duration;
            inst = $.datepicker._getInst(input);
            if ($.datepicker._curInst && $.datepicker._curInst !== inst) {
                $.datepicker._curInst.dpDiv.stop(true, true);
                if (inst && $.datepicker._datepickerShowing) {
                    $.datepicker._hideDatepicker($.datepicker._curInst.input[0]);
                }
            }
            beforeShow = $.datepicker._get(inst, "beforeShow");
            beforeShowSettings = beforeShow ? beforeShow.apply(input, [ input, inst ]) : {};
            if (beforeShowSettings === false) {
                return;
            }
            datepicker_extendRemove(inst.settings, beforeShowSettings);
            inst.lastVal = null;
            $.datepicker._lastInput = input;
            $.datepicker._setDateFromField(inst);
            if ($.datepicker._inDialog) {
                input.value = "";
            }
            if (!$.datepicker._pos) {
                $.datepicker._pos = $.datepicker._findPos(input);
                $.datepicker._pos[1] += input.offsetHeight;
            }
            isFixed = false;
            $(input).parents().each(function() {
                isFixed |= $(this).css("position") === "fixed";
                return !isFixed;
            });
            offset = {
                left: $.datepicker._pos[0],
                top: $.datepicker._pos[1]
            };
            $.datepicker._pos = null;
            inst.dpDiv.empty();
            inst.dpDiv.css({
                position: "absolute",
                display: "block",
                top: "-1000px"
            });
            $.datepicker._updateDatepicker(inst);
            offset = $.datepicker._checkOffset(inst, offset, isFixed);
            inst.dpDiv.css({
                position: $.datepicker._inDialog && $.blockUI ? "static" : isFixed ? "fixed" : "absolute",
                display: "none",
                left: offset.left + "px",
                top: offset.top + "px"
            });
            if (!inst.inline) {
                showAnim = $.datepicker._get(inst, "showAnim");
                duration = $.datepicker._get(inst, "duration");
                inst.dpDiv.css("z-index", datepicker_getZindex($(input)) + 1);
                $.datepicker._datepickerShowing = true;
                if ($.effects && $.effects.effect[showAnim]) {
                    inst.dpDiv.show(showAnim, $.datepicker._get(inst, "showOptions"), duration);
                } else {
                    inst.dpDiv[showAnim || "show"](showAnim ? duration : null);
                }
                if ($.datepicker._shouldFocusInput(inst)) {
                    inst.input.trigger("focus");
                }
                $.datepicker._curInst = inst;
            }
        },
        _updateDatepicker: function(inst) {
            this.maxRows = 4;
            datepicker_instActive = inst;
            inst.dpDiv.empty().append(this._generateHTML(inst));
            this._attachHandlers(inst);
            var origyearshtml, numMonths = this._getNumberOfMonths(inst), cols = numMonths[1], width = 17, activeCell = inst.dpDiv.find("." + this._dayOverClass + " a");
            if (activeCell.length > 0) {
                datepicker_handleMouseover.apply(activeCell.get(0));
            }
            inst.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width("");
            if (cols > 1) {
                inst.dpDiv.addClass("ui-datepicker-multi-" + cols).css("width", width * cols + "em");
            }
            inst.dpDiv[(numMonths[0] !== 1 || numMonths[1] !== 1 ? "add" : "remove") + "Class"]("ui-datepicker-multi");
            inst.dpDiv[(this._get(inst, "isRTL") ? "add" : "remove") + "Class"]("ui-datepicker-rtl");
            if (inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput(inst)) {
                inst.input.trigger("focus");
            }
            if (inst.yearshtml) {
                origyearshtml = inst.yearshtml;
                setTimeout(function() {
                    if (origyearshtml === inst.yearshtml && inst.yearshtml) {
                        inst.dpDiv.find("select.ui-datepicker-year:first").replaceWith(inst.yearshtml);
                    }
                    origyearshtml = inst.yearshtml = null;
                }, 0);
            }
        },
        _shouldFocusInput: function(inst) {
            return inst.input && inst.input.is(":visible") && !inst.input.is(":disabled") && !inst.input.is(":focus");
        },
        _checkOffset: function(inst, offset, isFixed) {
            var dpWidth = inst.dpDiv.outerWidth(), dpHeight = inst.dpDiv.outerHeight(), inputWidth = inst.input ? inst.input.outerWidth() : 0, inputHeight = inst.input ? inst.input.outerHeight() : 0, viewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft()), viewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop());
            offset.left -= this._get(inst, "isRTL") ? dpWidth - inputWidth : 0;
            offset.left -= isFixed && offset.left === inst.input.offset().left ? $(document).scrollLeft() : 0;
            offset.top -= isFixed && offset.top === inst.input.offset().top + inputHeight ? $(document).scrollTop() : 0;
            offset.left -= Math.min(offset.left, offset.left + dpWidth > viewWidth && viewWidth > dpWidth ? Math.abs(offset.left + dpWidth - viewWidth) : 0);
            offset.top -= Math.min(offset.top, offset.top + dpHeight > viewHeight && viewHeight > dpHeight ? Math.abs(dpHeight + inputHeight) : 0);
            return offset;
        },
        _findPos: function(obj) {
            var position, inst = this._getInst(obj), isRTL = this._get(inst, "isRTL");
            while (obj && (obj.type === "hidden" || obj.nodeType !== 1 || $.expr.filters.hidden(obj))) {
                obj = obj[isRTL ? "previousSibling" : "nextSibling"];
            }
            position = $(obj).offset();
            return [ position.left, position.top ];
        },
        _hideDatepicker: function(input) {
            var showAnim, duration, postProcess, onClose, inst = this._curInst;
            if (!inst || input && inst !== $.data(input, "datepicker")) {
                return;
            }
            if (this._datepickerShowing) {
                showAnim = this._get(inst, "showAnim");
                duration = this._get(inst, "duration");
                postProcess = function() {
                    $.datepicker._tidyDialog(inst);
                };
                if ($.effects && ($.effects.effect[showAnim] || $.effects[showAnim])) {
                    inst.dpDiv.hide(showAnim, $.datepicker._get(inst, "showOptions"), duration, postProcess);
                } else {
                    inst.dpDiv[showAnim === "slideDown" ? "slideUp" : showAnim === "fadeIn" ? "fadeOut" : "hide"](showAnim ? duration : null, postProcess);
                }
                if (!showAnim) {
                    postProcess();
                }
                this._datepickerShowing = false;
                onClose = this._get(inst, "onClose");
                if (onClose) {
                    onClose.apply(inst.input ? inst.input[0] : null, [ inst.input ? inst.input.val() : "", inst ]);
                }
                this._lastInput = null;
                if (this._inDialog) {
                    this._dialogInput.css({
                        position: "absolute",
                        left: "0",
                        top: "-100px"
                    });
                    if ($.blockUI) {
                        $.unblockUI();
                        $("body").append(this.dpDiv);
                    }
                }
                this._inDialog = false;
            }
        },
        _tidyDialog: function(inst) {
            inst.dpDiv.removeClass(this._dialogClass).off(".ui-datepicker-calendar");
        },
        _checkExternalClick: function(event) {
            if (!$.datepicker._curInst) {
                return;
            }
            var $target = $(event.target), inst = $.datepicker._getInst($target[0]);
            if ($target[0].id !== $.datepicker._mainDivId && $target.parents("#" + $.datepicker._mainDivId).length === 0 && !$target.hasClass($.datepicker.markerClassName) && !$target.closest("." + $.datepicker._triggerClass).length && $.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI) || $target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst !== inst) {
                $.datepicker._hideDatepicker();
            }
        },
        _adjustDate: function(id, offset, period) {
            var target = $(id), inst = this._getInst(target[0]);
            if (this._isDisabledDatepicker(target[0])) {
                return;
            }
            this._adjustInstDate(inst, offset + (period === "M" ? this._get(inst, "showCurrentAtPos") : 0), period);
            this._updateDatepicker(inst);
        },
        _gotoToday: function(id) {
            var date, target = $(id), inst = this._getInst(target[0]);
            if (this._get(inst, "gotoCurrent") && inst.currentDay) {
                inst.selectedDay = inst.currentDay;
                inst.drawMonth = inst.selectedMonth = inst.currentMonth;
                inst.drawYear = inst.selectedYear = inst.currentYear;
            } else {
                date = new Date();
                inst.selectedDay = date.getDate();
                inst.drawMonth = inst.selectedMonth = date.getMonth();
                inst.drawYear = inst.selectedYear = date.getFullYear();
            }
            this._notifyChange(inst);
            this._adjustDate(target);
        },
        _selectMonthYear: function(id, select, period) {
            var target = $(id), inst = this._getInst(target[0]);
            inst["selected" + (period === "M" ? "Month" : "Year")] = inst["draw" + (period === "M" ? "Month" : "Year")] = parseInt(select.options[select.selectedIndex].value, 10);
            this._notifyChange(inst);
            this._adjustDate(target);
        },
        _selectDay: function(id, month, year, td) {
            var inst, target = $(id);
            if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {
                return;
            }
            inst = this._getInst(target[0]);
            inst.selectedDay = inst.currentDay = $("a", td).html();
            inst.selectedMonth = inst.currentMonth = month;
            inst.selectedYear = inst.currentYear = year;
            this._selectDate(id, this._formatDate(inst, inst.currentDay, inst.currentMonth, inst.currentYear));
        },
        _clearDate: function(id) {
            var target = $(id);
            this._selectDate(target, "");
        },
        _selectDate: function(id, dateStr) {
            var onSelect, target = $(id), inst = this._getInst(target[0]);
            dateStr = dateStr != null ? dateStr : this._formatDate(inst);
            if (inst.input) {
                inst.input.val(dateStr);
            }
            this._updateAlternate(inst);
            onSelect = this._get(inst, "onSelect");
            if (onSelect) {
                onSelect.apply(inst.input ? inst.input[0] : null, [ dateStr, inst ]);
            } else if (inst.input) {
                inst.input.trigger("change");
            }
            if (inst.inline) {
                this._updateDatepicker(inst);
            } else {
                this._hideDatepicker();
                this._lastInput = inst.input[0];
                if (typeof inst.input[0] !== "object") {
                    inst.input.trigger("focus");
                }
                this._lastInput = null;
            }
        },
        _updateAlternate: function(inst) {
            var altFormat, date, dateStr, altField = this._get(inst, "altField");
            if (altField) {
                altFormat = this._get(inst, "altFormat") || this._get(inst, "dateFormat");
                date = this._getDate(inst);
                dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));
                $(altField).val(dateStr);
            }
        },
        noWeekends: function(date) {
            var day = date.getDay();
            return [ day > 0 && day < 6, "" ];
        },
        iso8601Week: function(date) {
            var time, checkDate = new Date(date.getTime());
            checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
            time = checkDate.getTime();
            checkDate.setMonth(0);
            checkDate.setDate(1);
            return Math.floor(Math.round((time - checkDate) / 864e5) / 7) + 1;
        },
        parseDate: function(format, value, settings) {
            if (format == null || value == null) {
                throw "Invalid arguments";
            }
            value = typeof value === "object" ? value.toString() : value + "";
            if (value === "") {
                return null;
            }
            var iFormat, dim, extra, iValue = 0, shortYearCutoffTemp = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff, shortYearCutoff = typeof shortYearCutoffTemp !== "string" ? shortYearCutoffTemp : new Date().getFullYear() % 100 + parseInt(shortYearCutoffTemp, 10), dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort, dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames, monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort, monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames, year = -1, month = -1, day = -1, doy = -1, literal = false, date, lookAhead = function(match) {
                var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;
                if (matches) {
                    iFormat++;
                }
                return matches;
            }, getNumber = function(match) {
                var isDoubled = lookAhead(match), size = match === "@" ? 14 : match === "!" ? 20 : match === "y" && isDoubled ? 4 : match === "o" ? 3 : 2, minSize = match === "y" ? size : 1, digits = new RegExp("^\\d{" + minSize + "," + size + "}"), num = value.substring(iValue).match(digits);
                if (!num) {
                    throw "Missing number at position " + iValue;
                }
                iValue += num[0].length;
                return parseInt(num[0], 10);
            }, getName = function(match, shortNames, longNames) {
                var index = -1, names = $.map(lookAhead(match) ? longNames : shortNames, function(v, k) {
                    return [ [ k, v ] ];
                }).sort(function(a, b) {
                    return -(a[1].length - b[1].length);
                });
                $.each(names, function(i, pair) {
                    var name = pair[1];
                    if (value.substr(iValue, name.length).toLowerCase() === name.toLowerCase()) {
                        index = pair[0];
                        iValue += name.length;
                        return false;
                    }
                });
                if (index !== -1) {
                    return index + 1;
                } else {
                    throw "Unknown name at position " + iValue;
                }
            }, checkLiteral = function() {
                if (value.charAt(iValue) !== format.charAt(iFormat)) {
                    throw "Unexpected literal at position " + iValue;
                }
                iValue++;
            };
            for (iFormat = 0; iFormat < format.length; iFormat++) {
                if (literal) {
                    if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
                        literal = false;
                    } else {
                        checkLiteral();
                    }
                } else {
                    switch (format.charAt(iFormat)) {
                      case "d":
                        day = getNumber("d");
                        break;

                      case "D":
                        getName("D", dayNamesShort, dayNames);
                        break;

                      case "o":
                        doy = getNumber("o");
                        break;

                      case "m":
                        month = getNumber("m");
                        break;

                      case "M":
                        month = getName("M", monthNamesShort, monthNames);
                        break;

                      case "y":
                        year = getNumber("y");
                        break;

                      case "@":
                        date = new Date(getNumber("@"));
                        year = date.getFullYear();
                        month = date.getMonth() + 1;
                        day = date.getDate();
                        break;

                      case "!":
                        date = new Date((getNumber("!") - this._ticksTo1970) / 1e4);
                        year = date.getFullYear();
                        month = date.getMonth() + 1;
                        day = date.getDate();
                        break;

                      case "'":
                        if (lookAhead("'")) {
                            checkLiteral();
                        } else {
                            literal = true;
                        }
                        break;

                      default:
                        checkLiteral();
                    }
                }
            }
            if (iValue < value.length) {
                extra = value.substr(iValue);
                if (!/^\s+/.test(extra)) {
                    throw "Extra/unparsed characters found in date: " + extra;
                }
            }
            if (year === -1) {
                year = new Date().getFullYear();
            } else if (year < 100) {
                year += new Date().getFullYear() - new Date().getFullYear() % 100 + (year <= shortYearCutoff ? 0 : -100);
            }
            if (doy > -1) {
                month = 1;
                day = doy;
                do {
                    dim = this._getDaysInMonth(year, month - 1);
                    if (day <= dim) {
                        break;
                    }
                    month++;
                    day -= dim;
                } while (true);
            }
            date = this._daylightSavingAdjust(new Date(year, month - 1, day));
            if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) {
                throw "Invalid date";
            }
            return date;
        },
        ATOM: "yy-mm-dd",
        COOKIE: "D, dd M yy",
        ISO_8601: "yy-mm-dd",
        RFC_822: "D, d M y",
        RFC_850: "DD, dd-M-y",
        RFC_1036: "D, d M y",
        RFC_1123: "D, d M yy",
        RFC_2822: "D, d M yy",
        RSS: "D, d M y",
        TICKS: "!",
        TIMESTAMP: "@",
        W3C: "yy-mm-dd",
        _ticksTo1970: ((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) + Math.floor(1970 / 400)) * 24 * 60 * 60 * 1e7,
        formatDate: function(format, date, settings) {
            if (!date) {
                return "";
            }
            var iFormat, dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort, dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames, monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort, monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames, lookAhead = function(match) {
                var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;
                if (matches) {
                    iFormat++;
                }
                return matches;
            }, formatNumber = function(match, value, len) {
                var num = "" + value;
                if (lookAhead(match)) {
                    while (num.length < len) {
                        num = "0" + num;
                    }
                }
                return num;
            }, formatName = function(match, value, shortNames, longNames) {
                return lookAhead(match) ? longNames[value] : shortNames[value];
            }, output = "", literal = false;
            if (date) {
                for (iFormat = 0; iFormat < format.length; iFormat++) {
                    if (literal) {
                        if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
                            literal = false;
                        } else {
                            output += format.charAt(iFormat);
                        }
                    } else {
                        switch (format.charAt(iFormat)) {
                          case "d":
                            output += formatNumber("d", date.getDate(), 2);
                            break;

                          case "D":
                            output += formatName("D", date.getDay(), dayNamesShort, dayNames);
                            break;

                          case "o":
                            output += formatNumber("o", Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 864e5), 3);
                            break;

                          case "m":
                            output += formatNumber("m", date.getMonth() + 1, 2);
                            break;

                          case "M":
                            output += formatName("M", date.getMonth(), monthNamesShort, monthNames);
                            break;

                          case "y":
                            output += lookAhead("y") ? date.getFullYear() : (date.getFullYear() % 100 < 10 ? "0" : "") + date.getFullYear() % 100;
                            break;

                          case "@":
                            output += date.getTime();
                            break;

                          case "!":
                            output += date.getTime() * 1e4 + this._ticksTo1970;
                            break;

                          case "'":
                            if (lookAhead("'")) {
                                output += "'";
                            } else {
                                literal = true;
                            }
                            break;

                          default:
                            output += format.charAt(iFormat);
                        }
                    }
                }
            }
            return output;
        },
        _possibleChars: function(format) {
            var iFormat, chars = "", literal = false, lookAhead = function(match) {
                var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;
                if (matches) {
                    iFormat++;
                }
                return matches;
            };
            for (iFormat = 0; iFormat < format.length; iFormat++) {
                if (literal) {
                    if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
                        literal = false;
                    } else {
                        chars += format.charAt(iFormat);
                    }
                } else {
                    switch (format.charAt(iFormat)) {
                      case "d":
                      case "m":
                      case "y":
                      case "@":
                        chars += "0123456789";
                        break;

                      case "D":
                      case "M":
                        return null;

                      case "'":
                        if (lookAhead("'")) {
                            chars += "'";
                        } else {
                            literal = true;
                        }
                        break;

                      default:
                        chars += format.charAt(iFormat);
                    }
                }
            }
            return chars;
        },
        _get: function(inst, name) {
            return inst.settings[name] !== undefined ? inst.settings[name] : this._defaults[name];
        },
        _setDateFromField: function(inst, noDefault) {
            if (inst.input.val() === inst.lastVal) {
                return;
            }
            var dateFormat = this._get(inst, "dateFormat"), dates = inst.lastVal = inst.input ? inst.input.val() : null, defaultDate = this._getDefaultDate(inst), date = defaultDate, settings = this._getFormatConfig(inst);
            try {
                date = this.parseDate(dateFormat, dates, settings) || defaultDate;
            } catch (event) {
                dates = noDefault ? "" : dates;
            }
            inst.selectedDay = date.getDate();
            inst.drawMonth = inst.selectedMonth = date.getMonth();
            inst.drawYear = inst.selectedYear = date.getFullYear();
            inst.currentDay = dates ? date.getDate() : 0;
            inst.currentMonth = dates ? date.getMonth() : 0;
            inst.currentYear = dates ? date.getFullYear() : 0;
            this._adjustInstDate(inst);
        },
        _getDefaultDate: function(inst) {
            return this._restrictMinMax(inst, this._determineDate(inst, this._get(inst, "defaultDate"), new Date()));
        },
        _determineDate: function(inst, date, defaultDate) {
            var offsetNumeric = function(offset) {
                var date = new Date();
                date.setDate(date.getDate() + offset);
                return date;
            }, offsetString = function(offset) {
                try {
                    return $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"), offset, $.datepicker._getFormatConfig(inst));
                } catch (e) {}
                var date = (offset.toLowerCase().match(/^c/) ? $.datepicker._getDate(inst) : null) || new Date(), year = date.getFullYear(), month = date.getMonth(), day = date.getDate(), pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g, matches = pattern.exec(offset);
                while (matches) {
                    switch (matches[2] || "d") {
                      case "d":
                      case "D":
                        day += parseInt(matches[1], 10);
                        break;

                      case "w":
                      case "W":
                        day += parseInt(matches[1], 10) * 7;
                        break;

                      case "m":
                      case "M":
                        month += parseInt(matches[1], 10);
                        day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
                        break;

                      case "y":
                      case "Y":
                        year += parseInt(matches[1], 10);
                        day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
                        break;
                    }
                    matches = pattern.exec(offset);
                }
                return new Date(year, month, day);
            }, newDate = date == null || date === "" ? defaultDate : typeof date === "string" ? offsetString(date) : typeof date === "number" ? isNaN(date) ? defaultDate : offsetNumeric(date) : new Date(date.getTime());
            newDate = newDate && newDate.toString() === "Invalid Date" ? defaultDate : newDate;
            if (newDate) {
                newDate.setHours(0);
                newDate.setMinutes(0);
                newDate.setSeconds(0);
                newDate.setMilliseconds(0);
            }
            return this._daylightSavingAdjust(newDate);
        },
        _daylightSavingAdjust: function(date) {
            if (!date) {
                return null;
            }
            date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
            return date;
        },
        _setDate: function(inst, date, noChange) {
            var clear = !date, origMonth = inst.selectedMonth, origYear = inst.selectedYear, newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));
            inst.selectedDay = inst.currentDay = newDate.getDate();
            inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
            inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
            if ((origMonth !== inst.selectedMonth || origYear !== inst.selectedYear) && !noChange) {
                this._notifyChange(inst);
            }
            this._adjustInstDate(inst);
            if (inst.input) {
                inst.input.val(clear ? "" : this._formatDate(inst));
            }
        },
        _getDate: function(inst) {
            var startDate = !inst.currentYear || inst.input && inst.input.val() === "" ? null : this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay));
            return startDate;
        },
        _attachHandlers: function(inst) {
            var stepMonths = this._get(inst, "stepMonths"), id = "#" + inst.id.replace(/\\\\/g, "\\");
            inst.dpDiv.find("[data-handler]").map(function() {
                var handler = {
                    prev: function() {
                        $.datepicker._adjustDate(id, -stepMonths, "M");
                    },
                    next: function() {
                        $.datepicker._adjustDate(id, +stepMonths, "M");
                    },
                    hide: function() {
                        $.datepicker._hideDatepicker();
                    },
                    today: function() {
                        $.datepicker._gotoToday(id);
                    },
                    selectDay: function() {
                        $.datepicker._selectDay(id, +this.getAttribute("data-month"), +this.getAttribute("data-year"), this);
                        return false;
                    },
                    selectMonth: function() {
                        $.datepicker._selectMonthYear(id, this, "M");
                        return false;
                    },
                    selectYear: function() {
                        $.datepicker._selectMonthYear(id, this, "Y");
                        return false;
                    }
                };
                $(this).on(this.getAttribute("data-event"), handler[this.getAttribute("data-handler")]);
            });
        },
        _generateHTML: function(inst) {
            var maxDraw, prevText, prev, nextText, next, currentText, gotoDate, controls, buttonPanel, firstDay, showWeek, dayNames, dayNamesMin, monthNames, monthNamesShort, beforeShowDay, showOtherMonths, selectOtherMonths, defaultDate, html, dow, row, group, col, selectedDate, cornerClass, calender, thead, day, daysInMonth, leadDays, curRows, numRows, printDate, dRow, tbody, daySettings, otherMonth, unselectable, tempDate = new Date(), today = this._daylightSavingAdjust(new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate())), isRTL = this._get(inst, "isRTL"), showButtonPanel = this._get(inst, "showButtonPanel"), hideIfNoPrevNext = this._get(inst, "hideIfNoPrevNext"), navigationAsDateFormat = this._get(inst, "navigationAsDateFormat"), numMonths = this._getNumberOfMonths(inst), showCurrentAtPos = this._get(inst, "showCurrentAtPos"), stepMonths = this._get(inst, "stepMonths"), isMultiMonth = numMonths[0] !== 1 || numMonths[1] !== 1, currentDate = this._daylightSavingAdjust(!inst.currentDay ? new Date(9999, 9, 9) : new Date(inst.currentYear, inst.currentMonth, inst.currentDay)), minDate = this._getMinMaxDate(inst, "min"), maxDate = this._getMinMaxDate(inst, "max"), drawMonth = inst.drawMonth - showCurrentAtPos, drawYear = inst.drawYear;
            if (drawMonth < 0) {
                drawMonth += 12;
                drawYear--;
            }
            if (maxDate) {
                maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(), maxDate.getMonth() - numMonths[0] * numMonths[1] + 1, maxDate.getDate()));
                maxDraw = minDate && maxDraw < minDate ? minDate : maxDraw;
                while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {
                    drawMonth--;
                    if (drawMonth < 0) {
                        drawMonth = 11;
                        drawYear--;
                    }
                }
            }
            inst.drawMonth = drawMonth;
            inst.drawYear = drawYear;
            prevText = this._get(inst, "prevText");
            prevText = !navigationAsDateFormat ? prevText : this.formatDate(prevText, this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)), this._getFormatConfig(inst));
            prev = this._canAdjustMonth(inst, -1, drawYear, drawMonth) ? "<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click'" + " title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "e" : "w") + "'>" + prevText + "</span></a>" : hideIfNoPrevNext ? "" : "<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "e" : "w") + "'>" + prevText + "</span></a>";
            nextText = this._get(inst, "nextText");
            nextText = !navigationAsDateFormat ? nextText : this.formatDate(nextText, this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)), this._getFormatConfig(inst));
            next = this._canAdjustMonth(inst, +1, drawYear, drawMonth) ? "<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click'" + " title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "w" : "e") + "'>" + nextText + "</span></a>" : hideIfNoPrevNext ? "" : "<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "w" : "e") + "'>" + nextText + "</span></a>";
            currentText = this._get(inst, "currentText");
            gotoDate = this._get(inst, "gotoCurrent") && inst.currentDay ? currentDate : today;
            currentText = !navigationAsDateFormat ? currentText : this.formatDate(currentText, gotoDate, this._getFormatConfig(inst));
            controls = !inst.inline ? "<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>" + this._get(inst, "closeText") + "</button>" : "";
            buttonPanel = showButtonPanel ? "<div class='ui-datepicker-buttonpane ui-widget-content'>" + (isRTL ? controls : "") + (this._isInRange(inst, gotoDate) ? "<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'" + ">" + currentText + "</button>" : "") + (isRTL ? "" : controls) + "</div>" : "";
            firstDay = parseInt(this._get(inst, "firstDay"), 10);
            firstDay = isNaN(firstDay) ? 0 : firstDay;
            showWeek = this._get(inst, "showWeek");
            dayNames = this._get(inst, "dayNames");
            dayNamesMin = this._get(inst, "dayNamesMin");
            monthNames = this._get(inst, "monthNames");
            monthNamesShort = this._get(inst, "monthNamesShort");
            beforeShowDay = this._get(inst, "beforeShowDay");
            showOtherMonths = this._get(inst, "showOtherMonths");
            selectOtherMonths = this._get(inst, "selectOtherMonths");
            defaultDate = this._getDefaultDate(inst);
            html = "";
            for (row = 0; row < numMonths[0]; row++) {
                group = "";
                this.maxRows = 4;
                for (col = 0; col < numMonths[1]; col++) {
                    selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));
                    cornerClass = " ui-corner-all";
                    calender = "";
                    if (isMultiMonth) {
                        calender += "<div class='ui-datepicker-group";
                        if (numMonths[1] > 1) {
                            switch (col) {
                              case 0:
                                calender += " ui-datepicker-group-first";
                                cornerClass = " ui-corner-" + (isRTL ? "right" : "left");
                                break;

                              case numMonths[1] - 1:
                                calender += " ui-datepicker-group-last";
                                cornerClass = " ui-corner-" + (isRTL ? "left" : "right");
                                break;

                              default:
                                calender += " ui-datepicker-group-middle";
                                cornerClass = "";
                                break;
                            }
                        }
                        calender += "'>";
                    }
                    calender += "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" + cornerClass + "'>" + (/all|left/.test(cornerClass) && row === 0 ? isRTL ? next : prev : "") + (/all|right/.test(cornerClass) && row === 0 ? isRTL ? prev : next : "") + this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate, row > 0 || col > 0, monthNames, monthNamesShort) + "</div><table class='ui-datepicker-calendar'><thead>" + "<tr>";
                    thead = showWeek ? "<th class='ui-datepicker-week-col'>" + this._get(inst, "weekHeader") + "</th>" : "";
                    for (dow = 0; dow < 7; dow++) {
                        day = (dow + firstDay) % 7;
                        thead += "<th scope='col'" + ((dow + firstDay + 6) % 7 >= 5 ? " class='ui-datepicker-week-end'" : "") + ">" + "<span title='" + dayNames[day] + "'>" + dayNamesMin[day] + "</span></th>";
                    }
                    calender += thead + "</tr></thead><tbody>";
                    daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
                    if (drawYear === inst.selectedYear && drawMonth === inst.selectedMonth) {
                        inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);
                    }
                    leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
                    curRows = Math.ceil((leadDays + daysInMonth) / 7);
                    numRows = isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows;
                    this.maxRows = numRows;
                    printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));
                    for (dRow = 0; dRow < numRows; dRow++) {
                        calender += "<tr>";
                        tbody = !showWeek ? "" : "<td class='ui-datepicker-week-col'>" + this._get(inst, "calculateWeek")(printDate) + "</td>";
                        for (dow = 0; dow < 7; dow++) {
                            daySettings = beforeShowDay ? beforeShowDay.apply(inst.input ? inst.input[0] : null, [ printDate ]) : [ true, "" ];
                            otherMonth = printDate.getMonth() !== drawMonth;
                            unselectable = otherMonth && !selectOtherMonths || !daySettings[0] || minDate && printDate < minDate || maxDate && printDate > maxDate;
                            tbody += "<td class='" + ((dow + firstDay + 6) % 7 >= 5 ? " ui-datepicker-week-end" : "") + (otherMonth ? " ui-datepicker-other-month" : "") + (printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent || defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime() ? " " + this._dayOverClass : "") + (unselectable ? " " + this._unselectableClass + " ui-state-disabled" : "") + (otherMonth && !showOtherMonths ? "" : " " + daySettings[1] + (printDate.getTime() === currentDate.getTime() ? " " + this._currentClass : "") + (printDate.getTime() === today.getTime() ? " ui-datepicker-today" : "")) + "'" + ((!otherMonth || showOtherMonths) && daySettings[2] ? " title='" + daySettings[2].replace(/'/g, "&#39;") + "'" : "") + (unselectable ? "" : " data-handler='selectDay' data-event='click' data-month='" + printDate.getMonth() + "' data-year='" + printDate.getFullYear() + "'") + ">" + (otherMonth && !showOtherMonths ? "&#xa0;" : unselectable ? "<span class='ui-state-default'>" + printDate.getDate() + "</span>" : "<a class='ui-state-default" + (printDate.getTime() === today.getTime() ? " ui-state-highlight" : "") + (printDate.getTime() === currentDate.getTime() ? " ui-state-active" : "") + (otherMonth ? " ui-priority-secondary" : "") + "' href='#'>" + printDate.getDate() + "</a>") + "</td>";
                            printDate.setDate(printDate.getDate() + 1);
                            printDate = this._daylightSavingAdjust(printDate);
                        }
                        calender += tbody + "</tr>";
                    }
                    drawMonth++;
                    if (drawMonth > 11) {
                        drawMonth = 0;
                        drawYear++;
                    }
                    calender += "</tbody></table>" + (isMultiMonth ? "</div>" + (numMonths[0] > 0 && col === numMonths[1] - 1 ? "<div class='ui-datepicker-row-break'></div>" : "") : "");
                    group += calender;
                }
                html += group;
            }
            html += buttonPanel;
            inst._keyEvent = false;
            return html;
        },
        _generateMonthYearHeader: function(inst, drawMonth, drawYear, minDate, maxDate, secondary, monthNames, monthNamesShort) {
            var inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear, changeMonth = this._get(inst, "changeMonth"), changeYear = this._get(inst, "changeYear"), showMonthAfterYear = this._get(inst, "showMonthAfterYear"), html = "<div class='ui-datepicker-title'>", monthHtml = "";
            if (secondary || !changeMonth) {
                monthHtml += "<span class='ui-datepicker-month'>" + monthNames[drawMonth] + "</span>";
            } else {
                inMinYear = minDate && minDate.getFullYear() === drawYear;
                inMaxYear = maxDate && maxDate.getFullYear() === drawYear;
                monthHtml += "<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>";
                for (month = 0; month < 12; month++) {
                    if ((!inMinYear || month >= minDate.getMonth()) && (!inMaxYear || month <= maxDate.getMonth())) {
                        monthHtml += "<option value='" + month + "'" + (month === drawMonth ? " selected='selected'" : "") + ">" + monthNamesShort[month] + "</option>";
                    }
                }
                monthHtml += "</select>";
            }
            if (!showMonthAfterYear) {
                html += monthHtml + (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "");
            }
            if (!inst.yearshtml) {
                inst.yearshtml = "";
                if (secondary || !changeYear) {
                    html += "<span class='ui-datepicker-year'>" + drawYear + "</span>";
                } else {
                    years = this._get(inst, "yearRange").split(":");
                    thisYear = new Date().getFullYear();
                    determineYear = function(value) {
                        var year = value.match(/c[+\-].*/) ? drawYear + parseInt(value.substring(1), 10) : value.match(/[+\-].*/) ? thisYear + parseInt(value, 10) : parseInt(value, 10);
                        return isNaN(year) ? thisYear : year;
                    };
                    year = determineYear(years[0]);
                    endYear = Math.max(year, determineYear(years[1] || ""));
                    year = minDate ? Math.max(year, minDate.getFullYear()) : year;
                    endYear = maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear;
                    inst.yearshtml += "<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>";
                    for (;year <= endYear; year++) {
                        inst.yearshtml += "<option value='" + year + "'" + (year === drawYear ? " selected='selected'" : "") + ">" + year + "</option>";
                    }
                    inst.yearshtml += "</select>";
                    html += inst.yearshtml;
                    inst.yearshtml = null;
                }
            }
            html += this._get(inst, "yearSuffix");
            if (showMonthAfterYear) {
                html += (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "") + monthHtml;
            }
            html += "</div>";
            return html;
        },
        _adjustInstDate: function(inst, offset, period) {
            var year = inst.selectedYear + (period === "Y" ? offset : 0), month = inst.selectedMonth + (period === "M" ? offset : 0), day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) + (period === "D" ? offset : 0), date = this._restrictMinMax(inst, this._daylightSavingAdjust(new Date(year, month, day)));
            inst.selectedDay = date.getDate();
            inst.drawMonth = inst.selectedMonth = date.getMonth();
            inst.drawYear = inst.selectedYear = date.getFullYear();
            if (period === "M" || period === "Y") {
                this._notifyChange(inst);
            }
        },
        _restrictMinMax: function(inst, date) {
            var minDate = this._getMinMaxDate(inst, "min"), maxDate = this._getMinMaxDate(inst, "max"), newDate = minDate && date < minDate ? minDate : date;
            return maxDate && newDate > maxDate ? maxDate : newDate;
        },
        _notifyChange: function(inst) {
            var onChange = this._get(inst, "onChangeMonthYear");
            if (onChange) {
                onChange.apply(inst.input ? inst.input[0] : null, [ inst.selectedYear, inst.selectedMonth + 1, inst ]);
            }
        },
        _getNumberOfMonths: function(inst) {
            var numMonths = this._get(inst, "numberOfMonths");
            return numMonths == null ? [ 1, 1 ] : typeof numMonths === "number" ? [ 1, numMonths ] : numMonths;
        },
        _getMinMaxDate: function(inst, minMax) {
            return this._determineDate(inst, this._get(inst, minMax + "Date"), null);
        },
        _getDaysInMonth: function(year, month) {
            return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();
        },
        _getFirstDayOfMonth: function(year, month) {
            return new Date(year, month, 1).getDay();
        },
        _canAdjustMonth: function(inst, offset, curYear, curMonth) {
            var numMonths = this._getNumberOfMonths(inst), date = this._daylightSavingAdjust(new Date(curYear, curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));
            if (offset < 0) {
                date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
            }
            return this._isInRange(inst, date);
        },
        _isInRange: function(inst, date) {
            var yearSplit, currentYear, minDate = this._getMinMaxDate(inst, "min"), maxDate = this._getMinMaxDate(inst, "max"), minYear = null, maxYear = null, years = this._get(inst, "yearRange");
            if (years) {
                yearSplit = years.split(":");
                currentYear = new Date().getFullYear();
                minYear = parseInt(yearSplit[0], 10);
                maxYear = parseInt(yearSplit[1], 10);
                if (yearSplit[0].match(/[+\-].*/)) {
                    minYear += currentYear;
                }
                if (yearSplit[1].match(/[+\-].*/)) {
                    maxYear += currentYear;
                }
            }
            return (!minDate || date.getTime() >= minDate.getTime()) && (!maxDate || date.getTime() <= maxDate.getTime()) && (!minYear || date.getFullYear() >= minYear) && (!maxYear || date.getFullYear() <= maxYear);
        },
        _getFormatConfig: function(inst) {
            var shortYearCutoff = this._get(inst, "shortYearCutoff");
            shortYearCutoff = typeof shortYearCutoff !== "string" ? shortYearCutoff : new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10);
            return {
                shortYearCutoff: shortYearCutoff,
                dayNamesShort: this._get(inst, "dayNamesShort"),
                dayNames: this._get(inst, "dayNames"),
                monthNamesShort: this._get(inst, "monthNamesShort"),
                monthNames: this._get(inst, "monthNames")
            };
        },
        _formatDate: function(inst, day, month, year) {
            if (!day) {
                inst.currentDay = inst.selectedDay;
                inst.currentMonth = inst.selectedMonth;
                inst.currentYear = inst.selectedYear;
            }
            var date = day ? typeof day === "object" ? day : this._daylightSavingAdjust(new Date(year, month, day)) : this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay));
            return this.formatDate(this._get(inst, "dateFormat"), date, this._getFormatConfig(inst));
        }
    });
    function datepicker_bindHover(dpDiv) {
        var selector = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
        return dpDiv.on("mouseout", selector, function() {
            $(this).removeClass("ui-state-hover");
            if (this.className.indexOf("ui-datepicker-prev") !== -1) {
                $(this).removeClass("ui-datepicker-prev-hover");
            }
            if (this.className.indexOf("ui-datepicker-next") !== -1) {
                $(this).removeClass("ui-datepicker-next-hover");
            }
        }).on("mouseover", selector, datepicker_handleMouseover);
    }
    function datepicker_handleMouseover() {
        if (!$.datepicker._isDisabledDatepicker(datepicker_instActive.inline ? datepicker_instActive.dpDiv.parent()[0] : datepicker_instActive.input[0])) {
            $(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover");
            $(this).addClass("ui-state-hover");
            if (this.className.indexOf("ui-datepicker-prev") !== -1) {
                $(this).addClass("ui-datepicker-prev-hover");
            }
            if (this.className.indexOf("ui-datepicker-next") !== -1) {
                $(this).addClass("ui-datepicker-next-hover");
            }
        }
    }
    function datepicker_extendRemove(target, props) {
        $.extend(target, props);
        for (var name in props) {
            if (props[name] == null) {
                target[name] = props[name];
            }
        }
        return target;
    }
    $.fn.datepicker = function(options) {
        if (!this.length) {
            return this;
        }
        if (!$.datepicker.initialized) {
            $(document).on("mousedown", $.datepicker._checkExternalClick);
            $.datepicker.initialized = true;
        }
        if ($("#" + $.datepicker._mainDivId).length === 0) {
            $("body").append($.datepicker.dpDiv);
        }
        var otherArgs = Array.prototype.slice.call(arguments, 1);
        if (typeof options === "string" && (options === "isDisabled" || options === "getDate" || options === "widget")) {
            return $.datepicker["_" + options + "Datepicker"].apply($.datepicker, [ this[0] ].concat(otherArgs));
        }
        if (options === "option" && arguments.length === 2 && typeof arguments[1] === "string") {
            return $.datepicker["_" + options + "Datepicker"].apply($.datepicker, [ this[0] ].concat(otherArgs));
        }
        return this.each(function() {
            typeof options === "string" ? $.datepicker["_" + options + "Datepicker"].apply($.datepicker, [ this ].concat(otherArgs)) : $.datepicker._attachDatepicker(this, options);
        });
    };
    $.datepicker = new Datepicker();
    $.datepicker.initialized = false;
    $.datepicker.uuid = new Date().getTime();
    $.datepicker.version = "1.12.1";
    var widgetsDatepicker = $.datepicker;
    var ie = $.ui.ie = !!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase());
    var mouseHandled = false;
    $(document).on("mouseup", function() {
        mouseHandled = false;
    });
    var widgetsMouse = $.widget("ui.mouse", {
        version: "1.12.1",
        options: {
            cancel: "input, textarea, button, select, option",
            distance: 1,
            delay: 0
        },
        _mouseInit: function() {
            var that = this;
            this.element.on("mousedown." + this.widgetName, function(event) {
                return that._mouseDown(event);
            }).on("click." + this.widgetName, function(event) {
                if (true === $.data(event.target, that.widgetName + ".preventClickEvent")) {
                    $.removeData(event.target, that.widgetName + ".preventClickEvent");
                    event.stopImmediatePropagation();
                    return false;
                }
            });
            this.started = false;
        },
        _mouseDestroy: function() {
            this.element.off("." + this.widgetName);
            if (this._mouseMoveDelegate) {
                this.document.off("mousemove." + this.widgetName, this._mouseMoveDelegate).off("mouseup." + this.widgetName, this._mouseUpDelegate);
            }
        },
        _mouseDown: function(event) {
            if (mouseHandled) {
                return;
            }
            this._mouseMoved = false;
            this._mouseStarted && this._mouseUp(event);
            this._mouseDownEvent = event;
            var that = this, btnIsLeft = event.which === 1, elIsCancel = typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false;
            if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
                return true;
            }
            this.mouseDelayMet = !this.options.delay;
            if (!this.mouseDelayMet) {
                this._mouseDelayTimer = setTimeout(function() {
                    that.mouseDelayMet = true;
                }, this.options.delay);
            }
            if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
                this._mouseStarted = this._mouseStart(event) !== false;
                if (!this._mouseStarted) {
                    event.preventDefault();
                    return true;
                }
            }
            if (true === $.data(event.target, this.widgetName + ".preventClickEvent")) {
                $.removeData(event.target, this.widgetName + ".preventClickEvent");
            }
            this._mouseMoveDelegate = function(event) {
                return that._mouseMove(event);
            };
            this._mouseUpDelegate = function(event) {
                return that._mouseUp(event);
            };
            this.document.on("mousemove." + this.widgetName, this._mouseMoveDelegate).on("mouseup." + this.widgetName, this._mouseUpDelegate);
            event.preventDefault();
            mouseHandled = true;
            return true;
        },
        _mouseMove: function(event) {
            if (this._mouseMoved) {
                if ($.ui.ie && (!document.documentMode || document.documentMode < 9) && !event.button) {
                    return this._mouseUp(event);
                } else if (!event.which) {
                    if (event.originalEvent.altKey || event.originalEvent.ctrlKey || event.originalEvent.metaKey || event.originalEvent.shiftKey) {
                        this.ignoreMissingWhich = true;
                    } else if (!this.ignoreMissingWhich) {
                        return this._mouseUp(event);
                    }
                }
            }
            if (event.which || event.button) {
                this._mouseMoved = true;
            }
            if (this._mouseStarted) {
                this._mouseDrag(event);
                return event.preventDefault();
            }
            if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
                this._mouseStarted = this._mouseStart(this._mouseDownEvent, event) !== false;
                this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event);
            }
            return !this._mouseStarted;
        },
        _mouseUp: function(event) {
            this.document.off("mousemove." + this.widgetName, this._mouseMoveDelegate).off("mouseup." + this.widgetName, this._mouseUpDelegate);
            if (this._mouseStarted) {
                this._mouseStarted = false;
                if (event.target === this._mouseDownEvent.target) {
                    $.data(event.target, this.widgetName + ".preventClickEvent", true);
                }
                this._mouseStop(event);
            }
            if (this._mouseDelayTimer) {
                clearTimeout(this._mouseDelayTimer);
                delete this._mouseDelayTimer;
            }
            this.ignoreMissingWhich = false;
            mouseHandled = false;
            event.preventDefault();
        },
        _mouseDistanceMet: function(event) {
            return Math.max(Math.abs(this._mouseDownEvent.pageX - event.pageX), Math.abs(this._mouseDownEvent.pageY - event.pageY)) >= this.options.distance;
        },
        _mouseDelayMet: function() {
            return this.mouseDelayMet;
        },
        _mouseStart: function() {},
        _mouseDrag: function() {},
        _mouseStop: function() {},
        _mouseCapture: function() {
            return true;
        }
    });
    var plugin = $.ui.plugin = {
        add: function(module, option, set) {
            var i, proto = $.ui[module].prototype;
            for (i in set) {
                proto.plugins[i] = proto.plugins[i] || [];
                proto.plugins[i].push([ option, set[i] ]);
            }
        },
        call: function(instance, name, args, allowDisconnected) {
            var i, set = instance.plugins[name];
            if (!set) {
                return;
            }
            if (!allowDisconnected && (!instance.element[0].parentNode || instance.element[0].parentNode.nodeType === 11)) {
                return;
            }
            for (i = 0; i < set.length; i++) {
                if (instance.options[set[i][0]]) {
                    set[i][1].apply(instance.element, args);
                }
            }
        }
    };
    var safeBlur = $.ui.safeBlur = function(element) {
        if (element && element.nodeName.toLowerCase() !== "body") {
            $(element).trigger("blur");
        }
    };
    $.widget("ui.draggable", $.ui.mouse, {
        version: "1.12.1",
        widgetEventPrefix: "drag",
        options: {
            addClasses: true,
            appendTo: "parent",
            axis: false,
            connectToSortable: false,
            containment: false,
            cursor: "auto",
            cursorAt: false,
            grid: false,
            handle: false,
            helper: "original",
            iframeFix: false,
            opacity: false,
            refreshPositions: false,
            revert: false,
            revertDuration: 500,
            scope: "default",
            scroll: true,
            scrollSensitivity: 20,
            scrollSpeed: 20,
            snap: false,
            snapMode: "both",
            snapTolerance: 20,
            stack: false,
            zIndex: false,
            drag: null,
            start: null,
            stop: null
        },
        _create: function() {
            if (this.options.helper === "original") {
                this._setPositionRelative();
            }
            if (this.options.addClasses) {
                this._addClass("ui-draggable");
            }
            this._setHandleClassName();
            this._mouseInit();
        },
        _setOption: function(key, value) {
            this._super(key, value);
            if (key === "handle") {
                this._removeHandleClassName();
                this._setHandleClassName();
            }
        },
        _destroy: function() {
            if ((this.helper || this.element).is(".ui-draggable-dragging")) {
                this.destroyOnClear = true;
                return;
            }
            this._removeHandleClassName();
            this._mouseDestroy();
        },
        _mouseCapture: function(event) {
            var o = this.options;
            if (this.helper || o.disabled || $(event.target).closest(".ui-resizable-handle").length > 0) {
                return false;
            }
            this.handle = this._getHandle(event);
            if (!this.handle) {
                return false;
            }
            this._blurActiveElement(event);
            this._blockFrames(o.iframeFix === true ? "iframe" : o.iframeFix);
            return true;
        },
        _blockFrames: function(selector) {
            this.iframeBlocks = this.document.find(selector).map(function() {
                var iframe = $(this);
                return $("<div>").css("position", "absolute").appendTo(iframe.parent()).outerWidth(iframe.outerWidth()).outerHeight(iframe.outerHeight()).offset(iframe.offset())[0];
            });
        },
        _unblockFrames: function() {
            if (this.iframeBlocks) {
                this.iframeBlocks.remove();
                delete this.iframeBlocks;
            }
        },
        _blurActiveElement: function(event) {
            var activeElement = $.ui.safeActiveElement(this.document[0]), target = $(event.target);
            if (target.closest(activeElement).length) {
                return;
            }
            $.ui.safeBlur(activeElement);
        },
        _mouseStart: function(event) {
            var o = this.options;
            this.helper = this._createHelper(event);
            this._addClass(this.helper, "ui-draggable-dragging");
            this._cacheHelperProportions();
            if ($.ui.ddmanager) {
                $.ui.ddmanager.current = this;
            }
            this._cacheMargins();
            this.cssPosition = this.helper.css("position");
            this.scrollParent = this.helper.scrollParent(true);
            this.offsetParent = this.helper.offsetParent();
            this.hasFixedAncestor = this.helper.parents().filter(function() {
                return $(this).css("position") === "fixed";
            }).length > 0;
            this.positionAbs = this.element.offset();
            this._refreshOffsets(event);
            this.originalPosition = this.position = this._generatePosition(event, false);
            this.originalPageX = event.pageX;
            this.originalPageY = event.pageY;
            o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt);
            this._setContainment();
            if (this._trigger("start", event) === false) {
                this._clear();
                return false;
            }
            this._cacheHelperProportions();
            if ($.ui.ddmanager && !o.dropBehaviour) {
                $.ui.ddmanager.prepareOffsets(this, event);
            }
            this._mouseDrag(event, true);
            if ($.ui.ddmanager) {
                $.ui.ddmanager.dragStart(this, event);
            }
            return true;
        },
        _refreshOffsets: function(event) {
            this.offset = {
                top: this.positionAbs.top - this.margins.top,
                left: this.positionAbs.left - this.margins.left,
                scroll: false,
                parent: this._getParentOffset(),
                relative: this._getRelativeOffset()
            };
            this.offset.click = {
                left: event.pageX - this.offset.left,
                top: event.pageY - this.offset.top
            };
        },
        _mouseDrag: function(event, noPropagation) {
            if (this.hasFixedAncestor) {
                this.offset.parent = this._getParentOffset();
            }
            this.position = this._generatePosition(event, true);
            this.positionAbs = this._convertPositionTo("absolute");
            if (!noPropagation) {
                var ui = this._uiHash();
                if (this._trigger("drag", event, ui) === false) {
                    this._mouseUp(new $.Event("mouseup", event));
                    return false;
                }
                this.position = ui.position;
            }
            this.helper[0].style.left = this.position.left + "px";
            this.helper[0].style.top = this.position.top + "px";
            if ($.ui.ddmanager) {
                $.ui.ddmanager.drag(this, event);
            }
            return false;
        },
        _mouseStop: function(event) {
            var that = this, dropped = false;
            if ($.ui.ddmanager && !this.options.dropBehaviour) {
                dropped = $.ui.ddmanager.drop(this, event);
            }
            if (this.dropped) {
                dropped = this.dropped;
                this.dropped = false;
            }
            if (this.options.revert === "invalid" && !dropped || this.options.revert === "valid" && dropped || this.options.revert === true || $.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped)) {
                $(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
                    if (that._trigger("stop", event) !== false) {
                        that._clear();
                    }
                });
            } else {
                if (this._trigger("stop", event) !== false) {
                    this._clear();
                }
            }
            return false;
        },
        _mouseUp: function(event) {
            this._unblockFrames();
            if ($.ui.ddmanager) {
                $.ui.ddmanager.dragStop(this, event);
            }
            if (this.handleElement.is(event.target)) {
                this.element.trigger("focus");
            }
            return $.ui.mouse.prototype._mouseUp.call(this, event);
        },
        cancel: function() {
            if (this.helper.is(".ui-draggable-dragging")) {
                this._mouseUp(new $.Event("mouseup", {
                    target: this.element[0]
                }));
            } else {
                this._clear();
            }
            return this;
        },
        _getHandle: function(event) {
            return this.options.handle ? !!$(event.target).closest(this.element.find(this.options.handle)).length : true;
        },
        _setHandleClassName: function() {
            this.handleElement = this.options.handle ? this.element.find(this.options.handle) : this.element;
            this._addClass(this.handleElement, "ui-draggable-handle");
        },
        _removeHandleClassName: function() {
            this._removeClass(this.handleElement, "ui-draggable-handle");
        },
        _createHelper: function(event) {
            var o = this.options, helperIsFunction = $.isFunction(o.helper), helper = helperIsFunction ? $(o.helper.apply(this.element[0], [ event ])) : o.helper === "clone" ? this.element.clone().removeAttr("id") : this.element;
            if (!helper.parents("body").length) {
                helper.appendTo(o.appendTo === "parent" ? this.element[0].parentNode : o.appendTo);
            }
            if (helperIsFunction && helper[0] === this.element[0]) {
                this._setPositionRelative();
            }
            if (helper[0] !== this.element[0] && !/(fixed|absolute)/.test(helper.css("position"))) {
                helper.css("position", "absolute");
            }
            return helper;
        },
        _setPositionRelative: function() {
            if (!/^(?:r|a|f)/.test(this.element.css("position"))) {
                this.element[0].style.position = "relative";
            }
        },
        _adjustOffsetFromHelper: function(obj) {
            if (typeof obj === "string") {
                obj = obj.split(" ");
            }
            if ($.isArray(obj)) {
                obj = {
                    left: +obj[0],
                    top: +obj[1] || 0
                };
            }
            if ("left" in obj) {
                this.offset.click.left = obj.left + this.margins.left;
            }
            if ("right" in obj) {
                this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
            }
            if ("top" in obj) {
                this.offset.click.top = obj.top + this.margins.top;
            }
            if ("bottom" in obj) {
                this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
            }
        },
        _isRootNode: function(element) {
            return /(html|body)/i.test(element.tagName) || element === this.document[0];
        },
        _getParentOffset: function() {
            var po = this.offsetParent.offset(), document = this.document[0];
            if (this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
                po.left += this.scrollParent.scrollLeft();
                po.top += this.scrollParent.scrollTop();
            }
            if (this._isRootNode(this.offsetParent[0])) {
                po = {
                    top: 0,
                    left: 0
                };
            }
            return {
                top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
                left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
            };
        },
        _getRelativeOffset: function() {
            if (this.cssPosition !== "relative") {
                return {
                    top: 0,
                    left: 0
                };
            }
            var p = this.element.position(), scrollIsRootNode = this._isRootNode(this.scrollParent[0]);
            return {
                top: p.top - (parseInt(this.helper.css("top"), 10) || 0) + (!scrollIsRootNode ? this.scrollParent.scrollTop() : 0),
                left: p.left - (parseInt(this.helper.css("left"), 10) || 0) + (!scrollIsRootNode ? this.scrollParent.scrollLeft() : 0)
            };
        },
        _cacheMargins: function() {
            this.margins = {
                left: parseInt(this.element.css("marginLeft"), 10) || 0,
                top: parseInt(this.element.css("marginTop"), 10) || 0,
                right: parseInt(this.element.css("marginRight"), 10) || 0,
                bottom: parseInt(this.element.css("marginBottom"), 10) || 0
            };
        },
        _cacheHelperProportions: function() {
            this.helperProportions = {
                width: this.helper.outerWidth(),
                height: this.helper.outerHeight()
            };
        },
        _setContainment: function() {
            var isUserScrollable, c, ce, o = this.options, document = this.document[0];
            this.relativeContainer = null;
            if (!o.containment) {
                this.containment = null;
                return;
            }
            if (o.containment === "window") {
                this.containment = [ $(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left, $(window).scrollTop() - this.offset.relative.top - this.offset.parent.top, $(window).scrollLeft() + $(window).width() - this.helperProportions.width - this.margins.left, $(window).scrollTop() + ($(window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top ];
                return;
            }
            if (o.containment === "document") {
                this.containment = [ 0, 0, $(document).width() - this.helperProportions.width - this.margins.left, ($(document).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top ];
                return;
            }
            if (o.containment.constructor === Array) {
                this.containment = o.containment;
                return;
            }
            if (o.containment === "parent") {
                o.containment = this.helper[0].parentNode;
            }
            c = $(o.containment);
            ce = c[0];
            if (!ce) {
                return;
            }
            isUserScrollable = /(scroll|auto)/.test(c.css("overflow"));
            this.containment = [ (parseInt(c.css("borderLeftWidth"), 10) || 0) + (parseInt(c.css("paddingLeft"), 10) || 0), (parseInt(c.css("borderTopWidth"), 10) || 0) + (parseInt(c.css("paddingTop"), 10) || 0), (isUserScrollable ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) - (parseInt(c.css("borderRightWidth"), 10) || 0) - (parseInt(c.css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left - this.margins.right, (isUserScrollable ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) - (parseInt(c.css("borderBottomWidth"), 10) || 0) - (parseInt(c.css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top - this.margins.bottom ];
            this.relativeContainer = c;
        },
        _convertPositionTo: function(d, pos) {
            if (!pos) {
                pos = this.position;
            }
            var mod = d === "absolute" ? 1 : -1, scrollIsRootNode = this._isRootNode(this.scrollParent[0]);
            return {
                top: pos.top + this.offset.relative.top * mod + this.offset.parent.top * mod - (this.cssPosition === "fixed" ? -this.offset.scroll.top : scrollIsRootNode ? 0 : this.offset.scroll.top) * mod,
                left: pos.left + this.offset.relative.left * mod + this.offset.parent.left * mod - (this.cssPosition === "fixed" ? -this.offset.scroll.left : scrollIsRootNode ? 0 : this.offset.scroll.left) * mod
            };
        },
        _generatePosition: function(event, constrainPosition) {
            var containment, co, top, left, o = this.options, scrollIsRootNode = this._isRootNode(this.scrollParent[0]), pageX = event.pageX, pageY = event.pageY;
            if (!scrollIsRootNode || !this.offset.scroll) {
                this.offset.scroll = {
                    top: this.scrollParent.scrollTop(),
                    left: this.scrollParent.scrollLeft()
                };
            }
            if (constrainPosition) {
                if (this.containment) {
                    if (this.relativeContainer) {
                        co = this.relativeContainer.offset();
                        containment = [ this.containment[0] + co.left, this.containment[1] + co.top, this.containment[2] + co.left, this.containment[3] + co.top ];
                    } else {
                        containment = this.containment;
                    }
                    if (event.pageX - this.offset.click.left < containment[0]) {
                        pageX = containment[0] + this.offset.click.left;
                    }
                    if (event.pageY - this.offset.click.top < containment[1]) {
                        pageY = containment[1] + this.offset.click.top;
                    }
                    if (event.pageX - this.offset.click.left > containment[2]) {
                        pageX = containment[2] + this.offset.click.left;
                    }
                    if (event.pageY - this.offset.click.top > containment[3]) {
                        pageY = containment[3] + this.offset.click.top;
                    }
                }
                if (o.grid) {
                    top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
                    pageY = containment ? top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3] ? top : top - this.offset.click.top >= containment[1] ? top - o.grid[1] : top + o.grid[1] : top;
                    left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;
                    pageX = containment ? left - this.offset.click.left >= containment[0] || left - this.offset.click.left > containment[2] ? left : left - this.offset.click.left >= containment[0] ? left - o.grid[0] : left + o.grid[0] : left;
                }
                if (o.axis === "y") {
                    pageX = this.originalPageX;
                }
                if (o.axis === "x") {
                    pageY = this.originalPageY;
                }
            }
            return {
                top: pageY - this.offset.click.top - this.offset.relative.top - this.offset.parent.top + (this.cssPosition === "fixed" ? -this.offset.scroll.top : scrollIsRootNode ? 0 : this.offset.scroll.top),
                left: pageX - this.offset.click.left - this.offset.relative.left - this.offset.parent.left + (this.cssPosition === "fixed" ? -this.offset.scroll.left : scrollIsRootNode ? 0 : this.offset.scroll.left)
            };
        },
        _clear: function() {
            this._removeClass(this.helper, "ui-draggable-dragging");
            if (this.helper[0] !== this.element[0] && !this.cancelHelperRemoval) {
                this.helper.remove();
            }
            this.helper = null;
            this.cancelHelperRemoval = false;
            if (this.destroyOnClear) {
                this.destroy();
            }
        },
        _trigger: function(type, event, ui) {
            ui = ui || this._uiHash();
            $.ui.plugin.call(this, type, [ event, ui, this ], true);
            if (/^(drag|start|stop)/.test(type)) {
                this.positionAbs = this._convertPositionTo("absolute");
                ui.offset = this.positionAbs;
            }
            return $.Widget.prototype._trigger.call(this, type, event, ui);
        },
        plugins: {},
        _uiHash: function() {
            return {
                helper: this.helper,
                position: this.position,
                originalPosition: this.originalPosition,
                offset: this.positionAbs
            };
        }
    });
    $.ui.plugin.add("draggable", "connectToSortable", {
        start: function(event, ui, draggable) {
            var uiSortable = $.extend({}, ui, {
                item: draggable.element
            });
            draggable.sortables = [];
            $(draggable.options.connectToSortable).each(function() {
                var sortable = $(this).sortable("instance");
                if (sortable && !sortable.options.disabled) {
                    draggable.sortables.push(sortable);
                    sortable.refreshPositions();
                    sortable._trigger("activate", event, uiSortable);
                }
            });
        },
        stop: function(event, ui, draggable) {
            var uiSortable = $.extend({}, ui, {
                item: draggable.element
            });
            draggable.cancelHelperRemoval = false;
            $.each(draggable.sortables, function() {
                var sortable = this;
                if (sortable.isOver) {
                    sortable.isOver = 0;
                    draggable.cancelHelperRemoval = true;
                    sortable.cancelHelperRemoval = false;
                    sortable._storedCSS = {
                        position: sortable.placeholder.css("position"),
                        top: sortable.placeholder.css("top"),
                        left: sortable.placeholder.css("left")
                    };
                    sortable._mouseStop(event);
                    sortable.options.helper = sortable.options._helper;
                } else {
                    sortable.cancelHelperRemoval = true;
                    sortable._trigger("deactivate", event, uiSortable);
                }
            });
        },
        drag: function(event, ui, draggable) {
            $.each(draggable.sortables, function() {
                var innermostIntersecting = false, sortable = this;
                sortable.positionAbs = draggable.positionAbs;
                sortable.helperProportions = draggable.helperProportions;
                sortable.offset.click = draggable.offset.click;
                if (sortable._intersectsWith(sortable.containerCache)) {
                    innermostIntersecting = true;
                    $.each(draggable.sortables, function() {
                        this.positionAbs = draggable.positionAbs;
                        this.helperProportions = draggable.helperProportions;
                        this.offset.click = draggable.offset.click;
                        if (this !== sortable && this._intersectsWith(this.containerCache) && $.contains(sortable.element[0], this.element[0])) {
                            innermostIntersecting = false;
                        }
                        return innermostIntersecting;
                    });
                }
                if (innermostIntersecting) {
                    if (!sortable.isOver) {
                        sortable.isOver = 1;
                        draggable._parent = ui.helper.parent();
                        sortable.currentItem = ui.helper.appendTo(sortable.element).data("ui-sortable-item", true);
                        sortable.options._helper = sortable.options.helper;
                        sortable.options.helper = function() {
                            return ui.helper[0];
                        };
                        event.target = sortable.currentItem[0];
                        sortable._mouseCapture(event, true);
                        sortable._mouseStart(event, true, true);
                        sortable.offset.click.top = draggable.offset.click.top;
                        sortable.offset.click.left = draggable.offset.click.left;
                        sortable.offset.parent.left -= draggable.offset.parent.left - sortable.offset.parent.left;
                        sortable.offset.parent.top -= draggable.offset.parent.top - sortable.offset.parent.top;
                        draggable._trigger("toSortable", event);
                        draggable.dropped = sortable.element;
                        $.each(draggable.sortables, function() {
                            this.refreshPositions();
                        });
                        draggable.currentItem = draggable.element;
                        sortable.fromOutside = draggable;
                    }
                    if (sortable.currentItem) {
                        sortable._mouseDrag(event);
                        ui.position = sortable.position;
                    }
                } else {
                    if (sortable.isOver) {
                        sortable.isOver = 0;
                        sortable.cancelHelperRemoval = true;
                        sortable.options._revert = sortable.options.revert;
                        sortable.options.revert = false;
                        sortable._trigger("out", event, sortable._uiHash(sortable));
                        sortable._mouseStop(event, true);
                        sortable.options.revert = sortable.options._revert;
                        sortable.options.helper = sortable.options._helper;
                        if (sortable.placeholder) {
                            sortable.placeholder.remove();
                        }
                        ui.helper.appendTo(draggable._parent);
                        draggable._refreshOffsets(event);
                        ui.position = draggable._generatePosition(event, true);
                        draggable._trigger("fromSortable", event);
                        draggable.dropped = false;
                        $.each(draggable.sortables, function() {
                            this.refreshPositions();
                        });
                    }
                }
            });
        }
    });
    $.ui.plugin.add("draggable", "cursor", {
        start: function(event, ui, instance) {
            var t = $("body"), o = instance.options;
            if (t.css("cursor")) {
                o._cursor = t.css("cursor");
            }
            t.css("cursor", o.cursor);
        },
        stop: function(event, ui, instance) {
            var o = instance.options;
            if (o._cursor) {
                $("body").css("cursor", o._cursor);
            }
        }
    });
    $.ui.plugin.add("draggable", "opacity", {
        start: function(event, ui, instance) {
            var t = $(ui.helper), o = instance.options;
            if (t.css("opacity")) {
                o._opacity = t.css("opacity");
            }
            t.css("opacity", o.opacity);
        },
        stop: function(event, ui, instance) {
            var o = instance.options;
            if (o._opacity) {
                $(ui.helper).css("opacity", o._opacity);
            }
        }
    });
    $.ui.plugin.add("draggable", "scroll", {
        start: function(event, ui, i) {
            if (!i.scrollParentNotHidden) {
                i.scrollParentNotHidden = i.helper.scrollParent(false);
            }
            if (i.scrollParentNotHidden[0] !== i.document[0] && i.scrollParentNotHidden[0].tagName !== "HTML") {
                i.overflowOffset = i.scrollParentNotHidden.offset();
            }
        },
        drag: function(event, ui, i) {
            var o = i.options, scrolled = false, scrollParent = i.scrollParentNotHidden[0], document = i.document[0];
            if (scrollParent !== document && scrollParent.tagName !== "HTML") {
                if (!o.axis || o.axis !== "x") {
                    if (i.overflowOffset.top + scrollParent.offsetHeight - event.pageY < o.scrollSensitivity) {
                        scrollParent.scrollTop = scrolled = scrollParent.scrollTop + o.scrollSpeed;
                    } else if (event.pageY - i.overflowOffset.top < o.scrollSensitivity) {
                        scrollParent.scrollTop = scrolled = scrollParent.scrollTop - o.scrollSpeed;
                    }
                }
                if (!o.axis || o.axis !== "y") {
                    if (i.overflowOffset.left + scrollParent.offsetWidth - event.pageX < o.scrollSensitivity) {
                        scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft + o.scrollSpeed;
                    } else if (event.pageX - i.overflowOffset.left < o.scrollSensitivity) {
                        scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft - o.scrollSpeed;
                    }
                }
            } else {
                if (!o.axis || o.axis !== "x") {
                    if (event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
                        scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
                    } else if ($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
                        scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
                    }
                }
                if (!o.axis || o.axis !== "y") {
                    if (event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
                        scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
                    } else if ($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
                        scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
                    }
                }
            }
            if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
                $.ui.ddmanager.prepareOffsets(i, event);
            }
        }
    });
    $.ui.plugin.add("draggable", "snap", {
        start: function(event, ui, i) {
            var o = i.options;
            i.snapElements = [];
            $(o.snap.constructor !== String ? o.snap.items || ":data(ui-draggable)" : o.snap).each(function() {
                var $t = $(this), $o = $t.offset();
                if (this !== i.element[0]) {
                    i.snapElements.push({
                        item: this,
                        width: $t.outerWidth(),
                        height: $t.outerHeight(),
                        top: $o.top,
                        left: $o.left
                    });
                }
            });
        },
        drag: function(event, ui, inst) {
            var ts, bs, ls, rs, l, r, t, b, i, first, o = inst.options, d = o.snapTolerance, x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width, y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;
            for (i = inst.snapElements.length - 1; i >= 0; i--) {
                l = inst.snapElements[i].left - inst.margins.left;
                r = l + inst.snapElements[i].width;
                t = inst.snapElements[i].top - inst.margins.top;
                b = t + inst.snapElements[i].height;
                if (x2 < l - d || x1 > r + d || y2 < t - d || y1 > b + d || !$.contains(inst.snapElements[i].item.ownerDocument, inst.snapElements[i].item)) {
                    if (inst.snapElements[i].snapping) {
                        inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), {
                            snapItem: inst.snapElements[i].item
                        }));
                    }
                    inst.snapElements[i].snapping = false;
                    continue;
                }
                if (o.snapMode !== "inner") {
                    ts = Math.abs(t - y2) <= d;
                    bs = Math.abs(b - y1) <= d;
                    ls = Math.abs(l - x2) <= d;
                    rs = Math.abs(r - x1) <= d;
                    if (ts) {
                        ui.position.top = inst._convertPositionTo("relative", {
                            top: t - inst.helperProportions.height,
                            left: 0
                        }).top;
                    }
                    if (bs) {
                        ui.position.top = inst._convertPositionTo("relative", {
                            top: b,
                            left: 0
                        }).top;
                    }
                    if (ls) {
                        ui.position.left = inst._convertPositionTo("relative", {
                            top: 0,
                            left: l - inst.helperProportions.width
                        }).left;
                    }
                    if (rs) {
                        ui.position.left = inst._convertPositionTo("relative", {
                            top: 0,
                            left: r
                        }).left;
                    }
                }
                first = ts || bs || ls || rs;
                if (o.snapMode !== "outer") {
                    ts = Math.abs(t - y1) <= d;
                    bs = Math.abs(b - y2) <= d;
                    ls = Math.abs(l - x1) <= d;
                    rs = Math.abs(r - x2) <= d;
                    if (ts) {
                        ui.position.top = inst._convertPositionTo("relative", {
                            top: t,
                            left: 0
                        }).top;
                    }
                    if (bs) {
                        ui.position.top = inst._convertPositionTo("relative", {
                            top: b - inst.helperProportions.height,
                            left: 0
                        }).top;
                    }
                    if (ls) {
                        ui.position.left = inst._convertPositionTo("relative", {
                            top: 0,
                            left: l
                        }).left;
                    }
                    if (rs) {
                        ui.position.left = inst._convertPositionTo("relative", {
                            top: 0,
                            left: r - inst.helperProportions.width
                        }).left;
                    }
                }
                if (!inst.snapElements[i].snapping && (ts || bs || ls || rs || first)) {
                    inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), {
                        snapItem: inst.snapElements[i].item
                    }));
                }
                inst.snapElements[i].snapping = ts || bs || ls || rs || first;
            }
        }
    });
    $.ui.plugin.add("draggable", "stack", {
        start: function(event, ui, instance) {
            var min, o = instance.options, group = $.makeArray($(o.stack)).sort(function(a, b) {
                return (parseInt($(a).css("zIndex"), 10) || 0) - (parseInt($(b).css("zIndex"), 10) || 0);
            });
            if (!group.length) {
                return;
            }
            min = parseInt($(group[0]).css("zIndex"), 10) || 0;
            $(group).each(function(i) {
                $(this).css("zIndex", min + i);
            });
            this.css("zIndex", min + group.length);
        }
    });
    $.ui.plugin.add("draggable", "zIndex", {
        start: function(event, ui, instance) {
            var t = $(ui.helper), o = instance.options;
            if (t.css("zIndex")) {
                o._zIndex = t.css("zIndex");
            }
            t.css("zIndex", o.zIndex);
        },
        stop: function(event, ui, instance) {
            var o = instance.options;
            if (o._zIndex) {
                $(ui.helper).css("zIndex", o._zIndex);
            }
        }
    });
    var widgetsDraggable = $.ui.draggable;
    $.widget("ui.resizable", $.ui.mouse, {
        version: "1.12.1",
        widgetEventPrefix: "resize",
        options: {
            alsoResize: false,
            animate: false,
            animateDuration: "slow",
            animateEasing: "swing",
            aspectRatio: false,
            autoHide: false,
            classes: {
                "ui-resizable-se": "ui-icon ui-icon-gripsmall-diagonal-se"
            },
            containment: false,
            ghost: false,
            grid: false,
            handles: "e,s,se",
            helper: false,
            maxHeight: null,
            maxWidth: null,
            minHeight: 10,
            minWidth: 10,
            zIndex: 90,
            resize: null,
            start: null,
            stop: null
        },
        _num: function(value) {
            return parseFloat(value) || 0;
        },
        _isNumber: function(value) {
            return !isNaN(parseFloat(value));
        },
        _hasScroll: function(el, a) {
            if ($(el).css("overflow") === "hidden") {
                return false;
            }
            var scroll = a && a === "left" ? "scrollLeft" : "scrollTop", has = false;
            if (el[scroll] > 0) {
                return true;
            }
            el[scroll] = 1;
            has = el[scroll] > 0;
            el[scroll] = 0;
            return has;
        },
        _create: function() {
            var margins, o = this.options, that = this;
            this._addClass("ui-resizable");
            $.extend(this, {
                _aspectRatio: !!o.aspectRatio,
                aspectRatio: o.aspectRatio,
                originalElement: this.element,
                _proportionallyResizeElements: [],
                _helper: o.helper || o.ghost || o.animate ? o.helper || "ui-resizable-helper" : null
            });
            if (this.element[0].nodeName.match(/^(canvas|textarea|input|select|button|img)$/i)) {
                this.element.wrap($("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({
                    position: this.element.css("position"),
                    width: this.element.outerWidth(),
                    height: this.element.outerHeight(),
                    top: this.element.css("top"),
                    left: this.element.css("left")
                }));
                this.element = this.element.parent().data("ui-resizable", this.element.resizable("instance"));
                this.elementIsWrapper = true;
                margins = {
                    marginTop: this.originalElement.css("marginTop"),
                    marginRight: this.originalElement.css("marginRight"),
                    marginBottom: this.originalElement.css("marginBottom"),
                    marginLeft: this.originalElement.css("marginLeft")
                };
                this.element.css(margins);
                this.originalElement.css("margin", 0);
                this.originalResizeStyle = this.originalElement.css("resize");
                this.originalElement.css("resize", "none");
                this._proportionallyResizeElements.push(this.originalElement.css({
                    position: "static",
                    zoom: 1,
                    display: "block"
                }));
                this.originalElement.css(margins);
                this._proportionallyResize();
            }
            this._setupHandles();
            if (o.autoHide) {
                $(this.element).on("mouseenter", function() {
                    if (o.disabled) {
                        return;
                    }
                    that._removeClass("ui-resizable-autohide");
                    that._handles.show();
                }).on("mouseleave", function() {
                    if (o.disabled) {
                        return;
                    }
                    if (!that.resizing) {
                        that._addClass("ui-resizable-autohide");
                        that._handles.hide();
                    }
                });
            }
            this._mouseInit();
        },
        _destroy: function() {
            this._mouseDestroy();
            var wrapper, _destroy = function(exp) {
                $(exp).removeData("resizable").removeData("ui-resizable").off(".resizable").find(".ui-resizable-handle").remove();
            };
            if (this.elementIsWrapper) {
                _destroy(this.element);
                wrapper = this.element;
                this.originalElement.css({
                    position: wrapper.css("position"),
                    width: wrapper.outerWidth(),
                    height: wrapper.outerHeight(),
                    top: wrapper.css("top"),
                    left: wrapper.css("left")
                }).insertAfter(wrapper);
                wrapper.remove();
            }
            this.originalElement.css("resize", this.originalResizeStyle);
            _destroy(this.originalElement);
            return this;
        },
        _setOption: function(key, value) {
            this._super(key, value);
            switch (key) {
              case "handles":
                this._removeHandles();
                this._setupHandles();
                break;

              default:
                break;
            }
        },
        _setupHandles: function() {
            var o = this.options, handle, i, n, hname, axis, that = this;
            this.handles = o.handles || (!$(".ui-resizable-handle", this.element).length ? "e,s,se" : {
                n: ".ui-resizable-n",
                e: ".ui-resizable-e",
                s: ".ui-resizable-s",
                w: ".ui-resizable-w",
                se: ".ui-resizable-se",
                sw: ".ui-resizable-sw",
                ne: ".ui-resizable-ne",
                nw: ".ui-resizable-nw"
            });
            this._handles = $();
            if (this.handles.constructor === String) {
                if (this.handles === "all") {
                    this.handles = "n,e,s,w,se,sw,ne,nw";
                }
                n = this.handles.split(",");
                this.handles = {};
                for (i = 0; i < n.length; i++) {
                    handle = $.trim(n[i]);
                    hname = "ui-resizable-" + handle;
                    axis = $("<div>");
                    this._addClass(axis, "ui-resizable-handle " + hname);
                    axis.css({
                        zIndex: o.zIndex
                    });
                    this.handles[handle] = ".ui-resizable-" + handle;
                    this.element.append(axis);
                }
            }
            this._renderAxis = function(target) {
                var i, axis, padPos, padWrapper;
                target = target || this.element;
                for (i in this.handles) {
                    if (this.handles[i].constructor === String) {
                        this.handles[i] = this.element.children(this.handles[i]).first().show();
                    } else if (this.handles[i].jquery || this.handles[i].nodeType) {
                        this.handles[i] = $(this.handles[i]);
                        this._on(this.handles[i], {
                            mousedown: that._mouseDown
                        });
                    }
                    if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/^(textarea|input|select|button)$/i)) {
                        axis = $(this.handles[i], this.element);
                        padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();
                        padPos = [ "padding", /ne|nw|n/.test(i) ? "Top" : /se|sw|s/.test(i) ? "Bottom" : /^e$/.test(i) ? "Right" : "Left" ].join("");
                        target.css(padPos, padWrapper);
                        this._proportionallyResize();
                    }
                    this._handles = this._handles.add(this.handles[i]);
                }
            };
            this._renderAxis(this.element);
            this._handles = this._handles.add(this.element.find(".ui-resizable-handle"));
            this._handles.disableSelection();
            this._handles.on("mouseover", function() {
                if (!that.resizing) {
                    if (this.className) {
                        axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);
                    }
                    that.axis = axis && axis[1] ? axis[1] : "se";
                }
            });
            if (o.autoHide) {
                this._handles.hide();
                this._addClass("ui-resizable-autohide");
            }
        },
        _removeHandles: function() {
            this._handles.remove();
        },
        _mouseCapture: function(event) {
            var i, handle, capture = false;
            for (i in this.handles) {
                handle = $(this.handles[i])[0];
                if (handle === event.target || $.contains(handle, event.target)) {
                    capture = true;
                }
            }
            return !this.options.disabled && capture;
        },
        _mouseStart: function(event) {
            var curleft, curtop, cursor, o = this.options, el = this.element;
            this.resizing = true;
            this._renderProxy();
            curleft = this._num(this.helper.css("left"));
            curtop = this._num(this.helper.css("top"));
            if (o.containment) {
                curleft += $(o.containment).scrollLeft() || 0;
                curtop += $(o.containment).scrollTop() || 0;
            }
            this.offset = this.helper.offset();
            this.position = {
                left: curleft,
                top: curtop
            };
            this.size = this._helper ? {
                width: this.helper.width(),
                height: this.helper.height()
            } : {
                width: el.width(),
                height: el.height()
            };
            this.originalSize = this._helper ? {
                width: el.outerWidth(),
                height: el.outerHeight()
            } : {
                width: el.width(),
                height: el.height()
            };
            this.sizeDiff = {
                width: el.outerWidth() - el.width(),
                height: el.outerHeight() - el.height()
            };
            this.originalPosition = {
                left: curleft,
                top: curtop
            };
            this.originalMousePosition = {
                left: event.pageX,
                top: event.pageY
            };
            this.aspectRatio = typeof o.aspectRatio === "number" ? o.aspectRatio : this.originalSize.width / this.originalSize.height || 1;
            cursor = $(".ui-resizable-" + this.axis).css("cursor");
            $("body").css("cursor", cursor === "auto" ? this.axis + "-resize" : cursor);
            this._addClass("ui-resizable-resizing");
            this._propagate("start", event);
            return true;
        },
        _mouseDrag: function(event) {
            var data, props, smp = this.originalMousePosition, a = this.axis, dx = event.pageX - smp.left || 0, dy = event.pageY - smp.top || 0, trigger = this._change[a];
            this._updatePrevProperties();
            if (!trigger) {
                return false;
            }
            data = trigger.apply(this, [ event, dx, dy ]);
            this._updateVirtualBoundaries(event.shiftKey);
            if (this._aspectRatio || event.shiftKey) {
                data = this._updateRatio(data, event);
            }
            data = this._respectSize(data, event);
            this._updateCache(data);
            this._propagate("resize", event);
            props = this._applyChanges();
            if (!this._helper && this._proportionallyResizeElements.length) {
                this._proportionallyResize();
            }
            if (!$.isEmptyObject(props)) {
                this._updatePrevProperties();
                this._trigger("resize", event, this.ui());
                this._applyChanges();
            }
            return false;
        },
        _mouseStop: function(event) {
            this.resizing = false;
            var pr, ista, soffseth, soffsetw, s, left, top, o = this.options, that = this;
            if (this._helper) {
                pr = this._proportionallyResizeElements;
                ista = pr.length && /textarea/i.test(pr[0].nodeName);
                soffseth = ista && this._hasScroll(pr[0], "left") ? 0 : that.sizeDiff.height;
                soffsetw = ista ? 0 : that.sizeDiff.width;
                s = {
                    width: that.helper.width() - soffsetw,
                    height: that.helper.height() - soffseth
                };
                left = parseFloat(that.element.css("left")) + (that.position.left - that.originalPosition.left) || null;
                top = parseFloat(that.element.css("top")) + (that.position.top - that.originalPosition.top) || null;
                if (!o.animate) {
                    this.element.css($.extend(s, {
                        top: top,
                        left: left
                    }));
                }
                that.helper.height(that.size.height);
                that.helper.width(that.size.width);
                if (this._helper && !o.animate) {
                    this._proportionallyResize();
                }
            }
            $("body").css("cursor", "auto");
            this._removeClass("ui-resizable-resizing");
            this._propagate("stop", event);
            if (this._helper) {
                this.helper.remove();
            }
            return false;
        },
        _updatePrevProperties: function() {
            this.prevPosition = {
                top: this.position.top,
                left: this.position.left
            };
            this.prevSize = {
                width: this.size.width,
                height: this.size.height
            };
        },
        _applyChanges: function() {
            var props = {};
            if (this.position.top !== this.prevPosition.top) {
                props.top = this.position.top + "px";
            }
            if (this.position.left !== this.prevPosition.left) {
                props.left = this.position.left + "px";
            }
            if (this.size.width !== this.prevSize.width) {
                props.width = this.size.width + "px";
            }
            if (this.size.height !== this.prevSize.height) {
                props.height = this.size.height + "px";
            }
            this.helper.css(props);
            return props;
        },
        _updateVirtualBoundaries: function(forceAspectRatio) {
            var pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b, o = this.options;
            b = {
                minWidth: this._isNumber(o.minWidth) ? o.minWidth : 0,
                maxWidth: this._isNumber(o.maxWidth) ? o.maxWidth : Infinity,
                minHeight: this._isNumber(o.minHeight) ? o.minHeight : 0,
                maxHeight: this._isNumber(o.maxHeight) ? o.maxHeight : Infinity
            };
            if (this._aspectRatio || forceAspectRatio) {
                pMinWidth = b.minHeight * this.aspectRatio;
                pMinHeight = b.minWidth / this.aspectRatio;
                pMaxWidth = b.maxHeight * this.aspectRatio;
                pMaxHeight = b.maxWidth / this.aspectRatio;
                if (pMinWidth > b.minWidth) {
                    b.minWidth = pMinWidth;
                }
                if (pMinHeight > b.minHeight) {
                    b.minHeight = pMinHeight;
                }
                if (pMaxWidth < b.maxWidth) {
                    b.maxWidth = pMaxWidth;
                }
                if (pMaxHeight < b.maxHeight) {
                    b.maxHeight = pMaxHeight;
                }
            }
            this._vBoundaries = b;
        },
        _updateCache: function(data) {
            this.offset = this.helper.offset();
            if (this._isNumber(data.left)) {
                this.position.left = data.left;
            }
            if (this._isNumber(data.top)) {
                this.position.top = data.top;
            }
            if (this._isNumber(data.height)) {
                this.size.height = data.height;
            }
            if (this._isNumber(data.width)) {
                this.size.width = data.width;
            }
        },
        _updateRatio: function(data) {
            var cpos = this.position, csize = this.size, a = this.axis;
            if (this._isNumber(data.height)) {
                data.width = data.height * this.aspectRatio;
            } else if (this._isNumber(data.width)) {
                data.height = data.width / this.aspectRatio;
            }
            if (a === "sw") {
                data.left = cpos.left + (csize.width - data.width);
                data.top = null;
            }
            if (a === "nw") {
                data.top = cpos.top + (csize.height - data.height);
                data.left = cpos.left + (csize.width - data.width);
            }
            return data;
        },
        _respectSize: function(data) {
            var o = this._vBoundaries, a = this.axis, ismaxw = this._isNumber(data.width) && o.maxWidth && o.maxWidth < data.width, ismaxh = this._isNumber(data.height) && o.maxHeight && o.maxHeight < data.height, isminw = this._isNumber(data.width) && o.minWidth && o.minWidth > data.width, isminh = this._isNumber(data.height) && o.minHeight && o.minHeight > data.height, dw = this.originalPosition.left + this.originalSize.width, dh = this.originalPosition.top + this.originalSize.height, cw = /sw|nw|w/.test(a), ch = /nw|ne|n/.test(a);
            if (isminw) {
                data.width = o.minWidth;
            }
            if (isminh) {
                data.height = o.minHeight;
            }
            if (ismaxw) {
                data.width = o.maxWidth;
            }
            if (ismaxh) {
                data.height = o.maxHeight;
            }
            if (isminw && cw) {
                data.left = dw - o.minWidth;
            }
            if (ismaxw && cw) {
                data.left = dw - o.maxWidth;
            }
            if (isminh && ch) {
                data.top = dh - o.minHeight;
            }
            if (ismaxh && ch) {
                data.top = dh - o.maxHeight;
            }
            if (!data.width && !data.height && !data.left && data.top) {
                data.top = null;
            } else if (!data.width && !data.height && !data.top && data.left) {
                data.left = null;
            }
            return data;
        },
        _getPaddingPlusBorderDimensions: function(element) {
            var i = 0, widths = [], borders = [ element.css("borderTopWidth"), element.css("borderRightWidth"), element.css("borderBottomWidth"), element.css("borderLeftWidth") ], paddings = [ element.css("paddingTop"), element.css("paddingRight"), element.css("paddingBottom"), element.css("paddingLeft") ];
            for (;i < 4; i++) {
                widths[i] = parseFloat(borders[i]) || 0;
                widths[i] += parseFloat(paddings[i]) || 0;
            }
            return {
                height: widths[0] + widths[2],
                width: widths[1] + widths[3]
            };
        },
        _proportionallyResize: function() {
            if (!this._proportionallyResizeElements.length) {
                return;
            }
            var prel, i = 0, element = this.helper || this.element;
            for (;i < this._proportionallyResizeElements.length; i++) {
                prel = this._proportionallyResizeElements[i];
                if (!this.outerDimensions) {
                    this.outerDimensions = this._getPaddingPlusBorderDimensions(prel);
                }
                prel.css({
                    height: element.height() - this.outerDimensions.height || 0,
                    width: element.width() - this.outerDimensions.width || 0
                });
            }
        },
        _renderProxy: function() {
            var el = this.element, o = this.options;
            this.elementOffset = el.offset();
            if (this._helper) {
                this.helper = this.helper || $("<div style='overflow:hidden;'></div>");
                this._addClass(this.helper, this._helper);
                this.helper.css({
                    width: this.element.outerWidth(),
                    height: this.element.outerHeight(),
                    position: "absolute",
                    left: this.elementOffset.left + "px",
                    top: this.elementOffset.top + "px",
                    zIndex: ++o.zIndex
                });
                this.helper.appendTo("body").disableSelection();
            } else {
                this.helper = this.element;
            }
        },
        _change: {
            e: function(event, dx) {
                return {
                    width: this.originalSize.width + dx
                };
            },
            w: function(event, dx) {
                var cs = this.originalSize, sp = this.originalPosition;
                return {
                    left: sp.left + dx,
                    width: cs.width - dx
                };
            },
            n: function(event, dx, dy) {
                var cs = this.originalSize, sp = this.originalPosition;
                return {
                    top: sp.top + dy,
                    height: cs.height - dy
                };
            },
            s: function(event, dx, dy) {
                return {
                    height: this.originalSize.height + dy
                };
            },
            se: function(event, dx, dy) {
                return $.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [ event, dx, dy ]));
            },
            sw: function(event, dx, dy) {
                return $.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [ event, dx, dy ]));
            },
            ne: function(event, dx, dy) {
                return $.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [ event, dx, dy ]));
            },
            nw: function(event, dx, dy) {
                return $.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [ event, dx, dy ]));
            }
        },
        _propagate: function(n, event) {
            $.ui.plugin.call(this, n, [ event, this.ui() ]);
            n !== "resize" && this._trigger(n, event, this.ui());
        },
        plugins: {},
        ui: function() {
            return {
                originalElement: this.originalElement,
                element: this.element,
                helper: this.helper,
                position: this.position,
                size: this.size,
                originalSize: this.originalSize,
                originalPosition: this.originalPosition
            };
        }
    });
    $.ui.plugin.add("resizable", "animate", {
        stop: function(event) {
            var that = $(this).resizable("instance"), o = that.options, pr = that._proportionallyResizeElements, ista = pr.length && /textarea/i.test(pr[0].nodeName), soffseth = ista && that._hasScroll(pr[0], "left") ? 0 : that.sizeDiff.height, soffsetw = ista ? 0 : that.sizeDiff.width, style = {
                width: that.size.width - soffsetw,
                height: that.size.height - soffseth
            }, left = parseFloat(that.element.css("left")) + (that.position.left - that.originalPosition.left) || null, top = parseFloat(that.element.css("top")) + (that.position.top - that.originalPosition.top) || null;
            that.element.animate($.extend(style, top && left ? {
                top: top,
                left: left
            } : {}), {
                duration: o.animateDuration,
                easing: o.animateEasing,
                step: function() {
                    var data = {
                        width: parseFloat(that.element.css("width")),
                        height: parseFloat(that.element.css("height")),
                        top: parseFloat(that.element.css("top")),
                        left: parseFloat(that.element.css("left"))
                    };
                    if (pr && pr.length) {
                        $(pr[0]).css({
                            width: data.width,
                            height: data.height
                        });
                    }
                    that._updateCache(data);
                    that._propagate("resize", event);
                }
            });
        }
    });
    $.ui.plugin.add("resizable", "containment", {
        start: function() {
            var element, p, co, ch, cw, width, height, that = $(this).resizable("instance"), o = that.options, el = that.element, oc = o.containment, ce = oc instanceof $ ? oc.get(0) : /parent/.test(oc) ? el.parent().get(0) : oc;
            if (!ce) {
                return;
            }
            that.containerElement = $(ce);
            if (/document/.test(oc) || oc === document) {
                that.containerOffset = {
                    left: 0,
                    top: 0
                };
                that.containerPosition = {
                    left: 0,
                    top: 0
                };
                that.parentData = {
                    element: $(document),
                    left: 0,
                    top: 0,
                    width: $(document).width(),
                    height: $(document).height() || document.body.parentNode.scrollHeight
                };
            } else {
                element = $(ce);
                p = [];
                $([ "Top", "Right", "Left", "Bottom" ]).each(function(i, name) {
                    p[i] = that._num(element.css("padding" + name));
                });
                that.containerOffset = element.offset();
                that.containerPosition = element.position();
                that.containerSize = {
                    height: element.innerHeight() - p[3],
                    width: element.innerWidth() - p[1]
                };
                co = that.containerOffset;
                ch = that.containerSize.height;
                cw = that.containerSize.width;
                width = that._hasScroll(ce, "left") ? ce.scrollWidth : cw;
                height = that._hasScroll(ce) ? ce.scrollHeight : ch;
                that.parentData = {
                    element: ce,
                    left: co.left,
                    top: co.top,
                    width: width,
                    height: height
                };
            }
        },
        resize: function(event) {
            var woset, hoset, isParent, isOffsetRelative, that = $(this).resizable("instance"), o = that.options, co = that.containerOffset, cp = that.position, pRatio = that._aspectRatio || event.shiftKey, cop = {
                top: 0,
                left: 0
            }, ce = that.containerElement, continueResize = true;
            if (ce[0] !== document && /static/.test(ce.css("position"))) {
                cop = co;
            }
            if (cp.left < (that._helper ? co.left : 0)) {
                that.size.width = that.size.width + (that._helper ? that.position.left - co.left : that.position.left - cop.left);
                if (pRatio) {
                    that.size.height = that.size.width / that.aspectRatio;
                    continueResize = false;
                }
                that.position.left = o.helper ? co.left : 0;
            }
            if (cp.top < (that._helper ? co.top : 0)) {
                that.size.height = that.size.height + (that._helper ? that.position.top - co.top : that.position.top);
                if (pRatio) {
                    that.size.width = that.size.height * that.aspectRatio;
                    continueResize = false;
                }
                that.position.top = that._helper ? co.top : 0;
            }
            isParent = that.containerElement.get(0) === that.element.parent().get(0);
            isOffsetRelative = /relative|absolute/.test(that.containerElement.css("position"));
            if (isParent && isOffsetRelative) {
                that.offset.left = that.parentData.left + that.position.left;
                that.offset.top = that.parentData.top + that.position.top;
            } else {
                that.offset.left = that.element.offset().left;
                that.offset.top = that.element.offset().top;
            }
            woset = Math.abs(that.sizeDiff.width + (that._helper ? that.offset.left - cop.left : that.offset.left - co.left));
            hoset = Math.abs(that.sizeDiff.height + (that._helper ? that.offset.top - cop.top : that.offset.top - co.top));
            if (woset + that.size.width >= that.parentData.width) {
                that.size.width = that.parentData.width - woset;
                if (pRatio) {
                    that.size.height = that.size.width / that.aspectRatio;
                    continueResize = false;
                }
            }
            if (hoset + that.size.height >= that.parentData.height) {
                that.size.height = that.parentData.height - hoset;
                if (pRatio) {
                    that.size.width = that.size.height * that.aspectRatio;
                    continueResize = false;
                }
            }
            if (!continueResize) {
                that.position.left = that.prevPosition.left;
                that.position.top = that.prevPosition.top;
                that.size.width = that.prevSize.width;
                that.size.height = that.prevSize.height;
            }
        },
        stop: function() {
            var that = $(this).resizable("instance"), o = that.options, co = that.containerOffset, cop = that.containerPosition, ce = that.containerElement, helper = $(that.helper), ho = helper.offset(), w = helper.outerWidth() - that.sizeDiff.width, h = helper.outerHeight() - that.sizeDiff.height;
            if (that._helper && !o.animate && /relative/.test(ce.css("position"))) {
                $(this).css({
                    left: ho.left - cop.left - co.left,
                    width: w,
                    height: h
                });
            }
            if (that._helper && !o.animate && /static/.test(ce.css("position"))) {
                $(this).css({
                    left: ho.left - cop.left - co.left,
                    width: w,
                    height: h
                });
            }
        }
    });
    $.ui.plugin.add("resizable", "alsoResize", {
        start: function() {
            var that = $(this).resizable("instance"), o = that.options;
            $(o.alsoResize).each(function() {
                var el = $(this);
                el.data("ui-resizable-alsoresize", {
                    width: parseFloat(el.width()),
                    height: parseFloat(el.height()),
                    left: parseFloat(el.css("left")),
                    top: parseFloat(el.css("top"))
                });
            });
        },
        resize: function(event, ui) {
            var that = $(this).resizable("instance"), o = that.options, os = that.originalSize, op = that.originalPosition, delta = {
                height: that.size.height - os.height || 0,
                width: that.size.width - os.width || 0,
                top: that.position.top - op.top || 0,
                left: that.position.left - op.left || 0
            };
            $(o.alsoResize).each(function() {
                var el = $(this), start = $(this).data("ui-resizable-alsoresize"), style = {}, css = el.parents(ui.originalElement[0]).length ? [ "width", "height" ] : [ "width", "height", "top", "left" ];
                $.each(css, function(i, prop) {
                    var sum = (start[prop] || 0) + (delta[prop] || 0);
                    if (sum && sum >= 0) {
                        style[prop] = sum || null;
                    }
                });
                el.css(style);
            });
        },
        stop: function() {
            $(this).removeData("ui-resizable-alsoresize");
        }
    });
    $.ui.plugin.add("resizable", "ghost", {
        start: function() {
            var that = $(this).resizable("instance"), cs = that.size;
            that.ghost = that.originalElement.clone();
            that.ghost.css({
                opacity: .25,
                display: "block",
                position: "relative",
                height: cs.height,
                width: cs.width,
                margin: 0,
                left: 0,
                top: 0
            });
            that._addClass(that.ghost, "ui-resizable-ghost");
            if ($.uiBackCompat !== false && typeof that.options.ghost === "string") {
                that.ghost.addClass(this.options.ghost);
            }
            that.ghost.appendTo(that.helper);
        },
        resize: function() {
            var that = $(this).resizable("instance");
            if (that.ghost) {
                that.ghost.css({
                    position: "relative",
                    height: that.size.height,
                    width: that.size.width
                });
            }
        },
        stop: function() {
            var that = $(this).resizable("instance");
            if (that.ghost && that.helper) {
                that.helper.get(0).removeChild(that.ghost.get(0));
            }
        }
    });
    $.ui.plugin.add("resizable", "grid", {
        resize: function() {
            var outerDimensions, that = $(this).resizable("instance"), o = that.options, cs = that.size, os = that.originalSize, op = that.originalPosition, a = that.axis, grid = typeof o.grid === "number" ? [ o.grid, o.grid ] : o.grid, gridX = grid[0] || 1, gridY = grid[1] || 1, ox = Math.round((cs.width - os.width) / gridX) * gridX, oy = Math.round((cs.height - os.height) / gridY) * gridY, newWidth = os.width + ox, newHeight = os.height + oy, isMaxWidth = o.maxWidth && o.maxWidth < newWidth, isMaxHeight = o.maxHeight && o.maxHeight < newHeight, isMinWidth = o.minWidth && o.minWidth > newWidth, isMinHeight = o.minHeight && o.minHeight > newHeight;
            o.grid = grid;
            if (isMinWidth) {
                newWidth += gridX;
            }
            if (isMinHeight) {
                newHeight += gridY;
            }
            if (isMaxWidth) {
                newWidth -= gridX;
            }
            if (isMaxHeight) {
                newHeight -= gridY;
            }
            if (/^(se|s|e)$/.test(a)) {
                that.size.width = newWidth;
                that.size.height = newHeight;
            } else if (/^(ne)$/.test(a)) {
                that.size.width = newWidth;
                that.size.height = newHeight;
                that.position.top = op.top - oy;
            } else if (/^(sw)$/.test(a)) {
                that.size.width = newWidth;
                that.size.height = newHeight;
                that.position.left = op.left - ox;
            } else {
                if (newHeight - gridY <= 0 || newWidth - gridX <= 0) {
                    outerDimensions = that._getPaddingPlusBorderDimensions(this);
                }
                if (newHeight - gridY > 0) {
                    that.size.height = newHeight;
                    that.position.top = op.top - oy;
                } else {
                    newHeight = gridY - outerDimensions.height;
                    that.size.height = newHeight;
                    that.position.top = op.top + os.height - newHeight;
                }
                if (newWidth - gridX > 0) {
                    that.size.width = newWidth;
                    that.position.left = op.left - ox;
                } else {
                    newWidth = gridX - outerDimensions.width;
                    that.size.width = newWidth;
                    that.position.left = op.left + os.width - newWidth;
                }
            }
        }
    });
    var widgetsResizable = $.ui.resizable;
    $.widget("ui.dialog", {
        version: "1.12.1",
        options: {
            appendTo: "body",
            autoOpen: true,
            buttons: [],
            classes: {
                "ui-dialog": "ui-corner-all",
                "ui-dialog-titlebar": "ui-corner-all"
            },
            closeOnEscape: true,
            closeText: "Close",
            draggable: true,
            hide: null,
            height: "auto",
            maxHeight: null,
            maxWidth: null,
            minHeight: 150,
            minWidth: 150,
            modal: false,
            position: {
                my: "center",
                at: "center",
                of: window,
                collision: "fit",
                using: function(pos) {
                    var topOffset = $(this).css(pos).offset().top;
                    if (topOffset < 0) {
                        $(this).css("top", pos.top - topOffset);
                    }
                }
            },
            resizable: true,
            show: null,
            title: null,
            width: 300,
            beforeClose: null,
            close: null,
            drag: null,
            dragStart: null,
            dragStop: null,
            focus: null,
            open: null,
            resize: null,
            resizeStart: null,
            resizeStop: null
        },
        sizeRelatedOptions: {
            buttons: true,
            height: true,
            maxHeight: true,
            maxWidth: true,
            minHeight: true,
            minWidth: true,
            width: true
        },
        resizableRelatedOptions: {
            maxHeight: true,
            maxWidth: true,
            minHeight: true,
            minWidth: true
        },
        _create: function() {
            this.originalCss = {
                display: this.element[0].style.display,
                width: this.element[0].style.width,
                minHeight: this.element[0].style.minHeight,
                maxHeight: this.element[0].style.maxHeight,
                height: this.element[0].style.height
            };
            this.originalPosition = {
                parent: this.element.parent(),
                index: this.element.parent().children().index(this.element)
            };
            this.originalTitle = this.element.attr("title");
            if (this.options.title == null && this.originalTitle != null) {
                this.options.title = this.originalTitle;
            }
            if (this.options.disabled) {
                this.options.disabled = false;
            }
            this._createWrapper();
            this.element.show().removeAttr("title").appendTo(this.uiDialog);
            this._addClass("ui-dialog-content", "ui-widget-content");
            this._createTitlebar();
            this._createButtonPane();
            if (this.options.draggable && $.fn.draggable) {
                this._makeDraggable();
            }
            if (this.options.resizable && $.fn.resizable) {
                this._makeResizable();
            }
            this._isOpen = false;
            this._trackFocus();
        },
        _init: function() {
            if (this.options.autoOpen) {
                this.open();
            }
        },
        _appendTo: function() {
            var element = this.options.appendTo;
            if (element && (element.jquery || element.nodeType)) {
                return $(element);
            }
            return this.document.find(element || "body").eq(0);
        },
        _destroy: function() {
            var next, originalPosition = this.originalPosition;
            this._untrackInstance();
            this._destroyOverlay();
            this.element.removeUniqueId().css(this.originalCss).detach();
            this.uiDialog.remove();
            if (this.originalTitle) {
                this.element.attr("title", this.originalTitle);
            }
            next = originalPosition.parent.children().eq(originalPosition.index);
            if (next.length && next[0] !== this.element[0]) {
                next.before(this.element);
            } else {
                originalPosition.parent.append(this.element);
            }
        },
        widget: function() {
            return this.uiDialog;
        },
        disable: $.noop,
        enable: $.noop,
        close: function(event) {
            var that = this;
            if (!this._isOpen || this._trigger("beforeClose", event) === false) {
                return;
            }
            this._isOpen = false;
            this._focusedElement = null;
            this._destroyOverlay();
            this._untrackInstance();
            if (!this.opener.filter(":focusable").trigger("focus").length) {
                $.ui.safeBlur($.ui.safeActiveElement(this.document[0]));
            }
            this._hide(this.uiDialog, this.options.hide, function() {
                that._trigger("close", event);
            });
        },
        isOpen: function() {
            return this._isOpen;
        },
        moveToTop: function() {
            this._moveToTop();
        },
        _moveToTop: function(event, silent) {
            var moved = false, zIndices = this.uiDialog.siblings(".ui-front:visible").map(function() {
                return +$(this).css("z-index");
            }).get(), zIndexMax = Math.max.apply(null, zIndices);
            if (zIndexMax >= +this.uiDialog.css("z-index")) {
                this.uiDialog.css("z-index", zIndexMax + 1);
                moved = true;
            }
            if (moved && !silent) {
                this._trigger("focus", event);
            }
            return moved;
        },
        open: function() {
            var that = this;
            if (this._isOpen) {
                if (this._moveToTop()) {
                    this._focusTabbable();
                }
                return;
            }
            this._isOpen = true;
            this.opener = $($.ui.safeActiveElement(this.document[0]));
            this._size();
            this._position();
            this._createOverlay();
            this._moveToTop(null, true);
            if (this.overlay) {
                this.overlay.css("z-index", this.uiDialog.css("z-index") - 1);
            }
            this._show(this.uiDialog, this.options.show, function() {
                that._focusTabbable();
                that._trigger("focus");
            });
            this._makeFocusTarget();
            this._trigger("open");
        },
        _focusTabbable: function() {
            var hasFocus = this._focusedElement;
            if (!hasFocus) {
                hasFocus = this.element.find("[autofocus]");
            }
            if (!hasFocus.length) {
                hasFocus = this.element.find(":tabbable");
            }
            if (!hasFocus.length) {
                hasFocus = this.uiDialogButtonPane.find(":tabbable");
            }
            if (!hasFocus.length) {
                hasFocus = this.uiDialogTitlebarClose.filter(":tabbable");
            }
            if (!hasFocus.length) {
                hasFocus = this.uiDialog;
            }
            hasFocus.eq(0).trigger("focus");
        },
        _keepFocus: function(event) {
            function checkFocus() {
                var activeElement = $.ui.safeActiveElement(this.document[0]), isActive = this.uiDialog[0] === activeElement || $.contains(this.uiDialog[0], activeElement);
                if (!isActive) {
                    this._focusTabbable();
                }
            }
            event.preventDefault();
            checkFocus.call(this);
            this._delay(checkFocus);
        },
        _createWrapper: function() {
            this.uiDialog = $("<div>").hide().attr({
                tabIndex: -1,
                role: "dialog"
            }).appendTo(this._appendTo());
            this._addClass(this.uiDialog, "ui-dialog", "ui-widget ui-widget-content ui-front");
            this._on(this.uiDialog, {
                keydown: function(event) {
                    if (this.options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode && event.keyCode === $.ui.keyCode.ESCAPE) {
                        event.preventDefault();
                        this.close(event);
                        return;
                    }
                    if (event.keyCode !== $.ui.keyCode.TAB || event.isDefaultPrevented()) {
                        return;
                    }
                    var tabbables = this.uiDialog.find(":tabbable"), first = tabbables.filter(":first"), last = tabbables.filter(":last");
                    if ((event.target === last[0] || event.target === this.uiDialog[0]) && !event.shiftKey) {
                        this._delay(function() {
                            first.trigger("focus");
                        });
                        event.preventDefault();
                    } else if ((event.target === first[0] || event.target === this.uiDialog[0]) && event.shiftKey) {
                        this._delay(function() {
                            last.trigger("focus");
                        });
                        event.preventDefault();
                    }
                },
                mousedown: function(event) {
                    if (this._moveToTop(event)) {
                        this._focusTabbable();
                    }
                }
            });
            if (!this.element.find("[aria-describedby]").length) {
                this.uiDialog.attr({
                    "aria-describedby": this.element.uniqueId().attr("id")
                });
            }
        },
        _createTitlebar: function() {
            var uiDialogTitle;
            this.uiDialogTitlebar = $("<div>");
            this._addClass(this.uiDialogTitlebar, "ui-dialog-titlebar", "ui-widget-header ui-helper-clearfix");
            this._on(this.uiDialogTitlebar, {
                mousedown: function(event) {
                    if (!$(event.target).closest(".ui-dialog-titlebar-close")) {
                        this.uiDialog.trigger("focus");
                    }
                }
            });
            this.uiDialogTitlebarClose = $("<button type='button'></button>").button({
                label: $("<a>").text(this.options.closeText).html(),
                icon: "ui-icon-closethick",
                showLabel: false
            }).appendTo(this.uiDialogTitlebar);
            this._addClass(this.uiDialogTitlebarClose, "ui-dialog-titlebar-close");
            this._on(this.uiDialogTitlebarClose, {
                click: function(event) {
                    event.preventDefault();
                    this.close(event);
                }
            });
            uiDialogTitle = $("<span>").uniqueId().prependTo(this.uiDialogTitlebar);
            this._addClass(uiDialogTitle, "ui-dialog-title");
            this._title(uiDialogTitle);
            this.uiDialogTitlebar.prependTo(this.uiDialog);
            this.uiDialog.attr({
                "aria-labelledby": uiDialogTitle.attr("id")
            });
        },
        _title: function(title) {
            if (this.options.title) {
                title.text(this.options.title);
            } else {
                title.html("&#160;");
            }
        },
        _createButtonPane: function() {
            this.uiDialogButtonPane = $("<div>");
            this._addClass(this.uiDialogButtonPane, "ui-dialog-buttonpane", "ui-widget-content ui-helper-clearfix");
            this.uiButtonSet = $("<div>").appendTo(this.uiDialogButtonPane);
            this._addClass(this.uiButtonSet, "ui-dialog-buttonset");
            this._createButtons();
        },
        _createButtons: function() {
            var that = this, buttons = this.options.buttons;
            this.uiDialogButtonPane.remove();
            this.uiButtonSet.empty();
            if ($.isEmptyObject(buttons) || $.isArray(buttons) && !buttons.length) {
                this._removeClass(this.uiDialog, "ui-dialog-buttons");
                return;
            }
            $.each(buttons, function(name, props) {
                var click, buttonOptions;
                props = $.isFunction(props) ? {
                    click: props,
                    text: name
                } : props;
                props = $.extend({
                    type: "button"
                }, props);
                click = props.click;
                buttonOptions = {
                    icon: props.icon,
                    iconPosition: props.iconPosition,
                    showLabel: props.showLabel,
                    icons: props.icons,
                    text: props.text
                };
                delete props.click;
                delete props.icon;
                delete props.iconPosition;
                delete props.showLabel;
                delete props.icons;
                if (typeof props.text === "boolean") {
                    delete props.text;
                }
                $("<button></button>", props).button(buttonOptions).appendTo(that.uiButtonSet).on("click", function() {
                    click.apply(that.element[0], arguments);
                });
            });
            this._addClass(this.uiDialog, "ui-dialog-buttons");
            this.uiDialogButtonPane.appendTo(this.uiDialog);
        },
        _makeDraggable: function() {
            var that = this, options = this.options;
            function filteredUi(ui) {
                return {
                    position: ui.position,
                    offset: ui.offset
                };
            }
            this.uiDialog.draggable({
                cancel: ".ui-dialog-content, .ui-dialog-titlebar-close",
                handle: ".ui-dialog-titlebar",
                containment: "document",
                start: function(event, ui) {
                    that._addClass($(this), "ui-dialog-dragging");
                    that._blockFrames();
                    that._trigger("dragStart", event, filteredUi(ui));
                },
                drag: function(event, ui) {
                    that._trigger("drag", event, filteredUi(ui));
                },
                stop: function(event, ui) {
                    var left = ui.offset.left - that.document.scrollLeft(), top = ui.offset.top - that.document.scrollTop();
                    options.position = {
                        my: "left top",
                        at: "left" + (left >= 0 ? "+" : "") + left + " " + "top" + (top >= 0 ? "+" : "") + top,
                        of: that.window
                    };
                    that._removeClass($(this), "ui-dialog-dragging");
                    that._unblockFrames();
                    that._trigger("dragStop", event, filteredUi(ui));
                }
            });
        },
        _makeResizable: function() {
            var that = this, options = this.options, handles = options.resizable, position = this.uiDialog.css("position"), resizeHandles = typeof handles === "string" ? handles : "n,e,s,w,se,sw,ne,nw";
            function filteredUi(ui) {
                return {
                    originalPosition: ui.originalPosition,
                    originalSize: ui.originalSize,
                    position: ui.position,
                    size: ui.size
                };
            }
            this.uiDialog.resizable({
                cancel: ".ui-dialog-content",
                containment: "document",
                alsoResize: this.element,
                maxWidth: options.maxWidth,
                maxHeight: options.maxHeight,
                minWidth: options.minWidth,
                minHeight: this._minHeight(),
                handles: resizeHandles,
                start: function(event, ui) {
                    that._addClass($(this), "ui-dialog-resizing");
                    that._blockFrames();
                    that._trigger("resizeStart", event, filteredUi(ui));
                },
                resize: function(event, ui) {
                    that._trigger("resize", event, filteredUi(ui));
                },
                stop: function(event, ui) {
                    var offset = that.uiDialog.offset(), left = offset.left - that.document.scrollLeft(), top = offset.top - that.document.scrollTop();
                    options.height = that.uiDialog.height();
                    options.width = that.uiDialog.width();
                    options.position = {
                        my: "left top",
                        at: "left" + (left >= 0 ? "+" : "") + left + " " + "top" + (top >= 0 ? "+" : "") + top,
                        of: that.window
                    };
                    that._removeClass($(this), "ui-dialog-resizing");
                    that._unblockFrames();
                    that._trigger("resizeStop", event, filteredUi(ui));
                }
            }).css("position", position);
        },
        _trackFocus: function() {
            this._on(this.widget(), {
                focusin: function(event) {
                    this._makeFocusTarget();
                    this._focusedElement = $(event.target);
                }
            });
        },
        _makeFocusTarget: function() {
            this._untrackInstance();
            this._trackingInstances().unshift(this);
        },
        _untrackInstance: function() {
            var instances = this._trackingInstances(), exists = $.inArray(this, instances);
            if (exists !== -1) {
                instances.splice(exists, 1);
            }
        },
        _trackingInstances: function() {
            var instances = this.document.data("ui-dialog-instances");
            if (!instances) {
                instances = [];
                this.document.data("ui-dialog-instances", instances);
            }
            return instances;
        },
        _minHeight: function() {
            var options = this.options;
            return options.height === "auto" ? options.minHeight : Math.min(options.minHeight, options.height);
        },
        _position: function() {
            var isVisible = this.uiDialog.is(":visible");
            if (!isVisible) {
                this.uiDialog.show();
            }
            this.uiDialog.position(this.options.position);
            if (!isVisible) {
                this.uiDialog.hide();
            }
        },
        _setOptions: function(options) {
            var that = this, resize = false, resizableOptions = {};
            $.each(options, function(key, value) {
                that._setOption(key, value);
                if (key in that.sizeRelatedOptions) {
                    resize = true;
                }
                if (key in that.resizableRelatedOptions) {
                    resizableOptions[key] = value;
                }
            });
            if (resize) {
                this._size();
                this._position();
            }
            if (this.uiDialog.is(":data(ui-resizable)")) {
                this.uiDialog.resizable("option", resizableOptions);
            }
        },
        _setOption: function(key, value) {
            var isDraggable, isResizable, uiDialog = this.uiDialog;
            if (key === "disabled") {
                return;
            }
            this._super(key, value);
            if (key === "appendTo") {
                this.uiDialog.appendTo(this._appendTo());
            }
            if (key === "buttons") {
                this._createButtons();
            }
            if (key === "closeText") {
                this.uiDialogTitlebarClose.button({
                    label: $("<a>").text("" + this.options.closeText).html()
                });
            }
            if (key === "draggable") {
                isDraggable = uiDialog.is(":data(ui-draggable)");
                if (isDraggable && !value) {
                    uiDialog.draggable("destroy");
                }
                if (!isDraggable && value) {
                    this._makeDraggable();
                }
            }
            if (key === "position") {
                this._position();
            }
            if (key === "resizable") {
                isResizable = uiDialog.is(":data(ui-resizable)");
                if (isResizable && !value) {
                    uiDialog.resizable("destroy");
                }
                if (isResizable && typeof value === "string") {
                    uiDialog.resizable("option", "handles", value);
                }
                if (!isResizable && value !== false) {
                    this._makeResizable();
                }
            }
            if (key === "title") {
                this._title(this.uiDialogTitlebar.find(".ui-dialog-title"));
            }
        },
        _size: function() {
            var nonContentHeight, minContentHeight, maxContentHeight, options = this.options;
            this.element.show().css({
                width: "auto",
                minHeight: 0,
                maxHeight: "none",
                height: 0
            });
            if (options.minWidth > options.width) {
                options.width = options.minWidth;
            }
            nonContentHeight = this.uiDialog.css({
                height: "auto",
                width: options.width
            }).outerHeight();
            minContentHeight = Math.max(0, options.minHeight - nonContentHeight);
            maxContentHeight = typeof options.maxHeight === "number" ? Math.max(0, options.maxHeight - nonContentHeight) : "none";
            if (options.height === "auto") {
                this.element.css({
                    minHeight: minContentHeight,
                    maxHeight: maxContentHeight,
                    height: "auto"
                });
            } else {
                this.element.height(Math.max(0, options.height - nonContentHeight));
            }
            if (this.uiDialog.is(":data(ui-resizable)")) {
                this.uiDialog.resizable("option", "minHeight", this._minHeight());
            }
        },
        _blockFrames: function() {
            this.iframeBlocks = this.document.find("iframe").map(function() {
                var iframe = $(this);
                return $("<div>").css({
                    position: "absolute",
                    width: iframe.outerWidth(),
                    height: iframe.outerHeight()
                }).appendTo(iframe.parent()).offset(iframe.offset())[0];
            });
        },
        _unblockFrames: function() {
            if (this.iframeBlocks) {
                this.iframeBlocks.remove();
                delete this.iframeBlocks;
            }
        },
        _allowInteraction: function(event) {
            if ($(event.target).closest(".ui-dialog").length) {
                return true;
            }
            return !!$(event.target).closest(".ui-datepicker").length;
        },
        _createOverlay: function() {
            if (!this.options.modal) {
                return;
            }
            var isOpening = true;
            this._delay(function() {
                isOpening = false;
            });
            if (!this.document.data("ui-dialog-overlays")) {
                this._on(this.document, {
                    focusin: function(event) {
                        if (isOpening) {
                            return;
                        }
                        if (!this._allowInteraction(event)) {
                            event.preventDefault();
                            this._trackingInstances()[0]._focusTabbable();
                        }
                    }
                });
            }
            this.overlay = $("<div>").appendTo(this._appendTo());
            this._addClass(this.overlay, null, "ui-widget-overlay ui-front");
            this._on(this.overlay, {
                mousedown: "_keepFocus"
            });
            this.document.data("ui-dialog-overlays", (this.document.data("ui-dialog-overlays") || 0) + 1);
        },
        _destroyOverlay: function() {
            if (!this.options.modal) {
                return;
            }
            if (this.overlay) {
                var overlays = this.document.data("ui-dialog-overlays") - 1;
                if (!overlays) {
                    this._off(this.document, "focusin");
                    this.document.removeData("ui-dialog-overlays");
                } else {
                    this.document.data("ui-dialog-overlays", overlays);
                }
                this.overlay.remove();
                this.overlay = null;
            }
        }
    });
    if ($.uiBackCompat !== false) {
        $.widget("ui.dialog", $.ui.dialog, {
            options: {
                dialogClass: ""
            },
            _createWrapper: function() {
                this._super();
                this.uiDialog.addClass(this.options.dialogClass);
            },
            _setOption: function(key, value) {
                if (key === "dialogClass") {
                    this.uiDialog.removeClass(this.options.dialogClass).addClass(value);
                }
                this._superApply(arguments);
            }
        });
    }
    var widgetsDialog = $.ui.dialog;
    $.widget("ui.droppable", {
        version: "1.12.1",
        widgetEventPrefix: "drop",
        options: {
            accept: "*",
            addClasses: true,
            greedy: false,
            scope: "default",
            tolerance: "intersect",
            activate: null,
            deactivate: null,
            drop: null,
            out: null,
            over: null
        },
        _create: function() {
            var proportions, o = this.options, accept = o.accept;
            this.isover = false;
            this.isout = true;
            this.accept = $.isFunction(accept) ? accept : function(d) {
                return d.is(accept);
            };
            this.proportions = function() {
                if (arguments.length) {
                    proportions = arguments[0];
                } else {
                    return proportions ? proportions : proportions = {
                        width: this.element[0].offsetWidth,
                        height: this.element[0].offsetHeight
                    };
                }
            };
            this._addToManager(o.scope);
            o.addClasses && this._addClass("ui-droppable");
        },
        _addToManager: function(scope) {
            $.ui.ddmanager.droppables[scope] = $.ui.ddmanager.droppables[scope] || [];
            $.ui.ddmanager.droppables[scope].push(this);
        },
        _splice: function(drop) {
            var i = 0;
            for (;i < drop.length; i++) {
                if (drop[i] === this) {
                    drop.splice(i, 1);
                }
            }
        },
        _destroy: function() {
            var drop = $.ui.ddmanager.droppables[this.options.scope];
            this._splice(drop);
        },
        _setOption: function(key, value) {
            if (key === "accept") {
                this.accept = $.isFunction(value) ? value : function(d) {
                    return d.is(value);
                };
            } else if (key === "scope") {
                var drop = $.ui.ddmanager.droppables[this.options.scope];
                this._splice(drop);
                this._addToManager(value);
            }
            this._super(key, value);
        },
        _activate: function(event) {
            var draggable = $.ui.ddmanager.current;
            this._addActiveClass();
            if (draggable) {
                this._trigger("activate", event, this.ui(draggable));
            }
        },
        _deactivate: function(event) {
            var draggable = $.ui.ddmanager.current;
            this._removeActiveClass();
            if (draggable) {
                this._trigger("deactivate", event, this.ui(draggable));
            }
        },
        _over: function(event) {
            var draggable = $.ui.ddmanager.current;
            if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
                return;
            }
            if (this.accept.call(this.element[0], draggable.currentItem || draggable.element)) {
                this._addHoverClass();
                this._trigger("over", event, this.ui(draggable));
            }
        },
        _out: function(event) {
            var draggable = $.ui.ddmanager.current;
            if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
                return;
            }
            if (this.accept.call(this.element[0], draggable.currentItem || draggable.element)) {
                this._removeHoverClass();
                this._trigger("out", event, this.ui(draggable));
            }
        },
        _drop: function(event, custom) {
            var draggable = custom || $.ui.ddmanager.current, childrenIntersection = false;
            if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
                return false;
            }
            this.element.find(":data(ui-droppable)").not(".ui-draggable-dragging").each(function() {
                var inst = $(this).droppable("instance");
                if (inst.options.greedy && !inst.options.disabled && inst.options.scope === draggable.options.scope && inst.accept.call(inst.element[0], draggable.currentItem || draggable.element) && intersect(draggable, $.extend(inst, {
                    offset: inst.element.offset()
                }), inst.options.tolerance, event)) {
                    childrenIntersection = true;
                    return false;
                }
            });
            if (childrenIntersection) {
                return false;
            }
            if (this.accept.call(this.element[0], draggable.currentItem || draggable.element)) {
                this._removeActiveClass();
                this._removeHoverClass();
                this._trigger("drop", event, this.ui(draggable));
                return this.element;
            }
            return false;
        },
        ui: function(c) {
            return {
                draggable: c.currentItem || c.element,
                helper: c.helper,
                position: c.position,
                offset: c.positionAbs
            };
        },
        _addHoverClass: function() {
            this._addClass("ui-droppable-hover");
        },
        _removeHoverClass: function() {
            this._removeClass("ui-droppable-hover");
        },
        _addActiveClass: function() {
            this._addClass("ui-droppable-active");
        },
        _removeActiveClass: function() {
            this._removeClass("ui-droppable-active");
        }
    });
    var intersect = $.ui.intersect = function() {
        function isOverAxis(x, reference, size) {
            return x >= reference && x < reference + size;
        }
        return function(draggable, droppable, toleranceMode, event) {
            if (!droppable.offset) {
                return false;
            }
            var x1 = (draggable.positionAbs || draggable.position.absolute).left + draggable.margins.left, y1 = (draggable.positionAbs || draggable.position.absolute).top + draggable.margins.top, x2 = x1 + draggable.helperProportions.width, y2 = y1 + draggable.helperProportions.height, l = droppable.offset.left, t = droppable.offset.top, r = l + droppable.proportions().width, b = t + droppable.proportions().height;
            switch (toleranceMode) {
              case "fit":
                return l <= x1 && x2 <= r && t <= y1 && y2 <= b;

              case "intersect":
                return l < x1 + draggable.helperProportions.width / 2 && x2 - draggable.helperProportions.width / 2 < r && t < y1 + draggable.helperProportions.height / 2 && y2 - draggable.helperProportions.height / 2 < b;

              case "pointer":
                return isOverAxis(event.pageY, t, droppable.proportions().height) && isOverAxis(event.pageX, l, droppable.proportions().width);

              case "touch":
                return (y1 >= t && y1 <= b || y2 >= t && y2 <= b || y1 < t && y2 > b) && (x1 >= l && x1 <= r || x2 >= l && x2 <= r || x1 < l && x2 > r);

              default:
                return false;
            }
        };
    }();
    $.ui.ddmanager = {
        current: null,
        droppables: {
            "default": []
        },
        prepareOffsets: function(t, event) {
            var i, j, m = $.ui.ddmanager.droppables[t.options.scope] || [], type = event ? event.type : null, list = (t.currentItem || t.element).find(":data(ui-droppable)").addBack();
            droppablesLoop: for (i = 0; i < m.length; i++) {
                if (m[i].options.disabled || t && !m[i].accept.call(m[i].element[0], t.currentItem || t.element)) {
                    continue;
                }
                for (j = 0; j < list.length; j++) {
                    if (list[j] === m[i].element[0]) {
                        m[i].proportions().height = 0;
                        continue droppablesLoop;
                    }
                }
                m[i].visible = m[i].element.css("display") !== "none";
                if (!m[i].visible) {
                    continue;
                }
                if (type === "mousedown") {
                    m[i]._activate.call(m[i], event);
                }
                m[i].offset = m[i].element.offset();
                m[i].proportions({
                    width: m[i].element[0].offsetWidth,
                    height: m[i].element[0].offsetHeight
                });
            }
        },
        drop: function(draggable, event) {
            var dropped = false;
            $.each(($.ui.ddmanager.droppables[draggable.options.scope] || []).slice(), function() {
                if (!this.options) {
                    return;
                }
                if (!this.options.disabled && this.visible && intersect(draggable, this, this.options.tolerance, event)) {
                    dropped = this._drop.call(this, event) || dropped;
                }
                if (!this.options.disabled && this.visible && this.accept.call(this.element[0], draggable.currentItem || draggable.element)) {
                    this.isout = true;
                    this.isover = false;
                    this._deactivate.call(this, event);
                }
            });
            return dropped;
        },
        dragStart: function(draggable, event) {
            draggable.element.parentsUntil("body").on("scroll.droppable", function() {
                if (!draggable.options.refreshPositions) {
                    $.ui.ddmanager.prepareOffsets(draggable, event);
                }
            });
        },
        drag: function(draggable, event) {
            if (draggable.options.refreshPositions) {
                $.ui.ddmanager.prepareOffsets(draggable, event);
            }
            $.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {
                if (this.options.disabled || this.greedyChild || !this.visible) {
                    return;
                }
                var parentInstance, scope, parent, intersects = intersect(draggable, this, this.options.tolerance, event), c = !intersects && this.isover ? "isout" : intersects && !this.isover ? "isover" : null;
                if (!c) {
                    return;
                }
                if (this.options.greedy) {
                    scope = this.options.scope;
                    parent = this.element.parents(":data(ui-droppable)").filter(function() {
                        return $(this).droppable("instance").options.scope === scope;
                    });
                    if (parent.length) {
                        parentInstance = $(parent[0]).droppable("instance");
                        parentInstance.greedyChild = c === "isover";
                    }
                }
                if (parentInstance && c === "isover") {
                    parentInstance.isover = false;
                    parentInstance.isout = true;
                    parentInstance._out.call(parentInstance, event);
                }
                this[c] = true;
                this[c === "isout" ? "isover" : "isout"] = false;
                this[c === "isover" ? "_over" : "_out"].call(this, event);
                if (parentInstance && c === "isout") {
                    parentInstance.isout = false;
                    parentInstance.isover = true;
                    parentInstance._over.call(parentInstance, event);
                }
            });
        },
        dragStop: function(draggable, event) {
            draggable.element.parentsUntil("body").off("scroll.droppable");
            if (!draggable.options.refreshPositions) {
                $.ui.ddmanager.prepareOffsets(draggable, event);
            }
        }
    };
    if ($.uiBackCompat !== false) {
        $.widget("ui.droppable", $.ui.droppable, {
            options: {
                hoverClass: false,
                activeClass: false
            },
            _addActiveClass: function() {
                this._super();
                if (this.options.activeClass) {
                    this.element.addClass(this.options.activeClass);
                }
            },
            _removeActiveClass: function() {
                this._super();
                if (this.options.activeClass) {
                    this.element.removeClass(this.options.activeClass);
                }
            },
            _addHoverClass: function() {
                this._super();
                if (this.options.hoverClass) {
                    this.element.addClass(this.options.hoverClass);
                }
            },
            _removeHoverClass: function() {
                this._super();
                if (this.options.hoverClass) {
                    this.element.removeClass(this.options.hoverClass);
                }
            }
        });
    }
    var widgetsDroppable = $.ui.droppable;
    var widgetsProgressbar = $.widget("ui.progressbar", {
        version: "1.12.1",
        options: {
            classes: {
                "ui-progressbar": "ui-corner-all",
                "ui-progressbar-value": "ui-corner-left",
                "ui-progressbar-complete": "ui-corner-right"
            },
            max: 100,
            value: 0,
            change: null,
            complete: null
        },
        min: 0,
        _create: function() {
            this.oldValue = this.options.value = this._constrainedValue();
            this.element.attr({
                role: "progressbar",
                "aria-valuemin": this.min
            });
            this._addClass("ui-progressbar", "ui-widget ui-widget-content");
            this.valueDiv = $("<div>").appendTo(this.element);
            this._addClass(this.valueDiv, "ui-progressbar-value", "ui-widget-header");
            this._refreshValue();
        },
        _destroy: function() {
            this.element.removeAttr("role aria-valuemin aria-valuemax aria-valuenow");
            this.valueDiv.remove();
        },
        value: function(newValue) {
            if (newValue === undefined) {
                return this.options.value;
            }
            this.options.value = this._constrainedValue(newValue);
            this._refreshValue();
        },
        _constrainedValue: function(newValue) {
            if (newValue === undefined) {
                newValue = this.options.value;
            }
            this.indeterminate = newValue === false;
            if (typeof newValue !== "number") {
                newValue = 0;
            }
            return this.indeterminate ? false : Math.min(this.options.max, Math.max(this.min, newValue));
        },
        _setOptions: function(options) {
            var value = options.value;
            delete options.value;
            this._super(options);
            this.options.value = this._constrainedValue(value);
            this._refreshValue();
        },
        _setOption: function(key, value) {
            if (key === "max") {
                value = Math.max(this.min, value);
            }
            this._super(key, value);
        },
        _setOptionDisabled: function(value) {
            this._super(value);
            this.element.attr("aria-disabled", value);
            this._toggleClass(null, "ui-state-disabled", !!value);
        },
        _percentage: function() {
            return this.indeterminate ? 100 : 100 * (this.options.value - this.min) / (this.options.max - this.min);
        },
        _refreshValue: function() {
            var value = this.options.value, percentage = this._percentage();
            this.valueDiv.toggle(this.indeterminate || value > this.min).width(percentage.toFixed(0) + "%");
            this._toggleClass(this.valueDiv, "ui-progressbar-complete", null, value === this.options.max)._toggleClass("ui-progressbar-indeterminate", null, this.indeterminate);
            if (this.indeterminate) {
                this.element.removeAttr("aria-valuenow");
                if (!this.overlayDiv) {
                    this.overlayDiv = $("<div>").appendTo(this.valueDiv);
                    this._addClass(this.overlayDiv, "ui-progressbar-overlay");
                }
            } else {
                this.element.attr({
                    "aria-valuemax": this.options.max,
                    "aria-valuenow": value
                });
                if (this.overlayDiv) {
                    this.overlayDiv.remove();
                    this.overlayDiv = null;
                }
            }
            if (this.oldValue !== value) {
                this.oldValue = value;
                this._trigger("change");
            }
            if (value === this.options.max) {
                this._trigger("complete");
            }
        }
    });
    var widgetsSelectable = $.widget("ui.selectable", $.ui.mouse, {
        version: "1.12.1",
        options: {
            appendTo: "body",
            autoRefresh: true,
            distance: 0,
            filter: "*",
            tolerance: "touch",
            selected: null,
            selecting: null,
            start: null,
            stop: null,
            unselected: null,
            unselecting: null
        },
        _create: function() {
            var that = this;
            this._addClass("ui-selectable");
            this.dragged = false;
            this.refresh = function() {
                that.elementPos = $(that.element[0]).offset();
                that.selectees = $(that.options.filter, that.element[0]);
                that._addClass(that.selectees, "ui-selectee");
                that.selectees.each(function() {
                    var $this = $(this), selecteeOffset = $this.offset(), pos = {
                        left: selecteeOffset.left - that.elementPos.left,
                        top: selecteeOffset.top - that.elementPos.top
                    };
                    $.data(this, "selectable-item", {
                        element: this,
                        $element: $this,
                        left: pos.left,
                        top: pos.top,
                        right: pos.left + $this.outerWidth(),
                        bottom: pos.top + $this.outerHeight(),
                        startselected: false,
                        selected: $this.hasClass("ui-selected"),
                        selecting: $this.hasClass("ui-selecting"),
                        unselecting: $this.hasClass("ui-unselecting")
                    });
                });
            };
            this.refresh();
            this._mouseInit();
            this.helper = $("<div>");
            this._addClass(this.helper, "ui-selectable-helper");
        },
        _destroy: function() {
            this.selectees.removeData("selectable-item");
            this._mouseDestroy();
        },
        _mouseStart: function(event) {
            var that = this, options = this.options;
            this.opos = [ event.pageX, event.pageY ];
            this.elementPos = $(this.element[0]).offset();
            if (this.options.disabled) {
                return;
            }
            this.selectees = $(options.filter, this.element[0]);
            this._trigger("start", event);
            $(options.appendTo).append(this.helper);
            this.helper.css({
                left: event.pageX,
                top: event.pageY,
                width: 0,
                height: 0
            });
            if (options.autoRefresh) {
                this.refresh();
            }
            this.selectees.filter(".ui-selected").each(function() {
                var selectee = $.data(this, "selectable-item");
                selectee.startselected = true;
                if (!event.metaKey && !event.ctrlKey) {
                    that._removeClass(selectee.$element, "ui-selected");
                    selectee.selected = false;
                    that._addClass(selectee.$element, "ui-unselecting");
                    selectee.unselecting = true;
                    that._trigger("unselecting", event, {
                        unselecting: selectee.element
                    });
                }
            });
            $(event.target).parents().addBack().each(function() {
                var doSelect, selectee = $.data(this, "selectable-item");
                if (selectee) {
                    doSelect = !event.metaKey && !event.ctrlKey || !selectee.$element.hasClass("ui-selected");
                    that._removeClass(selectee.$element, doSelect ? "ui-unselecting" : "ui-selected")._addClass(selectee.$element, doSelect ? "ui-selecting" : "ui-unselecting");
                    selectee.unselecting = !doSelect;
                    selectee.selecting = doSelect;
                    selectee.selected = doSelect;
                    if (doSelect) {
                        that._trigger("selecting", event, {
                            selecting: selectee.element
                        });
                    } else {
                        that._trigger("unselecting", event, {
                            unselecting: selectee.element
                        });
                    }
                    return false;
                }
            });
        },
        _mouseDrag: function(event) {
            this.dragged = true;
            if (this.options.disabled) {
                return;
            }
            var tmp, that = this, options = this.options, x1 = this.opos[0], y1 = this.opos[1], x2 = event.pageX, y2 = event.pageY;
            if (x1 > x2) {
                tmp = x2;
                x2 = x1;
                x1 = tmp;
            }
            if (y1 > y2) {
                tmp = y2;
                y2 = y1;
                y1 = tmp;
            }
            this.helper.css({
                left: x1,
                top: y1,
                width: x2 - x1,
                height: y2 - y1
            });
            this.selectees.each(function() {
                var selectee = $.data(this, "selectable-item"), hit = false, offset = {};
                if (!selectee || selectee.element === that.element[0]) {
                    return;
                }
                offset.left = selectee.left + that.elementPos.left;
                offset.right = selectee.right + that.elementPos.left;
                offset.top = selectee.top + that.elementPos.top;
                offset.bottom = selectee.bottom + that.elementPos.top;
                if (options.tolerance === "touch") {
                    hit = !(offset.left > x2 || offset.right < x1 || offset.top > y2 || offset.bottom < y1);
                } else if (options.tolerance === "fit") {
                    hit = offset.left > x1 && offset.right < x2 && offset.top > y1 && offset.bottom < y2;
                }
                if (hit) {
                    if (selectee.selected) {
                        that._removeClass(selectee.$element, "ui-selected");
                        selectee.selected = false;
                    }
                    if (selectee.unselecting) {
                        that._removeClass(selectee.$element, "ui-unselecting");
                        selectee.unselecting = false;
                    }
                    if (!selectee.selecting) {
                        that._addClass(selectee.$element, "ui-selecting");
                        selectee.selecting = true;
                        that._trigger("selecting", event, {
                            selecting: selectee.element
                        });
                    }
                } else {
                    if (selectee.selecting) {
                        if ((event.metaKey || event.ctrlKey) && selectee.startselected) {
                            that._removeClass(selectee.$element, "ui-selecting");
                            selectee.selecting = false;
                            that._addClass(selectee.$element, "ui-selected");
                            selectee.selected = true;
                        } else {
                            that._removeClass(selectee.$element, "ui-selecting");
                            selectee.selecting = false;
                            if (selectee.startselected) {
                                that._addClass(selectee.$element, "ui-unselecting");
                                selectee.unselecting = true;
                            }
                            that._trigger("unselecting", event, {
                                unselecting: selectee.element
                            });
                        }
                    }
                    if (selectee.selected) {
                        if (!event.metaKey && !event.ctrlKey && !selectee.startselected) {
                            that._removeClass(selectee.$element, "ui-selected");
                            selectee.selected = false;
                            that._addClass(selectee.$element, "ui-unselecting");
                            selectee.unselecting = true;
                            that._trigger("unselecting", event, {
                                unselecting: selectee.element
                            });
                        }
                    }
                }
            });
            return false;
        },
        _mouseStop: function(event) {
            var that = this;
            this.dragged = false;
            $(".ui-unselecting", this.element[0]).each(function() {
                var selectee = $.data(this, "selectable-item");
                that._removeClass(selectee.$element, "ui-unselecting");
                selectee.unselecting = false;
                selectee.startselected = false;
                that._trigger("unselected", event, {
                    unselected: selectee.element
                });
            });
            $(".ui-selecting", this.element[0]).each(function() {
                var selectee = $.data(this, "selectable-item");
                that._removeClass(selectee.$element, "ui-selecting")._addClass(selectee.$element, "ui-selected");
                selectee.selecting = false;
                selectee.selected = true;
                selectee.startselected = true;
                that._trigger("selected", event, {
                    selected: selectee.element
                });
            });
            this._trigger("stop", event);
            this.helper.remove();
            return false;
        }
    });
    var widgetsSelectmenu = $.widget("ui.selectmenu", [ $.ui.formResetMixin, {
        version: "1.12.1",
        defaultElement: "<select>",
        options: {
            appendTo: null,
            classes: {
                "ui-selectmenu-button-open": "ui-corner-top",
                "ui-selectmenu-button-closed": "ui-corner-all"
            },
            disabled: null,
            icons: {
                button: "ui-icon-triangle-1-s"
            },
            position: {
                my: "left top",
                at: "left bottom",
                collision: "none"
            },
            width: false,
            change: null,
            close: null,
            focus: null,
            open: null,
            select: null
        },
        _create: function() {
            var selectmenuId = this.element.uniqueId().attr("id");
            this.ids = {
                element: selectmenuId,
                button: selectmenuId + "-button",
                menu: selectmenuId + "-menu"
            };
            this._drawButton();
            this._drawMenu();
            this._bindFormResetHandler();
            this._rendered = false;
            this.menuItems = $();
        },
        _drawButton: function() {
            var icon, that = this, item = this._parseOption(this.element.find("option:selected"), this.element[0].selectedIndex);
            this.labels = this.element.labels().attr("for", this.ids.button);
            this._on(this.labels, {
                click: function(event) {
                    this.button.focus();
                    event.preventDefault();
                }
            });
            this.element.hide();
            this.button = $("<span>", {
                tabindex: this.options.disabled ? -1 : 0,
                id: this.ids.button,
                role: "combobox",
                "aria-expanded": "false",
                "aria-autocomplete": "list",
                "aria-owns": this.ids.menu,
                "aria-haspopup": "true",
                title: this.element.attr("title")
            }).insertAfter(this.element);
            this._addClass(this.button, "ui-selectmenu-button ui-selectmenu-button-closed", "ui-button ui-widget");
            icon = $("<span>").appendTo(this.button);
            this._addClass(icon, "ui-selectmenu-icon", "ui-icon " + this.options.icons.button);
            this.buttonItem = this._renderButtonItem(item).appendTo(this.button);
            if (this.options.width !== false) {
                this._resizeButton();
            }
            this._on(this.button, this._buttonEvents);
            this.button.one("focusin", function() {
                if (!that._rendered) {
                    that._refreshMenu();
                }
            });
        },
        _drawMenu: function() {
            var that = this;
            this.menu = $("<ul>", {
                "aria-hidden": "true",
                "aria-labelledby": this.ids.button,
                id: this.ids.menu
            });
            this.menuWrap = $("<div>").append(this.menu);
            this._addClass(this.menuWrap, "ui-selectmenu-menu", "ui-front");
            this.menuWrap.appendTo(this._appendTo());
            this.menuInstance = this.menu.menu({
                classes: {
                    "ui-menu": "ui-corner-bottom"
                },
                role: "listbox",
                select: function(event, ui) {
                    event.preventDefault();
                    that._setSelection();
                    that._select(ui.item.data("ui-selectmenu-item"), event);
                },
                focus: function(event, ui) {
                    var item = ui.item.data("ui-selectmenu-item");
                    if (that.focusIndex != null && item.index !== that.focusIndex) {
                        that._trigger("focus", event, {
                            item: item
                        });
                        if (!that.isOpen) {
                            that._select(item, event);
                        }
                    }
                    that.focusIndex = item.index;
                    that.button.attr("aria-activedescendant", that.menuItems.eq(item.index).attr("id"));
                }
            }).menu("instance");
            this.menuInstance._off(this.menu, "mouseleave");
            this.menuInstance._closeOnDocumentClick = function() {
                return false;
            };
            this.menuInstance._isDivider = function() {
                return false;
            };
        },
        refresh: function() {
            this._refreshMenu();
            this.buttonItem.replaceWith(this.buttonItem = this._renderButtonItem(this._getSelectedItem().data("ui-selectmenu-item") || {}));
            if (this.options.width === null) {
                this._resizeButton();
            }
        },
        _refreshMenu: function() {
            var item, options = this.element.find("option");
            this.menu.empty();
            this._parseOptions(options);
            this._renderMenu(this.menu, this.items);
            this.menuInstance.refresh();
            this.menuItems = this.menu.find("li").not(".ui-selectmenu-optgroup").find(".ui-menu-item-wrapper");
            this._rendered = true;
            if (!options.length) {
                return;
            }
            item = this._getSelectedItem();
            this.menuInstance.focus(null, item);
            this._setAria(item.data("ui-selectmenu-item"));
            this._setOption("disabled", this.element.prop("disabled"));
        },
        open: function(event) {
            if (this.options.disabled) {
                return;
            }
            if (!this._rendered) {
                this._refreshMenu();
            } else {
                this._removeClass(this.menu.find(".ui-state-active"), null, "ui-state-active");
                this.menuInstance.focus(null, this._getSelectedItem());
            }
            if (!this.menuItems.length) {
                return;
            }
            this.isOpen = true;
            this._toggleAttr();
            this._resizeMenu();
            this._position();
            this._on(this.document, this._documentClick);
            this._trigger("open", event);
        },
        _position: function() {
            this.menuWrap.position($.extend({
                of: this.button
            }, this.options.position));
        },
        close: function(event) {
            if (!this.isOpen) {
                return;
            }
            this.isOpen = false;
            this._toggleAttr();
            this.range = null;
            this._off(this.document);
            this._trigger("close", event);
        },
        widget: function() {
            return this.button;
        },
        menuWidget: function() {
            return this.menu;
        },
        _renderButtonItem: function(item) {
            var buttonItem = $("<span>");
            this._setText(buttonItem, item.label);
            this._addClass(buttonItem, "ui-selectmenu-text");
            return buttonItem;
        },
        _renderMenu: function(ul, items) {
            var that = this, currentOptgroup = "";
            $.each(items, function(index, item) {
                var li;
                if (item.optgroup !== currentOptgroup) {
                    li = $("<li>", {
                        text: item.optgroup
                    });
                    that._addClass(li, "ui-selectmenu-optgroup", "ui-menu-divider" + (item.element.parent("optgroup").prop("disabled") ? " ui-state-disabled" : ""));
                    li.appendTo(ul);
                    currentOptgroup = item.optgroup;
                }
                that._renderItemData(ul, item);
            });
        },
        _renderItemData: function(ul, item) {
            return this._renderItem(ul, item).data("ui-selectmenu-item", item);
        },
        _renderItem: function(ul, item) {
            var li = $("<li>"), wrapper = $("<div>", {
                title: item.element.attr("title")
            });
            if (item.disabled) {
                this._addClass(li, null, "ui-state-disabled");
            }
            this._setText(wrapper, item.label);
            return li.append(wrapper).appendTo(ul);
        },
        _setText: function(element, value) {
            if (value) {
                element.text(value);
            } else {
                element.html("&#160;");
            }
        },
        _move: function(direction, event) {
            var item, next, filter = ".ui-menu-item";
            if (this.isOpen) {
                item = this.menuItems.eq(this.focusIndex).parent("li");
            } else {
                item = this.menuItems.eq(this.element[0].selectedIndex).parent("li");
                filter += ":not(.ui-state-disabled)";
            }
            if (direction === "first" || direction === "last") {
                next = item[direction === "first" ? "prevAll" : "nextAll"](filter).eq(-1);
            } else {
                next = item[direction + "All"](filter).eq(0);
            }
            if (next.length) {
                this.menuInstance.focus(event, next);
            }
        },
        _getSelectedItem: function() {
            return this.menuItems.eq(this.element[0].selectedIndex).parent("li");
        },
        _toggle: function(event) {
            this[this.isOpen ? "close" : "open"](event);
        },
        _setSelection: function() {
            var selection;
            if (!this.range) {
                return;
            }
            if (window.getSelection) {
                selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(this.range);
            } else {
                this.range.select();
            }
            this.button.focus();
        },
        _documentClick: {
            mousedown: function(event) {
                if (!this.isOpen) {
                    return;
                }
                if (!$(event.target).closest(".ui-selectmenu-menu, #" + $.ui.escapeSelector(this.ids.button)).length) {
                    this.close(event);
                }
            }
        },
        _buttonEvents: {
            mousedown: function() {
                var selection;
                if (window.getSelection) {
                    selection = window.getSelection();
                    if (selection.rangeCount) {
                        this.range = selection.getRangeAt(0);
                    }
                } else {
                    this.range = document.selection.createRange();
                }
            },
            click: function(event) {
                this._setSelection();
                this._toggle(event);
            },
            keydown: function(event) {
                var preventDefault = true;
                switch (event.keyCode) {
                  case $.ui.keyCode.TAB:
                  case $.ui.keyCode.ESCAPE:
                    this.close(event);
                    preventDefault = false;
                    break;

                  case $.ui.keyCode.ENTER:
                    if (this.isOpen) {
                        this._selectFocusedItem(event);
                    }
                    break;

                  case $.ui.keyCode.UP:
                    if (event.altKey) {
                        this._toggle(event);
                    } else {
                        this._move("prev", event);
                    }
                    break;

                  case $.ui.keyCode.DOWN:
                    if (event.altKey) {
                        this._toggle(event);
                    } else {
                        this._move("next", event);
                    }
                    break;

                  case $.ui.keyCode.SPACE:
                    if (this.isOpen) {
                        this._selectFocusedItem(event);
                    } else {
                        this._toggle(event);
                    }
                    break;

                  case $.ui.keyCode.LEFT:
                    this._move("prev", event);
                    break;

                  case $.ui.keyCode.RIGHT:
                    this._move("next", event);
                    break;

                  case $.ui.keyCode.HOME:
                  case $.ui.keyCode.PAGE_UP:
                    this._move("first", event);
                    break;

                  case $.ui.keyCode.END:
                  case $.ui.keyCode.PAGE_DOWN:
                    this._move("last", event);
                    break;

                  default:
                    this.menu.trigger(event);
                    preventDefault = false;
                }
                if (preventDefault) {
                    event.preventDefault();
                }
            }
        },
        _selectFocusedItem: function(event) {
            var item = this.menuItems.eq(this.focusIndex).parent("li");
            if (!item.hasClass("ui-state-disabled")) {
                this._select(item.data("ui-selectmenu-item"), event);
            }
        },
        _select: function(item, event) {
            var oldIndex = this.element[0].selectedIndex;
            this.element[0].selectedIndex = item.index;
            this.buttonItem.replaceWith(this.buttonItem = this._renderButtonItem(item));
            this._setAria(item);
            this._trigger("select", event, {
                item: item
            });
            if (item.index !== oldIndex) {
                this._trigger("change", event, {
                    item: item
                });
            }
            this.close(event);
        },
        _setAria: function(item) {
            var id = this.menuItems.eq(item.index).attr("id");
            this.button.attr({
                "aria-labelledby": id,
                "aria-activedescendant": id
            });
            this.menu.attr("aria-activedescendant", id);
        },
        _setOption: function(key, value) {
            if (key === "icons") {
                var icon = this.button.find("span.ui-icon");
                this._removeClass(icon, null, this.options.icons.button)._addClass(icon, null, value.button);
            }
            this._super(key, value);
            if (key === "appendTo") {
                this.menuWrap.appendTo(this._appendTo());
            }
            if (key === "width") {
                this._resizeButton();
            }
        },
        _setOptionDisabled: function(value) {
            this._super(value);
            this.menuInstance.option("disabled", value);
            this.button.attr("aria-disabled", value);
            this._toggleClass(this.button, null, "ui-state-disabled", value);
            this.element.prop("disabled", value);
            if (value) {
                this.button.attr("tabindex", -1);
                this.close();
            } else {
                this.button.attr("tabindex", 0);
            }
        },
        _appendTo: function() {
            var element = this.options.appendTo;
            if (element) {
                element = element.jquery || element.nodeType ? $(element) : this.document.find(element).eq(0);
            }
            if (!element || !element[0]) {
                element = this.element.closest(".ui-front, dialog");
            }
            if (!element.length) {
                element = this.document[0].body;
            }
            return element;
        },
        _toggleAttr: function() {
            this.button.attr("aria-expanded", this.isOpen);
            this._removeClass(this.button, "ui-selectmenu-button-" + (this.isOpen ? "closed" : "open"))._addClass(this.button, "ui-selectmenu-button-" + (this.isOpen ? "open" : "closed"))._toggleClass(this.menuWrap, "ui-selectmenu-open", null, this.isOpen);
            this.menu.attr("aria-hidden", !this.isOpen);
        },
        _resizeButton: function() {
            var width = this.options.width;
            if (width === false) {
                this.button.css("width", "");
                return;
            }
            if (width === null) {
                width = this.element.show().outerWidth();
                this.element.hide();
            }
            this.button.outerWidth(width);
        },
        _resizeMenu: function() {
            this.menu.outerWidth(Math.max(this.button.outerWidth(), this.menu.width("").outerWidth() + 1));
        },
        _getCreateOptions: function() {
            var options = this._super();
            options.disabled = this.element.prop("disabled");
            return options;
        },
        _parseOptions: function(options) {
            var that = this, data = [];
            options.each(function(index, item) {
                data.push(that._parseOption($(item), index));
            });
            this.items = data;
        },
        _parseOption: function(option, index) {
            var optgroup = option.parent("optgroup");
            return {
                element: option,
                index: index,
                value: option.val(),
                label: option.text(),
                optgroup: optgroup.attr("label") || "",
                disabled: optgroup.prop("disabled") || option.prop("disabled")
            };
        },
        _destroy: function() {
            this._unbindFormResetHandler();
            this.menuWrap.remove();
            this.button.remove();
            this.element.show();
            this.element.removeUniqueId();
            this.labels.attr("for", this.ids.element);
        }
    } ]);
    var widgetsSlider = $.widget("ui.slider", $.ui.mouse, {
        version: "1.12.1",
        widgetEventPrefix: "slide",
        options: {
            animate: false,
            classes: {
                "ui-slider": "ui-corner-all",
                "ui-slider-handle": "ui-corner-all",
                "ui-slider-range": "ui-corner-all ui-widget-header"
            },
            distance: 0,
            max: 100,
            min: 0,
            orientation: "horizontal",
            range: false,
            step: 1,
            value: 0,
            values: null,
            change: null,
            slide: null,
            start: null,
            stop: null
        },
        numPages: 5,
        _create: function() {
            this._keySliding = false;
            this._mouseSliding = false;
            this._animateOff = true;
            this._handleIndex = null;
            this._detectOrientation();
            this._mouseInit();
            this._calculateNewMax();
            this._addClass("ui-slider ui-slider-" + this.orientation, "ui-widget ui-widget-content");
            this._refresh();
            this._animateOff = false;
        },
        _refresh: function() {
            this._createRange();
            this._createHandles();
            this._setupEvents();
            this._refreshValue();
        },
        _createHandles: function() {
            var i, handleCount, options = this.options, existingHandles = this.element.find(".ui-slider-handle"), handle = "<span tabindex='0'></span>", handles = [];
            handleCount = options.values && options.values.length || 1;
            if (existingHandles.length > handleCount) {
                existingHandles.slice(handleCount).remove();
                existingHandles = existingHandles.slice(0, handleCount);
            }
            for (i = existingHandles.length; i < handleCount; i++) {
                handles.push(handle);
            }
            this.handles = existingHandles.add($(handles.join("")).appendTo(this.element));
            this._addClass(this.handles, "ui-slider-handle", "ui-state-default");
            this.handle = this.handles.eq(0);
            this.handles.each(function(i) {
                $(this).data("ui-slider-handle-index", i).attr("tabIndex", 0);
            });
        },
        _createRange: function() {
            var options = this.options;
            if (options.range) {
                if (options.range === true) {
                    if (!options.values) {
                        options.values = [ this._valueMin(), this._valueMin() ];
                    } else if (options.values.length && options.values.length !== 2) {
                        options.values = [ options.values[0], options.values[0] ];
                    } else if ($.isArray(options.values)) {
                        options.values = options.values.slice(0);
                    }
                }
                if (!this.range || !this.range.length) {
                    this.range = $("<div>").appendTo(this.element);
                    this._addClass(this.range, "ui-slider-range");
                } else {
                    this._removeClass(this.range, "ui-slider-range-min ui-slider-range-max");
                    this.range.css({
                        left: "",
                        bottom: ""
                    });
                }
                if (options.range === "min" || options.range === "max") {
                    this._addClass(this.range, "ui-slider-range-" + options.range);
                }
            } else {
                if (this.range) {
                    this.range.remove();
                }
                this.range = null;
            }
        },
        _setupEvents: function() {
            this._off(this.handles);
            this._on(this.handles, this._handleEvents);
            this._hoverable(this.handles);
            this._focusable(this.handles);
        },
        _destroy: function() {
            this.handles.remove();
            if (this.range) {
                this.range.remove();
            }
            this._mouseDestroy();
        },
        _mouseCapture: function(event) {
            var position, normValue, distance, closestHandle, index, allowed, offset, mouseOverHandle, that = this, o = this.options;
            if (o.disabled) {
                return false;
            }
            this.elementSize = {
                width: this.element.outerWidth(),
                height: this.element.outerHeight()
            };
            this.elementOffset = this.element.offset();
            position = {
                x: event.pageX,
                y: event.pageY
            };
            normValue = this._normValueFromMouse(position);
            distance = this._valueMax() - this._valueMin() + 1;
            this.handles.each(function(i) {
                var thisDistance = Math.abs(normValue - that.values(i));
                if (distance > thisDistance || distance === thisDistance && (i === that._lastChangedValue || that.values(i) === o.min)) {
                    distance = thisDistance;
                    closestHandle = $(this);
                    index = i;
                }
            });
            allowed = this._start(event, index);
            if (allowed === false) {
                return false;
            }
            this._mouseSliding = true;
            this._handleIndex = index;
            this._addClass(closestHandle, null, "ui-state-active");
            closestHandle.trigger("focus");
            offset = closestHandle.offset();
            mouseOverHandle = !$(event.target).parents().addBack().is(".ui-slider-handle");
            this._clickOffset = mouseOverHandle ? {
                left: 0,
                top: 0
            } : {
                left: event.pageX - offset.left - closestHandle.width() / 2,
                top: event.pageY - offset.top - closestHandle.height() / 2 - (parseInt(closestHandle.css("borderTopWidth"), 10) || 0) - (parseInt(closestHandle.css("borderBottomWidth"), 10) || 0) + (parseInt(closestHandle.css("marginTop"), 10) || 0)
            };
            if (!this.handles.hasClass("ui-state-hover")) {
                this._slide(event, index, normValue);
            }
            this._animateOff = true;
            return true;
        },
        _mouseStart: function() {
            return true;
        },
        _mouseDrag: function(event) {
            var position = {
                x: event.pageX,
                y: event.pageY
            }, normValue = this._normValueFromMouse(position);
            this._slide(event, this._handleIndex, normValue);
            return false;
        },
        _mouseStop: function(event) {
            this._removeClass(this.handles, null, "ui-state-active");
            this._mouseSliding = false;
            this._stop(event, this._handleIndex);
            this._change(event, this._handleIndex);
            this._handleIndex = null;
            this._clickOffset = null;
            this._animateOff = false;
            return false;
        },
        _detectOrientation: function() {
            this.orientation = this.options.orientation === "vertical" ? "vertical" : "horizontal";
        },
        _normValueFromMouse: function(position) {
            var pixelTotal, pixelMouse, percentMouse, valueTotal, valueMouse;
            if (this.orientation === "horizontal") {
                pixelTotal = this.elementSize.width;
                pixelMouse = position.x - this.elementOffset.left - (this._clickOffset ? this._clickOffset.left : 0);
            } else {
                pixelTotal = this.elementSize.height;
                pixelMouse = position.y - this.elementOffset.top - (this._clickOffset ? this._clickOffset.top : 0);
            }
            percentMouse = pixelMouse / pixelTotal;
            if (percentMouse > 1) {
                percentMouse = 1;
            }
            if (percentMouse < 0) {
                percentMouse = 0;
            }
            if (this.orientation === "vertical") {
                percentMouse = 1 - percentMouse;
            }
            valueTotal = this._valueMax() - this._valueMin();
            valueMouse = this._valueMin() + percentMouse * valueTotal;
            return this._trimAlignValue(valueMouse);
        },
        _uiHash: function(index, value, values) {
            var uiHash = {
                handle: this.handles[index],
                handleIndex: index,
                value: value !== undefined ? value : this.value()
            };
            if (this._hasMultipleValues()) {
                uiHash.value = value !== undefined ? value : this.values(index);
                uiHash.values = values || this.values();
            }
            return uiHash;
        },
        _hasMultipleValues: function() {
            return this.options.values && this.options.values.length;
        },
        _start: function(event, index) {
            return this._trigger("start", event, this._uiHash(index));
        },
        _slide: function(event, index, newVal) {
            var allowed, otherVal, currentValue = this.value(), newValues = this.values();
            if (this._hasMultipleValues()) {
                otherVal = this.values(index ? 0 : 1);
                currentValue = this.values(index);
                if (this.options.values.length === 2 && this.options.range === true) {
                    newVal = index === 0 ? Math.min(otherVal, newVal) : Math.max(otherVal, newVal);
                }
                newValues[index] = newVal;
            }
            if (newVal === currentValue) {
                return;
            }
            allowed = this._trigger("slide", event, this._uiHash(index, newVal, newValues));
            if (allowed === false) {
                return;
            }
            if (this._hasMultipleValues()) {
                this.values(index, newVal);
            } else {
                this.value(newVal);
            }
        },
        _stop: function(event, index) {
            this._trigger("stop", event, this._uiHash(index));
        },
        _change: function(event, index) {
            if (!this._keySliding && !this._mouseSliding) {
                this._lastChangedValue = index;
                this._trigger("change", event, this._uiHash(index));
            }
        },
        value: function(newValue) {
            if (arguments.length) {
                this.options.value = this._trimAlignValue(newValue);
                this._refreshValue();
                this._change(null, 0);
                return;
            }
            return this._value();
        },
        values: function(index, newValue) {
            var vals, newValues, i;
            if (arguments.length > 1) {
                this.options.values[index] = this._trimAlignValue(newValue);
                this._refreshValue();
                this._change(null, index);
                return;
            }
            if (arguments.length) {
                if ($.isArray(arguments[0])) {
                    vals = this.options.values;
                    newValues = arguments[0];
                    for (i = 0; i < vals.length; i += 1) {
                        vals[i] = this._trimAlignValue(newValues[i]);
                        this._change(null, i);
                    }
                    this._refreshValue();
                } else {
                    if (this._hasMultipleValues()) {
                        return this._values(index);
                    } else {
                        return this.value();
                    }
                }
            } else {
                return this._values();
            }
        },
        _setOption: function(key, value) {
            var i, valsLength = 0;
            if (key === "range" && this.options.range === true) {
                if (value === "min") {
                    this.options.value = this._values(0);
                    this.options.values = null;
                } else if (value === "max") {
                    this.options.value = this._values(this.options.values.length - 1);
                    this.options.values = null;
                }
            }
            if ($.isArray(this.options.values)) {
                valsLength = this.options.values.length;
            }
            this._super(key, value);
            switch (key) {
              case "orientation":
                this._detectOrientation();
                this._removeClass("ui-slider-horizontal ui-slider-vertical")._addClass("ui-slider-" + this.orientation);
                this._refreshValue();
                if (this.options.range) {
                    this._refreshRange(value);
                }
                this.handles.css(value === "horizontal" ? "bottom" : "left", "");
                break;

              case "value":
                this._animateOff = true;
                this._refreshValue();
                this._change(null, 0);
                this._animateOff = false;
                break;

              case "values":
                this._animateOff = true;
                this._refreshValue();
                for (i = valsLength - 1; i >= 0; i--) {
                    this._change(null, i);
                }
                this._animateOff = false;
                break;

              case "step":
              case "min":
              case "max":
                this._animateOff = true;
                this._calculateNewMax();
                this._refreshValue();
                this._animateOff = false;
                break;

              case "range":
                this._animateOff = true;
                this._refresh();
                this._animateOff = false;
                break;
            }
        },
        _setOptionDisabled: function(value) {
            this._super(value);
            this._toggleClass(null, "ui-state-disabled", !!value);
        },
        _value: function() {
            var val = this.options.value;
            val = this._trimAlignValue(val);
            return val;
        },
        _values: function(index) {
            var val, vals, i;
            if (arguments.length) {
                val = this.options.values[index];
                val = this._trimAlignValue(val);
                return val;
            } else if (this._hasMultipleValues()) {
                vals = this.options.values.slice();
                for (i = 0; i < vals.length; i += 1) {
                    vals[i] = this._trimAlignValue(vals[i]);
                }
                return vals;
            } else {
                return [];
            }
        },
        _trimAlignValue: function(val) {
            if (val <= this._valueMin()) {
                return this._valueMin();
            }
            if (val >= this._valueMax()) {
                return this._valueMax();
            }
            var step = this.options.step > 0 ? this.options.step : 1, valModStep = (val - this._valueMin()) % step, alignValue = val - valModStep;
            if (Math.abs(valModStep) * 2 >= step) {
                alignValue += valModStep > 0 ? step : -step;
            }
            return parseFloat(alignValue.toFixed(5));
        },
        _calculateNewMax: function() {
            var max = this.options.max, min = this._valueMin(), step = this.options.step, aboveMin = Math.round((max - min) / step) * step;
            max = aboveMin + min;
            if (max > this.options.max) {
                max -= step;
            }
            this.max = parseFloat(max.toFixed(this._precision()));
        },
        _precision: function() {
            var precision = this._precisionOf(this.options.step);
            if (this.options.min !== null) {
                precision = Math.max(precision, this._precisionOf(this.options.min));
            }
            return precision;
        },
        _precisionOf: function(num) {
            var str = num.toString(), decimal = str.indexOf(".");
            return decimal === -1 ? 0 : str.length - decimal - 1;
        },
        _valueMin: function() {
            return this.options.min;
        },
        _valueMax: function() {
            return this.max;
        },
        _refreshRange: function(orientation) {
            if (orientation === "vertical") {
                this.range.css({
                    width: "",
                    left: ""
                });
            }
            if (orientation === "horizontal") {
                this.range.css({
                    height: "",
                    bottom: ""
                });
            }
        },
        _refreshValue: function() {
            var lastValPercent, valPercent, value, valueMin, valueMax, oRange = this.options.range, o = this.options, that = this, animate = !this._animateOff ? o.animate : false, _set = {};
            if (this._hasMultipleValues()) {
                this.handles.each(function(i) {
                    valPercent = (that.values(i) - that._valueMin()) / (that._valueMax() - that._valueMin()) * 100;
                    _set[that.orientation === "horizontal" ? "left" : "bottom"] = valPercent + "%";
                    $(this).stop(1, 1)[animate ? "animate" : "css"](_set, o.animate);
                    if (that.options.range === true) {
                        if (that.orientation === "horizontal") {
                            if (i === 0) {
                                that.range.stop(1, 1)[animate ? "animate" : "css"]({
                                    left: valPercent + "%"
                                }, o.animate);
                            }
                            if (i === 1) {
                                that.range[animate ? "animate" : "css"]({
                                    width: valPercent - lastValPercent + "%"
                                }, {
                                    queue: false,
                                    duration: o.animate
                                });
                            }
                        } else {
                            if (i === 0) {
                                that.range.stop(1, 1)[animate ? "animate" : "css"]({
                                    bottom: valPercent + "%"
                                }, o.animate);
                            }
                            if (i === 1) {
                                that.range[animate ? "animate" : "css"]({
                                    height: valPercent - lastValPercent + "%"
                                }, {
                                    queue: false,
                                    duration: o.animate
                                });
                            }
                        }
                    }
                    lastValPercent = valPercent;
                });
            } else {
                value = this.value();
                valueMin = this._valueMin();
                valueMax = this._valueMax();
                valPercent = valueMax !== valueMin ? (value - valueMin) / (valueMax - valueMin) * 100 : 0;
                _set[this.orientation === "horizontal" ? "left" : "bottom"] = valPercent + "%";
                this.handle.stop(1, 1)[animate ? "animate" : "css"](_set, o.animate);
                if (oRange === "min" && this.orientation === "horizontal") {
                    this.range.stop(1, 1)[animate ? "animate" : "css"]({
                        width: valPercent + "%"
                    }, o.animate);
                }
                if (oRange === "max" && this.orientation === "horizontal") {
                    this.range.stop(1, 1)[animate ? "animate" : "css"]({
                        width: 100 - valPercent + "%"
                    }, o.animate);
                }
                if (oRange === "min" && this.orientation === "vertical") {
                    this.range.stop(1, 1)[animate ? "animate" : "css"]({
                        height: valPercent + "%"
                    }, o.animate);
                }
                if (oRange === "max" && this.orientation === "vertical") {
                    this.range.stop(1, 1)[animate ? "animate" : "css"]({
                        height: 100 - valPercent + "%"
                    }, o.animate);
                }
            }
        },
        _handleEvents: {
            keydown: function(event) {
                var allowed, curVal, newVal, step, index = $(event.target).data("ui-slider-handle-index");
                switch (event.keyCode) {
                  case $.ui.keyCode.HOME:
                  case $.ui.keyCode.END:
                  case $.ui.keyCode.PAGE_UP:
                  case $.ui.keyCode.PAGE_DOWN:
                  case $.ui.keyCode.UP:
                  case $.ui.keyCode.RIGHT:
                  case $.ui.keyCode.DOWN:
                  case $.ui.keyCode.LEFT:
                    event.preventDefault();
                    if (!this._keySliding) {
                        this._keySliding = true;
                        this._addClass($(event.target), null, "ui-state-active");
                        allowed = this._start(event, index);
                        if (allowed === false) {
                            return;
                        }
                    }
                    break;
                }
                step = this.options.step;
                if (this._hasMultipleValues()) {
                    curVal = newVal = this.values(index);
                } else {
                    curVal = newVal = this.value();
                }
                switch (event.keyCode) {
                  case $.ui.keyCode.HOME:
                    newVal = this._valueMin();
                    break;

                  case $.ui.keyCode.END:
                    newVal = this._valueMax();
                    break;

                  case $.ui.keyCode.PAGE_UP:
                    newVal = this._trimAlignValue(curVal + (this._valueMax() - this._valueMin()) / this.numPages);
                    break;

                  case $.ui.keyCode.PAGE_DOWN:
                    newVal = this._trimAlignValue(curVal - (this._valueMax() - this._valueMin()) / this.numPages);
                    break;

                  case $.ui.keyCode.UP:
                  case $.ui.keyCode.RIGHT:
                    if (curVal === this._valueMax()) {
                        return;
                    }
                    newVal = this._trimAlignValue(curVal + step);
                    break;

                  case $.ui.keyCode.DOWN:
                  case $.ui.keyCode.LEFT:
                    if (curVal === this._valueMin()) {
                        return;
                    }
                    newVal = this._trimAlignValue(curVal - step);
                    break;
                }
                this._slide(event, index, newVal);
            },
            keyup: function(event) {
                var index = $(event.target).data("ui-slider-handle-index");
                if (this._keySliding) {
                    this._keySliding = false;
                    this._stop(event, index);
                    this._change(event, index);
                    this._removeClass($(event.target), null, "ui-state-active");
                }
            }
        }
    });
    var widgetsSortable = $.widget("ui.sortable", $.ui.mouse, {
        version: "1.12.1",
        widgetEventPrefix: "sort",
        ready: false,
        options: {
            appendTo: "parent",
            axis: false,
            connectWith: false,
            containment: false,
            cursor: "auto",
            cursorAt: false,
            dropOnEmpty: true,
            forcePlaceholderSize: false,
            forceHelperSize: false,
            grid: false,
            handle: false,
            helper: "original",
            items: "> *",
            opacity: false,
            placeholder: false,
            revert: false,
            scroll: true,
            scrollSensitivity: 20,
            scrollSpeed: 20,
            scope: "default",
            tolerance: "intersect",
            zIndex: 1e3,
            activate: null,
            beforeStop: null,
            change: null,
            deactivate: null,
            out: null,
            over: null,
            receive: null,
            remove: null,
            sort: null,
            start: null,
            stop: null,
            update: null
        },
        _isOverAxis: function(x, reference, size) {
            return x >= reference && x < reference + size;
        },
        _isFloating: function(item) {
            return /left|right/.test(item.css("float")) || /inline|table-cell/.test(item.css("display"));
        },
        _create: function() {
            this.containerCache = {};
            this._addClass("ui-sortable");
            this.refresh();
            this.offset = this.element.offset();
            this._mouseInit();
            this._setHandleClassName();
            this.ready = true;
        },
        _setOption: function(key, value) {
            this._super(key, value);
            if (key === "handle") {
                this._setHandleClassName();
            }
        },
        _setHandleClassName: function() {
            var that = this;
            this._removeClass(this.element.find(".ui-sortable-handle"), "ui-sortable-handle");
            $.each(this.items, function() {
                that._addClass(this.instance.options.handle ? this.item.find(this.instance.options.handle) : this.item, "ui-sortable-handle");
            });
        },
        _destroy: function() {
            this._mouseDestroy();
            for (var i = this.items.length - 1; i >= 0; i--) {
                this.items[i].item.removeData(this.widgetName + "-item");
            }
            return this;
        },
        _mouseCapture: function(event, overrideHandle) {
            var currentItem = null, validHandle = false, that = this;
            if (this.reverting) {
                return false;
            }
            if (this.options.disabled || this.options.type === "static") {
                return false;
            }
            this._refreshItems(event);
            $(event.target).parents().each(function() {
                if ($.data(this, that.widgetName + "-item") === that) {
                    currentItem = $(this);
                    return false;
                }
            });
            if ($.data(event.target, that.widgetName + "-item") === that) {
                currentItem = $(event.target);
            }
            if (!currentItem) {
                return false;
            }
            if (this.options.handle && !overrideHandle) {
                $(this.options.handle, currentItem).find("*").addBack().each(function() {
                    if (this === event.target) {
                        validHandle = true;
                    }
                });
                if (!validHandle) {
                    return false;
                }
            }
            this.currentItem = currentItem;
            this._removeCurrentsFromItems();
            return true;
        },
        _mouseStart: function(event, overrideHandle, noActivation) {
            var i, body, o = this.options;
            this.currentContainer = this;
            this.refreshPositions();
            this.helper = this._createHelper(event);
            this._cacheHelperProportions();
            this._cacheMargins();
            this.scrollParent = this.helper.scrollParent();
            this.offset = this.currentItem.offset();
            this.offset = {
                top: this.offset.top - this.margins.top,
                left: this.offset.left - this.margins.left
            };
            $.extend(this.offset, {
                click: {
                    left: event.pageX - this.offset.left,
                    top: event.pageY - this.offset.top
                },
                parent: this._getParentOffset(),
                relative: this._getRelativeOffset()
            });
            this.helper.css("position", "absolute");
            this.cssPosition = this.helper.css("position");
            this.originalPosition = this._generatePosition(event);
            this.originalPageX = event.pageX;
            this.originalPageY = event.pageY;
            o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt);
            this.domPosition = {
                prev: this.currentItem.prev()[0],
                parent: this.currentItem.parent()[0]
            };
            if (this.helper[0] !== this.currentItem[0]) {
                this.currentItem.hide();
            }
            this._createPlaceholder();
            if (o.containment) {
                this._setContainment();
            }
            if (o.cursor && o.cursor !== "auto") {
                body = this.document.find("body");
                this.storedCursor = body.css("cursor");
                body.css("cursor", o.cursor);
                this.storedStylesheet = $("<style>*{ cursor: " + o.cursor + " !important; }</style>").appendTo(body);
            }
            if (o.opacity) {
                if (this.helper.css("opacity")) {
                    this._storedOpacity = this.helper.css("opacity");
                }
                this.helper.css("opacity", o.opacity);
            }
            if (o.zIndex) {
                if (this.helper.css("zIndex")) {
                    this._storedZIndex = this.helper.css("zIndex");
                }
                this.helper.css("zIndex", o.zIndex);
            }
            if (this.scrollParent[0] !== this.document[0] && this.scrollParent[0].tagName !== "HTML") {
                this.overflowOffset = this.scrollParent.offset();
            }
            this._trigger("start", event, this._uiHash());
            if (!this._preserveHelperProportions) {
                this._cacheHelperProportions();
            }
            if (!noActivation) {
                for (i = this.containers.length - 1; i >= 0; i--) {
                    this.containers[i]._trigger("activate", event, this._uiHash(this));
                }
            }
            if ($.ui.ddmanager) {
                $.ui.ddmanager.current = this;
            }
            if ($.ui.ddmanager && !o.dropBehaviour) {
                $.ui.ddmanager.prepareOffsets(this, event);
            }
            this.dragging = true;
            this._addClass(this.helper, "ui-sortable-helper");
            this._mouseDrag(event);
            return true;
        },
        _mouseDrag: function(event) {
            var i, item, itemElement, intersection, o = this.options, scrolled = false;
            this.position = this._generatePosition(event);
            this.positionAbs = this._convertPositionTo("absolute");
            if (!this.lastPositionAbs) {
                this.lastPositionAbs = this.positionAbs;
            }
            if (this.options.scroll) {
                if (this.scrollParent[0] !== this.document[0] && this.scrollParent[0].tagName !== "HTML") {
                    if (this.overflowOffset.top + this.scrollParent[0].offsetHeight - event.pageY < o.scrollSensitivity) {
                        this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;
                    } else if (event.pageY - this.overflowOffset.top < o.scrollSensitivity) {
                        this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;
                    }
                    if (this.overflowOffset.left + this.scrollParent[0].offsetWidth - event.pageX < o.scrollSensitivity) {
                        this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;
                    } else if (event.pageX - this.overflowOffset.left < o.scrollSensitivity) {
                        this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;
                    }
                } else {
                    if (event.pageY - this.document.scrollTop() < o.scrollSensitivity) {
                        scrolled = this.document.scrollTop(this.document.scrollTop() - o.scrollSpeed);
                    } else if (this.window.height() - (event.pageY - this.document.scrollTop()) < o.scrollSensitivity) {
                        scrolled = this.document.scrollTop(this.document.scrollTop() + o.scrollSpeed);
                    }
                    if (event.pageX - this.document.scrollLeft() < o.scrollSensitivity) {
                        scrolled = this.document.scrollLeft(this.document.scrollLeft() - o.scrollSpeed);
                    } else if (this.window.width() - (event.pageX - this.document.scrollLeft()) < o.scrollSensitivity) {
                        scrolled = this.document.scrollLeft(this.document.scrollLeft() + o.scrollSpeed);
                    }
                }
                if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
                    $.ui.ddmanager.prepareOffsets(this, event);
                }
            }
            this.positionAbs = this._convertPositionTo("absolute");
            if (!this.options.axis || this.options.axis !== "y") {
                this.helper[0].style.left = this.position.left + "px";
            }
            if (!this.options.axis || this.options.axis !== "x") {
                this.helper[0].style.top = this.position.top + "px";
            }
            for (i = this.items.length - 1; i >= 0; i--) {
                item = this.items[i];
                itemElement = item.item[0];
                intersection = this._intersectsWithPointer(item);
                if (!intersection) {
                    continue;
                }
                if (item.instance !== this.currentContainer) {
                    continue;
                }
                if (itemElement !== this.currentItem[0] && this.placeholder[intersection === 1 ? "next" : "prev"]()[0] !== itemElement && !$.contains(this.placeholder[0], itemElement) && (this.options.type === "semi-dynamic" ? !$.contains(this.element[0], itemElement) : true)) {
                    this.direction = intersection === 1 ? "down" : "up";
                    if (this.options.tolerance === "pointer" || this._intersectsWithSides(item)) {
                        this._rearrange(event, item);
                    } else {
                        break;
                    }
                    this._trigger("change", event, this._uiHash());
                    break;
                }
            }
            this._contactContainers(event);
            if ($.ui.ddmanager) {
                $.ui.ddmanager.drag(this, event);
            }
            this._trigger("sort", event, this._uiHash());
            this.lastPositionAbs = this.positionAbs;
            return false;
        },
        _mouseStop: function(event, noPropagation) {
            if (!event) {
                return;
            }
            if ($.ui.ddmanager && !this.options.dropBehaviour) {
                $.ui.ddmanager.drop(this, event);
            }
            if (this.options.revert) {
                var that = this, cur = this.placeholder.offset(), axis = this.options.axis, animation = {};
                if (!axis || axis === "x") {
                    animation.left = cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollLeft);
                }
                if (!axis || axis === "y") {
                    animation.top = cur.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollTop);
                }
                this.reverting = true;
                $(this.helper).animate(animation, parseInt(this.options.revert, 10) || 500, function() {
                    that._clear(event);
                });
            } else {
                this._clear(event, noPropagation);
            }
            return false;
        },
        cancel: function() {
            if (this.dragging) {
                this._mouseUp(new $.Event("mouseup", {
                    target: null
                }));
                if (this.options.helper === "original") {
                    this.currentItem.css(this._storedCSS);
                    this._removeClass(this.currentItem, "ui-sortable-helper");
                } else {
                    this.currentItem.show();
                }
                for (var i = this.containers.length - 1; i >= 0; i--) {
                    this.containers[i]._trigger("deactivate", null, this._uiHash(this));
                    if (this.containers[i].containerCache.over) {
                        this.containers[i]._trigger("out", null, this._uiHash(this));
                        this.containers[i].containerCache.over = 0;
                    }
                }
            }
            if (this.placeholder) {
                if (this.placeholder[0].parentNode) {
                    this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
                }
                if (this.options.helper !== "original" && this.helper && this.helper[0].parentNode) {
                    this.helper.remove();
                }
                $.extend(this, {
                    helper: null,
                    dragging: false,
                    reverting: false,
                    _noFinalSort: null
                });
                if (this.domPosition.prev) {
                    $(this.domPosition.prev).after(this.currentItem);
                } else {
                    $(this.domPosition.parent).prepend(this.currentItem);
                }
            }
            return this;
        },
        serialize: function(o) {
            var items = this._getItemsAsjQuery(o && o.connected), str = [];
            o = o || {};
            $(items).each(function() {
                var res = ($(o.item || this).attr(o.attribute || "id") || "").match(o.expression || /(.+)[\-=_](.+)/);
                if (res) {
                    str.push((o.key || res[1] + "[]") + "=" + (o.key && o.expression ? res[1] : res[2]));
                }
            });
            if (!str.length && o.key) {
                str.push(o.key + "=");
            }
            return str.join("&");
        },
        toArray: function(o) {
            var items = this._getItemsAsjQuery(o && o.connected), ret = [];
            o = o || {};
            items.each(function() {
                ret.push($(o.item || this).attr(o.attribute || "id") || "");
            });
            return ret;
        },
        _intersectsWith: function(item) {
            var x1 = this.positionAbs.left, x2 = x1 + this.helperProportions.width, y1 = this.positionAbs.top, y2 = y1 + this.helperProportions.height, l = item.left, r = l + item.width, t = item.top, b = t + item.height, dyClick = this.offset.click.top, dxClick = this.offset.click.left, isOverElementHeight = this.options.axis === "x" || y1 + dyClick > t && y1 + dyClick < b, isOverElementWidth = this.options.axis === "y" || x1 + dxClick > l && x1 + dxClick < r, isOverElement = isOverElementHeight && isOverElementWidth;
            if (this.options.tolerance === "pointer" || this.options.forcePointerForContainers || this.options.tolerance !== "pointer" && this.helperProportions[this.floating ? "width" : "height"] > item[this.floating ? "width" : "height"]) {
                return isOverElement;
            } else {
                return l < x1 + this.helperProportions.width / 2 && x2 - this.helperProportions.width / 2 < r && t < y1 + this.helperProportions.height / 2 && y2 - this.helperProportions.height / 2 < b;
            }
        },
        _intersectsWithPointer: function(item) {
            var verticalDirection, horizontalDirection, isOverElementHeight = this.options.axis === "x" || this._isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height), isOverElementWidth = this.options.axis === "y" || this._isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width), isOverElement = isOverElementHeight && isOverElementWidth;
            if (!isOverElement) {
                return false;
            }
            verticalDirection = this._getDragVerticalDirection();
            horizontalDirection = this._getDragHorizontalDirection();
            return this.floating ? horizontalDirection === "right" || verticalDirection === "down" ? 2 : 1 : verticalDirection && (verticalDirection === "down" ? 2 : 1);
        },
        _intersectsWithSides: function(item) {
            var isOverBottomHalf = this._isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + item.height / 2, item.height), isOverRightHalf = this._isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + item.width / 2, item.width), verticalDirection = this._getDragVerticalDirection(), horizontalDirection = this._getDragHorizontalDirection();
            if (this.floating && horizontalDirection) {
                return horizontalDirection === "right" && isOverRightHalf || horizontalDirection === "left" && !isOverRightHalf;
            } else {
                return verticalDirection && (verticalDirection === "down" && isOverBottomHalf || verticalDirection === "up" && !isOverBottomHalf);
            }
        },
        _getDragVerticalDirection: function() {
            var delta = this.positionAbs.top - this.lastPositionAbs.top;
            return delta !== 0 && (delta > 0 ? "down" : "up");
        },
        _getDragHorizontalDirection: function() {
            var delta = this.positionAbs.left - this.lastPositionAbs.left;
            return delta !== 0 && (delta > 0 ? "right" : "left");
        },
        refresh: function(event) {
            this._refreshItems(event);
            this._setHandleClassName();
            this.refreshPositions();
            return this;
        },
        _connectWith: function() {
            var options = this.options;
            return options.connectWith.constructor === String ? [ options.connectWith ] : options.connectWith;
        },
        _getItemsAsjQuery: function(connected) {
            var i, j, cur, inst, items = [], queries = [], connectWith = this._connectWith();
            if (connectWith && connected) {
                for (i = connectWith.length - 1; i >= 0; i--) {
                    cur = $(connectWith[i], this.document[0]);
                    for (j = cur.length - 1; j >= 0; j--) {
                        inst = $.data(cur[j], this.widgetFullName);
                        if (inst && inst !== this && !inst.options.disabled) {
                            queries.push([ $.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), inst ]);
                        }
                    }
                }
            }
            queries.push([ $.isFunction(this.options.items) ? this.options.items.call(this.element, null, {
                options: this.options,
                item: this.currentItem
            }) : $(this.options.items, this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), this ]);
            function addItems() {
                items.push(this);
            }
            for (i = queries.length - 1; i >= 0; i--) {
                queries[i][0].each(addItems);
            }
            return $(items);
        },
        _removeCurrentsFromItems: function() {
            var list = this.currentItem.find(":data(" + this.widgetName + "-item)");
            this.items = $.grep(this.items, function(item) {
                for (var j = 0; j < list.length; j++) {
                    if (list[j] === item.item[0]) {
                        return false;
                    }
                }
                return true;
            });
        },
        _refreshItems: function(event) {
            this.items = [];
            this.containers = [ this ];
            var i, j, cur, inst, targetData, _queries, item, queriesLength, items = this.items, queries = [ [ $.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, {
                item: this.currentItem
            }) : $(this.options.items, this.element), this ] ], connectWith = this._connectWith();
            if (connectWith && this.ready) {
                for (i = connectWith.length - 1; i >= 0; i--) {
                    cur = $(connectWith[i], this.document[0]);
                    for (j = cur.length - 1; j >= 0; j--) {
                        inst = $.data(cur[j], this.widgetFullName);
                        if (inst && inst !== this && !inst.options.disabled) {
                            queries.push([ $.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, {
                                item: this.currentItem
                            }) : $(inst.options.items, inst.element), inst ]);
                            this.containers.push(inst);
                        }
                    }
                }
            }
            for (i = queries.length - 1; i >= 0; i--) {
                targetData = queries[i][1];
                _queries = queries[i][0];
                for (j = 0, queriesLength = _queries.length; j < queriesLength; j++) {
                    item = $(_queries[j]);
                    item.data(this.widgetName + "-item", targetData);
                    items.push({
                        item: item,
                        instance: targetData,
                        width: 0,
                        height: 0,
                        left: 0,
                        top: 0
                    });
                }
            }
        },
        refreshPositions: function(fast) {
            this.floating = this.items.length ? this.options.axis === "x" || this._isFloating(this.items[0].item) : false;
            if (this.offsetParent && this.helper) {
                this.offset.parent = this._getParentOffset();
            }
            var i, item, t, p;
            for (i = this.items.length - 1; i >= 0; i--) {
                item = this.items[i];
                if (item.instance !== this.currentContainer && this.currentContainer && item.item[0] !== this.currentItem[0]) {
                    continue;
                }
                t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;
                if (!fast) {
                    item.width = t.outerWidth();
                    item.height = t.outerHeight();
                }
                p = t.offset();
                item.left = p.left;
                item.top = p.top;
            }
            if (this.options.custom && this.options.custom.refreshContainers) {
                this.options.custom.refreshContainers.call(this);
            } else {
                for (i = this.containers.length - 1; i >= 0; i--) {
                    p = this.containers[i].element.offset();
                    this.containers[i].containerCache.left = p.left;
                    this.containers[i].containerCache.top = p.top;
                    this.containers[i].containerCache.width = this.containers[i].element.outerWidth();
                    this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
                }
            }
            return this;
        },
        _createPlaceholder: function(that) {
            that = that || this;
            var className, o = that.options;
            if (!o.placeholder || o.placeholder.constructor === String) {
                className = o.placeholder;
                o.placeholder = {
                    element: function() {
                        var nodeName = that.currentItem[0].nodeName.toLowerCase(), element = $("<" + nodeName + ">", that.document[0]);
                        that._addClass(element, "ui-sortable-placeholder", className || that.currentItem[0].className)._removeClass(element, "ui-sortable-helper");
                        if (nodeName === "tbody") {
                            that._createTrPlaceholder(that.currentItem.find("tr").eq(0), $("<tr>", that.document[0]).appendTo(element));
                        } else if (nodeName === "tr") {
                            that._createTrPlaceholder(that.currentItem, element);
                        } else if (nodeName === "img") {
                            element.attr("src", that.currentItem.attr("src"));
                        }
                        if (!className) {
                            element.css("visibility", "hidden");
                        }
                        return element;
                    },
                    update: function(container, p) {
                        if (className && !o.forcePlaceholderSize) {
                            return;
                        }
                        if (!p.height()) {
                            p.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css("paddingTop") || 0, 10) - parseInt(that.currentItem.css("paddingBottom") || 0, 10));
                        }
                        if (!p.width()) {
                            p.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css("paddingLeft") || 0, 10) - parseInt(that.currentItem.css("paddingRight") || 0, 10));
                        }
                    }
                };
            }
            that.placeholder = $(o.placeholder.element.call(that.element, that.currentItem));
            that.currentItem.after(that.placeholder);
            o.placeholder.update(that, that.placeholder);
        },
        _createTrPlaceholder: function(sourceTr, targetTr) {
            var that = this;
            sourceTr.children().each(function() {
                $("<td>&#160;</td>", that.document[0]).attr("colspan", $(this).attr("colspan") || 1).appendTo(targetTr);
            });
        },
        _contactContainers: function(event) {
            var i, j, dist, itemWithLeastDistance, posProperty, sizeProperty, cur, nearBottom, floating, axis, innermostContainer = null, innermostIndex = null;
            for (i = this.containers.length - 1; i >= 0; i--) {
                if ($.contains(this.currentItem[0], this.containers[i].element[0])) {
                    continue;
                }
                if (this._intersectsWith(this.containers[i].containerCache)) {
                    if (innermostContainer && $.contains(this.containers[i].element[0], innermostContainer.element[0])) {
                        continue;
                    }
                    innermostContainer = this.containers[i];
                    innermostIndex = i;
                } else {
                    if (this.containers[i].containerCache.over) {
                        this.containers[i]._trigger("out", event, this._uiHash(this));
                        this.containers[i].containerCache.over = 0;
                    }
                }
            }
            if (!innermostContainer) {
                return;
            }
            if (this.containers.length === 1) {
                if (!this.containers[innermostIndex].containerCache.over) {
                    this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
                    this.containers[innermostIndex].containerCache.over = 1;
                }
            } else {
                dist = 1e4;
                itemWithLeastDistance = null;
                floating = innermostContainer.floating || this._isFloating(this.currentItem);
                posProperty = floating ? "left" : "top";
                sizeProperty = floating ? "width" : "height";
                axis = floating ? "pageX" : "pageY";
                for (j = this.items.length - 1; j >= 0; j--) {
                    if (!$.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) {
                        continue;
                    }
                    if (this.items[j].item[0] === this.currentItem[0]) {
                        continue;
                    }
                    cur = this.items[j].item.offset()[posProperty];
                    nearBottom = false;
                    if (event[axis] - cur > this.items[j][sizeProperty] / 2) {
                        nearBottom = true;
                    }
                    if (Math.abs(event[axis] - cur) < dist) {
                        dist = Math.abs(event[axis] - cur);
                        itemWithLeastDistance = this.items[j];
                        this.direction = nearBottom ? "up" : "down";
                    }
                }
                if (!itemWithLeastDistance && !this.options.dropOnEmpty) {
                    return;
                }
                if (this.currentContainer === this.containers[innermostIndex]) {
                    if (!this.currentContainer.containerCache.over) {
                        this.containers[innermostIndex]._trigger("over", event, this._uiHash());
                        this.currentContainer.containerCache.over = 1;
                    }
                    return;
                }
                itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);
                this._trigger("change", event, this._uiHash());
                this.containers[innermostIndex]._trigger("change", event, this._uiHash(this));
                this.currentContainer = this.containers[innermostIndex];
                this.options.placeholder.update(this.currentContainer, this.placeholder);
                this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
                this.containers[innermostIndex].containerCache.over = 1;
            }
        },
        _createHelper: function(event) {
            var o = this.options, helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [ event, this.currentItem ])) : o.helper === "clone" ? this.currentItem.clone() : this.currentItem;
            if (!helper.parents("body").length) {
                $(o.appendTo !== "parent" ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);
            }
            if (helper[0] === this.currentItem[0]) {
                this._storedCSS = {
                    width: this.currentItem[0].style.width,
                    height: this.currentItem[0].style.height,
                    position: this.currentItem.css("position"),
                    top: this.currentItem.css("top"),
                    left: this.currentItem.css("left")
                };
            }
            if (!helper[0].style.width || o.forceHelperSize) {
                helper.width(this.currentItem.width());
            }
            if (!helper[0].style.height || o.forceHelperSize) {
                helper.height(this.currentItem.height());
            }
            return helper;
        },
        _adjustOffsetFromHelper: function(obj) {
            if (typeof obj === "string") {
                obj = obj.split(" ");
            }
            if ($.isArray(obj)) {
                obj = {
                    left: +obj[0],
                    top: +obj[1] || 0
                };
            }
            if ("left" in obj) {
                this.offset.click.left = obj.left + this.margins.left;
            }
            if ("right" in obj) {
                this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
            }
            if ("top" in obj) {
                this.offset.click.top = obj.top + this.margins.top;
            }
            if ("bottom" in obj) {
                this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
            }
        },
        _getParentOffset: function() {
            this.offsetParent = this.helper.offsetParent();
            var po = this.offsetParent.offset();
            if (this.cssPosition === "absolute" && this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) {
                po.left += this.scrollParent.scrollLeft();
                po.top += this.scrollParent.scrollTop();
            }
            if (this.offsetParent[0] === this.document[0].body || this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === "html" && $.ui.ie) {
                po = {
                    top: 0,
                    left: 0
                };
            }
            return {
                top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
                left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
            };
        },
        _getRelativeOffset: function() {
            if (this.cssPosition === "relative") {
                var p = this.currentItem.position();
                return {
                    top: p.top - (parseInt(this.helper.css("top"), 10) || 0) + this.scrollParent.scrollTop(),
                    left: p.left - (parseInt(this.helper.css("left"), 10) || 0) + this.scrollParent.scrollLeft()
                };
            } else {
                return {
                    top: 0,
                    left: 0
                };
            }
        },
        _cacheMargins: function() {
            this.margins = {
                left: parseInt(this.currentItem.css("marginLeft"), 10) || 0,
                top: parseInt(this.currentItem.css("marginTop"), 10) || 0
            };
        },
        _cacheHelperProportions: function() {
            this.helperProportions = {
                width: this.helper.outerWidth(),
                height: this.helper.outerHeight()
            };
        },
        _setContainment: function() {
            var ce, co, over, o = this.options;
            if (o.containment === "parent") {
                o.containment = this.helper[0].parentNode;
            }
            if (o.containment === "document" || o.containment === "window") {
                this.containment = [ 0 - this.offset.relative.left - this.offset.parent.left, 0 - this.offset.relative.top - this.offset.parent.top, o.containment === "document" ? this.document.width() : this.window.width() - this.helperProportions.width - this.margins.left, (o.containment === "document" ? this.document.height() || document.body.parentNode.scrollHeight : this.window.height() || this.document[0].body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top ];
            }
            if (!/^(document|window|parent)$/.test(o.containment)) {
                ce = $(o.containment)[0];
                co = $(o.containment).offset();
                over = $(ce).css("overflow") !== "hidden";
                this.containment = [ co.left + (parseInt($(ce).css("borderLeftWidth"), 10) || 0) + (parseInt($(ce).css("paddingLeft"), 10) || 0) - this.margins.left, co.top + (parseInt($(ce).css("borderTopWidth"), 10) || 0) + (parseInt($(ce).css("paddingTop"), 10) || 0) - this.margins.top, co.left + (over ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"), 10) || 0) - (parseInt($(ce).css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left, co.top + (over ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"), 10) || 0) - (parseInt($(ce).css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top ];
            }
        },
        _convertPositionTo: function(d, pos) {
            if (!pos) {
                pos = this.position;
            }
            var mod = d === "absolute" ? 1 : -1, scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = /(html|body)/i.test(scroll[0].tagName);
            return {
                top: pos.top + this.offset.relative.top * mod + this.offset.parent.top * mod - (this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : scrollIsRootNode ? 0 : scroll.scrollTop()) * mod,
                left: pos.left + this.offset.relative.left * mod + this.offset.parent.left * mod - (this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft()) * mod
            };
        },
        _generatePosition: function(event) {
            var top, left, o = this.options, pageX = event.pageX, pageY = event.pageY, scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = /(html|body)/i.test(scroll[0].tagName);
            if (this.cssPosition === "relative" && !(this.scrollParent[0] !== this.document[0] && this.scrollParent[0] !== this.offsetParent[0])) {
                this.offset.relative = this._getRelativeOffset();
            }
            if (this.originalPosition) {
                if (this.containment) {
                    if (event.pageX - this.offset.click.left < this.containment[0]) {
                        pageX = this.containment[0] + this.offset.click.left;
                    }
                    if (event.pageY - this.offset.click.top < this.containment[1]) {
                        pageY = this.containment[1] + this.offset.click.top;
                    }
                    if (event.pageX - this.offset.click.left > this.containment[2]) {
                        pageX = this.containment[2] + this.offset.click.left;
                    }
                    if (event.pageY - this.offset.click.top > this.containment[3]) {
                        pageY = this.containment[3] + this.offset.click.top;
                    }
                }
                if (o.grid) {
                    top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];
                    pageY = this.containment ? top - this.offset.click.top >= this.containment[1] && top - this.offset.click.top <= this.containment[3] ? top : top - this.offset.click.top >= this.containment[1] ? top - o.grid[1] : top + o.grid[1] : top;
                    left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];
                    pageX = this.containment ? left - this.offset.click.left >= this.containment[0] && left - this.offset.click.left <= this.containment[2] ? left : left - this.offset.click.left >= this.containment[0] ? left - o.grid[0] : left + o.grid[0] : left;
                }
            }
            return {
                top: pageY - this.offset.click.top - this.offset.relative.top - this.offset.parent.top + (this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : scrollIsRootNode ? 0 : scroll.scrollTop()),
                left: pageX - this.offset.click.left - this.offset.relative.left - this.offset.parent.left + (this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft())
            };
        },
        _rearrange: function(event, i, a, hardRefresh) {
            a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], this.direction === "down" ? i.item[0] : i.item[0].nextSibling);
            this.counter = this.counter ? ++this.counter : 1;
            var counter = this.counter;
            this._delay(function() {
                if (counter === this.counter) {
                    this.refreshPositions(!hardRefresh);
                }
            });
        },
        _clear: function(event, noPropagation) {
            this.reverting = false;
            var i, delayedTriggers = [];
            if (!this._noFinalSort && this.currentItem.parent().length) {
                this.placeholder.before(this.currentItem);
            }
            this._noFinalSort = null;
            if (this.helper[0] === this.currentItem[0]) {
                for (i in this._storedCSS) {
                    if (this._storedCSS[i] === "auto" || this._storedCSS[i] === "static") {
                        this._storedCSS[i] = "";
                    }
                }
                this.currentItem.css(this._storedCSS);
                this._removeClass(this.currentItem, "ui-sortable-helper");
            } else {
                this.currentItem.show();
            }
            if (this.fromOutside && !noPropagation) {
                delayedTriggers.push(function(event) {
                    this._trigger("receive", event, this._uiHash(this.fromOutside));
                });
            }
            if ((this.fromOutside || this.domPosition.prev !== this.currentItem.prev().not(".ui-sortable-helper")[0] || this.domPosition.parent !== this.currentItem.parent()[0]) && !noPropagation) {
                delayedTriggers.push(function(event) {
                    this._trigger("update", event, this._uiHash());
                });
            }
            if (this !== this.currentContainer) {
                if (!noPropagation) {
                    delayedTriggers.push(function(event) {
                        this._trigger("remove", event, this._uiHash());
                    });
                    delayedTriggers.push(function(c) {
                        return function(event) {
                            c._trigger("receive", event, this._uiHash(this));
                        };
                    }.call(this, this.currentContainer));
                    delayedTriggers.push(function(c) {
                        return function(event) {
                            c._trigger("update", event, this._uiHash(this));
                        };
                    }.call(this, this.currentContainer));
                }
            }
            function delayEvent(type, instance, container) {
                return function(event) {
                    container._trigger(type, event, instance._uiHash(instance));
                };
            }
            for (i = this.containers.length - 1; i >= 0; i--) {
                if (!noPropagation) {
                    delayedTriggers.push(delayEvent("deactivate", this, this.containers[i]));
                }
                if (this.containers[i].containerCache.over) {
                    delayedTriggers.push(delayEvent("out", this, this.containers[i]));
                    this.containers[i].containerCache.over = 0;
                }
            }
            if (this.storedCursor) {
                this.document.find("body").css("cursor", this.storedCursor);
                this.storedStylesheet.remove();
            }
            if (this._storedOpacity) {
                this.helper.css("opacity", this._storedOpacity);
            }
            if (this._storedZIndex) {
                this.helper.css("zIndex", this._storedZIndex === "auto" ? "" : this._storedZIndex);
            }
            this.dragging = false;
            if (!noPropagation) {
                this._trigger("beforeStop", event, this._uiHash());
            }
            this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
            if (!this.cancelHelperRemoval) {
                if (this.helper[0] !== this.currentItem[0]) {
                    this.helper.remove();
                }
                this.helper = null;
            }
            if (!noPropagation) {
                for (i = 0; i < delayedTriggers.length; i++) {
                    delayedTriggers[i].call(this, event);
                }
                this._trigger("stop", event, this._uiHash());
            }
            this.fromOutside = false;
            return !this.cancelHelperRemoval;
        },
        _trigger: function() {
            if ($.Widget.prototype._trigger.apply(this, arguments) === false) {
                this.cancel();
            }
        },
        _uiHash: function(_inst) {
            var inst = _inst || this;
            return {
                helper: inst.helper,
                placeholder: inst.placeholder || $([]),
                position: inst.position,
                originalPosition: inst.originalPosition,
                offset: inst.positionAbs,
                item: inst.currentItem,
                sender: _inst ? _inst.element : null
            };
        }
    });
    function spinnerModifer(fn) {
        return function() {
            var previous = this.element.val();
            fn.apply(this, arguments);
            this._refresh();
            if (previous !== this.element.val()) {
                this._trigger("change");
            }
        };
    }
    $.widget("ui.spinner", {
        version: "1.12.1",
        defaultElement: "<input>",
        widgetEventPrefix: "spin",
        options: {
            classes: {
                "ui-spinner": "ui-corner-all",
                "ui-spinner-down": "ui-corner-br",
                "ui-spinner-up": "ui-corner-tr"
            },
            culture: null,
            icons: {
                down: "ui-icon-triangle-1-s",
                up: "ui-icon-triangle-1-n"
            },
            incremental: true,
            max: null,
            min: null,
            numberFormat: null,
            page: 10,
            step: 1,
            change: null,
            spin: null,
            start: null,
            stop: null
        },
        _create: function() {
            this._setOption("max", this.options.max);
            this._setOption("min", this.options.min);
            this._setOption("step", this.options.step);
            if (this.value() !== "") {
                this._value(this.element.val(), true);
            }
            this._draw();
            this._on(this._events);
            this._refresh();
            this._on(this.window, {
                beforeunload: function() {
                    this.element.removeAttr("autocomplete");
                }
            });
        },
        _getCreateOptions: function() {
            var options = this._super();
            var element = this.element;
            $.each([ "min", "max", "step" ], function(i, option) {
                var value = element.attr(option);
                if (value != null && value.length) {
                    options[option] = value;
                }
            });
            return options;
        },
        _events: {
            keydown: function(event) {
                if (this._start(event) && this._keydown(event)) {
                    event.preventDefault();
                }
            },
            keyup: "_stop",
            focus: function() {
                this.previous = this.element.val();
            },
            blur: function(event) {
                if (this.cancelBlur) {
                    delete this.cancelBlur;
                    return;
                }
                this._stop();
                this._refresh();
                if (this.previous !== this.element.val()) {
                    this._trigger("change", event);
                }
            },
            mousewheel: function(event, delta) {
                if (!delta) {
                    return;
                }
                if (!this.spinning && !this._start(event)) {
                    return false;
                }
                this._spin((delta > 0 ? 1 : -1) * this.options.step, event);
                clearTimeout(this.mousewheelTimer);
                this.mousewheelTimer = this._delay(function() {
                    if (this.spinning) {
                        this._stop(event);
                    }
                }, 100);
                event.preventDefault();
            },
            "mousedown .ui-spinner-button": function(event) {
                var previous;
                previous = this.element[0] === $.ui.safeActiveElement(this.document[0]) ? this.previous : this.element.val();
                function checkFocus() {
                    var isActive = this.element[0] === $.ui.safeActiveElement(this.document[0]);
                    if (!isActive) {
                        this.element.trigger("focus");
                        this.previous = previous;
                        this._delay(function() {
                            this.previous = previous;
                        });
                    }
                }
                event.preventDefault();
                checkFocus.call(this);
                this.cancelBlur = true;
                this._delay(function() {
                    delete this.cancelBlur;
                    checkFocus.call(this);
                });
                if (this._start(event) === false) {
                    return;
                }
                this._repeat(null, $(event.currentTarget).hasClass("ui-spinner-up") ? 1 : -1, event);
            },
            "mouseup .ui-spinner-button": "_stop",
            "mouseenter .ui-spinner-button": function(event) {
                if (!$(event.currentTarget).hasClass("ui-state-active")) {
                    return;
                }
                if (this._start(event) === false) {
                    return false;
                }
                this._repeat(null, $(event.currentTarget).hasClass("ui-spinner-up") ? 1 : -1, event);
            },
            "mouseleave .ui-spinner-button": "_stop"
        },
        _enhance: function() {
            this.uiSpinner = this.element.attr("autocomplete", "off").wrap("<span>").parent().append("<a></a><a></a>");
        },
        _draw: function() {
            this._enhance();
            this._addClass(this.uiSpinner, "ui-spinner", "ui-widget ui-widget-content");
            this._addClass("ui-spinner-input");
            this.element.attr("role", "spinbutton");
            this.buttons = this.uiSpinner.children("a").attr("tabIndex", -1).attr("aria-hidden", true).button({
                classes: {
                    "ui-button": ""
                }
            });
            this._removeClass(this.buttons, "ui-corner-all");
            this._addClass(this.buttons.first(), "ui-spinner-button ui-spinner-up");
            this._addClass(this.buttons.last(), "ui-spinner-button ui-spinner-down");
            this.buttons.first().button({
                icon: this.options.icons.up,
                showLabel: false
            });
            this.buttons.last().button({
                icon: this.options.icons.down,
                showLabel: false
            });
            if (this.buttons.height() > Math.ceil(this.uiSpinner.height() * .5) && this.uiSpinner.height() > 0) {
                this.uiSpinner.height(this.uiSpinner.height());
            }
        },
        _keydown: function(event) {
            var options = this.options, keyCode = $.ui.keyCode;
            switch (event.keyCode) {
              case keyCode.UP:
                this._repeat(null, 1, event);
                return true;

              case keyCode.DOWN:
                this._repeat(null, -1, event);
                return true;

              case keyCode.PAGE_UP:
                this._repeat(null, options.page, event);
                return true;

              case keyCode.PAGE_DOWN:
                this._repeat(null, -options.page, event);
                return true;
            }
            return false;
        },
        _start: function(event) {
            if (!this.spinning && this._trigger("start", event) === false) {
                return false;
            }
            if (!this.counter) {
                this.counter = 1;
            }
            this.spinning = true;
            return true;
        },
        _repeat: function(i, steps, event) {
            i = i || 500;
            clearTimeout(this.timer);
            this.timer = this._delay(function() {
                this._repeat(40, steps, event);
            }, i);
            this._spin(steps * this.options.step, event);
        },
        _spin: function(step, event) {
            var value = this.value() || 0;
            if (!this.counter) {
                this.counter = 1;
            }
            value = this._adjustValue(value + step * this._increment(this.counter));
            if (!this.spinning || this._trigger("spin", event, {
                value: value
            }) !== false) {
                this._value(value);
                this.counter++;
            }
        },
        _increment: function(i) {
            var incremental = this.options.incremental;
            if (incremental) {
                return $.isFunction(incremental) ? incremental(i) : Math.floor(i * i * i / 5e4 - i * i / 500 + 17 * i / 200 + 1);
            }
            return 1;
        },
        _precision: function() {
            var precision = this._precisionOf(this.options.step);
            if (this.options.min !== null) {
                precision = Math.max(precision, this._precisionOf(this.options.min));
            }
            return precision;
        },
        _precisionOf: function(num) {
            var str = num.toString(), decimal = str.indexOf(".");
            return decimal === -1 ? 0 : str.length - decimal - 1;
        },
        _adjustValue: function(value) {
            var base, aboveMin, options = this.options;
            base = options.min !== null ? options.min : 0;
            aboveMin = value - base;
            aboveMin = Math.round(aboveMin / options.step) * options.step;
            value = base + aboveMin;
            value = parseFloat(value.toFixed(this._precision()));
            if (options.max !== null && value > options.max) {
                return options.max;
            }
            if (options.min !== null && value < options.min) {
                return options.min;
            }
            return value;
        },
        _stop: function(event) {
            if (!this.spinning) {
                return;
            }
            clearTimeout(this.timer);
            clearTimeout(this.mousewheelTimer);
            this.counter = 0;
            this.spinning = false;
            this._trigger("stop", event);
        },
        _setOption: function(key, value) {
            var prevValue, first, last;
            if (key === "culture" || key === "numberFormat") {
                prevValue = this._parse(this.element.val());
                this.options[key] = value;
                this.element.val(this._format(prevValue));
                return;
            }
            if (key === "max" || key === "min" || key === "step") {
                if (typeof value === "string") {
                    value = this._parse(value);
                }
            }
            if (key === "icons") {
                first = this.buttons.first().find(".ui-icon");
                this._removeClass(first, null, this.options.icons.up);
                this._addClass(first, null, value.up);
                last = this.buttons.last().find(".ui-icon");
                this._removeClass(last, null, this.options.icons.down);
                this._addClass(last, null, value.down);
            }
            this._super(key, value);
        },
        _setOptionDisabled: function(value) {
            this._super(value);
            this._toggleClass(this.uiSpinner, null, "ui-state-disabled", !!value);
            this.element.prop("disabled", !!value);
            this.buttons.button(value ? "disable" : "enable");
        },
        _setOptions: spinnerModifer(function(options) {
            this._super(options);
        }),
        _parse: function(val) {
            if (typeof val === "string" && val !== "") {
                val = window.Globalize && this.options.numberFormat ? Globalize.parseFloat(val, 10, this.options.culture) : +val;
            }
            return val === "" || isNaN(val) ? null : val;
        },
        _format: function(value) {
            if (value === "") {
                return "";
            }
            return window.Globalize && this.options.numberFormat ? Globalize.format(value, this.options.numberFormat, this.options.culture) : value;
        },
        _refresh: function() {
            this.element.attr({
                "aria-valuemin": this.options.min,
                "aria-valuemax": this.options.max,
                "aria-valuenow": this._parse(this.element.val())
            });
        },
        isValid: function() {
            var value = this.value();
            if (value === null) {
                return false;
            }
            return value === this._adjustValue(value);
        },
        _value: function(value, allowAny) {
            var parsed;
            if (value !== "") {
                parsed = this._parse(value);
                if (parsed !== null) {
                    if (!allowAny) {
                        parsed = this._adjustValue(parsed);
                    }
                    value = this._format(parsed);
                }
            }
            this.element.val(value);
            this._refresh();
        },
        _destroy: function() {
            this.element.prop("disabled", false).removeAttr("autocomplete role aria-valuemin aria-valuemax aria-valuenow");
            this.uiSpinner.replaceWith(this.element);
        },
        stepUp: spinnerModifer(function(steps) {
            this._stepUp(steps);
        }),
        _stepUp: function(steps) {
            if (this._start()) {
                this._spin((steps || 1) * this.options.step);
                this._stop();
            }
        },
        stepDown: spinnerModifer(function(steps) {
            this._stepDown(steps);
        }),
        _stepDown: function(steps) {
            if (this._start()) {
                this._spin((steps || 1) * -this.options.step);
                this._stop();
            }
        },
        pageUp: spinnerModifer(function(pages) {
            this._stepUp((pages || 1) * this.options.page);
        }),
        pageDown: spinnerModifer(function(pages) {
            this._stepDown((pages || 1) * this.options.page);
        }),
        value: function(newVal) {
            if (!arguments.length) {
                return this._parse(this.element.val());
            }
            spinnerModifer(this._value).call(this, newVal);
        },
        widget: function() {
            return this.uiSpinner;
        }
    });
    if ($.uiBackCompat !== false) {
        $.widget("ui.spinner", $.ui.spinner, {
            _enhance: function() {
                this.uiSpinner = this.element.attr("autocomplete", "off").wrap(this._uiSpinnerHtml()).parent().append(this._buttonHtml());
            },
            _uiSpinnerHtml: function() {
                return "<span>";
            },
            _buttonHtml: function() {
                return "<a></a><a></a>";
            }
        });
    }
    var widgetsSpinner = $.ui.spinner;
    $.widget("ui.tabs", {
        version: "1.12.1",
        delay: 300,
        options: {
            active: null,
            classes: {
                "ui-tabs": "ui-corner-all",
                "ui-tabs-nav": "ui-corner-all",
                "ui-tabs-panel": "ui-corner-bottom",
                "ui-tabs-tab": "ui-corner-top"
            },
            collapsible: false,
            event: "click",
            heightStyle: "content",
            hide: null,
            show: null,
            activate: null,
            beforeActivate: null,
            beforeLoad: null,
            load: null
        },
        _isLocal: function() {
            var rhash = /#.*$/;
            return function(anchor) {
                var anchorUrl, locationUrl;
                anchorUrl = anchor.href.replace(rhash, "");
                locationUrl = location.href.replace(rhash, "");
                try {
                    anchorUrl = decodeURIComponent(anchorUrl);
                } catch (error) {}
                try {
                    locationUrl = decodeURIComponent(locationUrl);
                } catch (error) {}
                return anchor.hash.length > 1 && anchorUrl === locationUrl;
            };
        }(),
        _create: function() {
            var that = this, options = this.options;
            this.running = false;
            this._addClass("ui-tabs", "ui-widget ui-widget-content");
            this._toggleClass("ui-tabs-collapsible", null, options.collapsible);
            this._processTabs();
            options.active = this._initialActive();
            if ($.isArray(options.disabled)) {
                options.disabled = $.unique(options.disabled.concat($.map(this.tabs.filter(".ui-state-disabled"), function(li) {
                    return that.tabs.index(li);
                }))).sort();
            }
            if (this.options.active !== false && this.anchors.length) {
                this.active = this._findActive(options.active);
            } else {
                this.active = $();
            }
            this._refresh();
            if (this.active.length) {
                this.load(options.active);
            }
        },
        _initialActive: function() {
            var active = this.options.active, collapsible = this.options.collapsible, locationHash = location.hash.substring(1);
            if (active === null) {
                if (locationHash) {
                    this.tabs.each(function(i, tab) {
                        if ($(tab).attr("aria-controls") === locationHash) {
                            active = i;
                            return false;
                        }
                    });
                }
                if (active === null) {
                    active = this.tabs.index(this.tabs.filter(".ui-tabs-active"));
                }
                if (active === null || active === -1) {
                    active = this.tabs.length ? 0 : false;
                }
            }
            if (active !== false) {
                active = this.tabs.index(this.tabs.eq(active));
                if (active === -1) {
                    active = collapsible ? false : 0;
                }
            }
            if (!collapsible && active === false && this.anchors.length) {
                active = 0;
            }
            return active;
        },
        _getCreateEventData: function() {
            return {
                tab: this.active,
                panel: !this.active.length ? $() : this._getPanelForTab(this.active)
            };
        },
        _tabKeydown: function(event) {
            var focusedTab = $($.ui.safeActiveElement(this.document[0])).closest("li"), selectedIndex = this.tabs.index(focusedTab), goingForward = true;
            if (this._handlePageNav(event)) {
                return;
            }
            switch (event.keyCode) {
              case $.ui.keyCode.RIGHT:
              case $.ui.keyCode.DOWN:
                selectedIndex++;
                break;

              case $.ui.keyCode.UP:
              case $.ui.keyCode.LEFT:
                goingForward = false;
                selectedIndex--;
                break;

              case $.ui.keyCode.END:
                selectedIndex = this.anchors.length - 1;
                break;

              case $.ui.keyCode.HOME:
                selectedIndex = 0;
                break;

              case $.ui.keyCode.SPACE:
                event.preventDefault();
                clearTimeout(this.activating);
                this._activate(selectedIndex);
                return;

              case $.ui.keyCode.ENTER:
                event.preventDefault();
                clearTimeout(this.activating);
                this._activate(selectedIndex === this.options.active ? false : selectedIndex);
                return;

              default:
                return;
            }
            event.preventDefault();
            clearTimeout(this.activating);
            selectedIndex = this._focusNextTab(selectedIndex, goingForward);
            if (!event.ctrlKey && !event.metaKey) {
                focusedTab.attr("aria-selected", "false");
                this.tabs.eq(selectedIndex).attr("aria-selected", "true");
                this.activating = this._delay(function() {
                    this.option("active", selectedIndex);
                }, this.delay);
            }
        },
        _panelKeydown: function(event) {
            if (this._handlePageNav(event)) {
                return;
            }
            if (event.ctrlKey && event.keyCode === $.ui.keyCode.UP) {
                event.preventDefault();
                this.active.trigger("focus");
            }
        },
        _handlePageNav: function(event) {
            if (event.altKey && event.keyCode === $.ui.keyCode.PAGE_UP) {
                this._activate(this._focusNextTab(this.options.active - 1, false));
                return true;
            }
            if (event.altKey && event.keyCode === $.ui.keyCode.PAGE_DOWN) {
                this._activate(this._focusNextTab(this.options.active + 1, true));
                return true;
            }
        },
        _findNextTab: function(index, goingForward) {
            var lastTabIndex = this.tabs.length - 1;
            function constrain() {
                if (index > lastTabIndex) {
                    index = 0;
                }
                if (index < 0) {
                    index = lastTabIndex;
                }
                return index;
            }
            while ($.inArray(constrain(), this.options.disabled) !== -1) {
                index = goingForward ? index + 1 : index - 1;
            }
            return index;
        },
        _focusNextTab: function(index, goingForward) {
            index = this._findNextTab(index, goingForward);
            this.tabs.eq(index).trigger("focus");
            return index;
        },
        _setOption: function(key, value) {
            if (key === "active") {
                this._activate(value);
                return;
            }
            this._super(key, value);
            if (key === "collapsible") {
                this._toggleClass("ui-tabs-collapsible", null, value);
                if (!value && this.options.active === false) {
                    this._activate(0);
                }
            }
            if (key === "event") {
                this._setupEvents(value);
            }
            if (key === "heightStyle") {
                this._setupHeightStyle(value);
            }
        },
        _sanitizeSelector: function(hash) {
            return hash ? hash.replace(/[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&") : "";
        },
        refresh: function() {
            var options = this.options, lis = this.tablist.children(":has(a[href])");
            options.disabled = $.map(lis.filter(".ui-state-disabled"), function(tab) {
                return lis.index(tab);
            });
            this._processTabs();
            if (options.active === false || !this.anchors.length) {
                options.active = false;
                this.active = $();
            } else if (this.active.length && !$.contains(this.tablist[0], this.active[0])) {
                if (this.tabs.length === options.disabled.length) {
                    options.active = false;
                    this.active = $();
                } else {
                    this._activate(this._findNextTab(Math.max(0, options.active - 1), false));
                }
            } else {
                options.active = this.tabs.index(this.active);
            }
            this._refresh();
        },
        _refresh: function() {
            this._setOptionDisabled(this.options.disabled);
            this._setupEvents(this.options.event);
            this._setupHeightStyle(this.options.heightStyle);
            this.tabs.not(this.active).attr({
                "aria-selected": "false",
                "aria-expanded": "false",
                tabIndex: -1
            });
            this.panels.not(this._getPanelForTab(this.active)).hide().attr({
                "aria-hidden": "true"
            });
            if (!this.active.length) {
                this.tabs.eq(0).attr("tabIndex", 0);
            } else {
                this.active.attr({
                    "aria-selected": "true",
                    "aria-expanded": "true",
                    tabIndex: 0
                });
                this._addClass(this.active, "ui-tabs-active", "ui-state-active");
                this._getPanelForTab(this.active).show().attr({
                    "aria-hidden": "false"
                });
            }
        },
        _processTabs: function() {
            var that = this, prevTabs = this.tabs, prevAnchors = this.anchors, prevPanels = this.panels;
            this.tablist = this._getList().attr("role", "tablist");
            this._addClass(this.tablist, "ui-tabs-nav", "ui-helper-reset ui-helper-clearfix ui-widget-header");
            this.tablist.on("mousedown" + this.eventNamespace, "> li", function(event) {
                if ($(this).is(".ui-state-disabled")) {
                    event.preventDefault();
                }
            }).on("focus" + this.eventNamespace, ".ui-tabs-anchor", function() {
                if ($(this).closest("li").is(".ui-state-disabled")) {
                    this.blur();
                }
            });
            this.tabs = this.tablist.find("> li:has(a[href])").attr({
                role: "tab",
                tabIndex: -1
            });
            this._addClass(this.tabs, "ui-tabs-tab", "ui-state-default");
            this.anchors = this.tabs.map(function() {
                return $("a", this)[0];
            }).attr({
                role: "presentation",
                tabIndex: -1
            });
            this._addClass(this.anchors, "ui-tabs-anchor");
            this.panels = $();
            this.anchors.each(function(i, anchor) {
                var selector, panel, panelId, anchorId = $(anchor).uniqueId().attr("id"), tab = $(anchor).closest("li"), originalAriaControls = tab.attr("aria-controls");
                if (that._isLocal(anchor)) {
                    selector = anchor.hash;
                    panelId = selector.substring(1);
                    panel = that.element.find(that._sanitizeSelector(selector));
                } else {
                    panelId = tab.attr("aria-controls") || $({}).uniqueId()[0].id;
                    selector = "#" + panelId;
                    panel = that.element.find(selector);
                    if (!panel.length) {
                        panel = that._createPanel(panelId);
                        panel.insertAfter(that.panels[i - 1] || that.tablist);
                    }
                    panel.attr("aria-live", "polite");
                }
                if (panel.length) {
                    that.panels = that.panels.add(panel);
                }
                if (originalAriaControls) {
                    tab.data("ui-tabs-aria-controls", originalAriaControls);
                }
                tab.attr({
                    "aria-controls": panelId,
                    "aria-labelledby": anchorId
                });
                panel.attr("aria-labelledby", anchorId);
            });
            this.panels.attr("role", "tabpanel");
            this._addClass(this.panels, "ui-tabs-panel", "ui-widget-content");
            if (prevTabs) {
                this._off(prevTabs.not(this.tabs));
                this._off(prevAnchors.not(this.anchors));
                this._off(prevPanels.not(this.panels));
            }
        },
        _getList: function() {
            return this.tablist || this.element.find("ol, ul").eq(0);
        },
        _createPanel: function(id) {
            return $("<div>").attr("id", id).data("ui-tabs-destroy", true);
        },
        _setOptionDisabled: function(disabled) {
            var currentItem, li, i;
            if ($.isArray(disabled)) {
                if (!disabled.length) {
                    disabled = false;
                } else if (disabled.length === this.anchors.length) {
                    disabled = true;
                }
            }
            for (i = 0; li = this.tabs[i]; i++) {
                currentItem = $(li);
                if (disabled === true || $.inArray(i, disabled) !== -1) {
                    currentItem.attr("aria-disabled", "true");
                    this._addClass(currentItem, null, "ui-state-disabled");
                } else {
                    currentItem.removeAttr("aria-disabled");
                    this._removeClass(currentItem, null, "ui-state-disabled");
                }
            }
            this.options.disabled = disabled;
            this._toggleClass(this.widget(), this.widgetFullName + "-disabled", null, disabled === true);
        },
        _setupEvents: function(event) {
            var events = {};
            if (event) {
                $.each(event.split(" "), function(index, eventName) {
                    events[eventName] = "_eventHandler";
                });
            }
            this._off(this.anchors.add(this.tabs).add(this.panels));
            this._on(true, this.anchors, {
                click: function(event) {
                    event.preventDefault();
                }
            });
            this._on(this.anchors, events);
            this._on(this.tabs, {
                keydown: "_tabKeydown"
            });
            this._on(this.panels, {
                keydown: "_panelKeydown"
            });
            this._focusable(this.tabs);
            this._hoverable(this.tabs);
        },
        _setupHeightStyle: function(heightStyle) {
            var maxHeight, parent = this.element.parent();
            if (heightStyle === "fill") {
                maxHeight = parent.height();
                maxHeight -= this.element.outerHeight() - this.element.height();
                this.element.siblings(":visible").each(function() {
                    var elem = $(this), position = elem.css("position");
                    if (position === "absolute" || position === "fixed") {
                        return;
                    }
                    maxHeight -= elem.outerHeight(true);
                });
                this.element.children().not(this.panels).each(function() {
                    maxHeight -= $(this).outerHeight(true);
                });
                this.panels.each(function() {
                    $(this).height(Math.max(0, maxHeight - $(this).innerHeight() + $(this).height()));
                }).css("overflow", "auto");
            } else if (heightStyle === "auto") {
                maxHeight = 0;
                this.panels.each(function() {
                    maxHeight = Math.max(maxHeight, $(this).height("").height());
                }).height(maxHeight);
            }
        },
        _eventHandler: function(event) {
            var options = this.options, active = this.active, anchor = $(event.currentTarget), tab = anchor.closest("li"), clickedIsActive = tab[0] === active[0], collapsing = clickedIsActive && options.collapsible, toShow = collapsing ? $() : this._getPanelForTab(tab), toHide = !active.length ? $() : this._getPanelForTab(active), eventData = {
                oldTab: active,
                oldPanel: toHide,
                newTab: collapsing ? $() : tab,
                newPanel: toShow
            };
            event.preventDefault();
            if (tab.hasClass("ui-state-disabled") || tab.hasClass("ui-tabs-loading") || this.running || clickedIsActive && !options.collapsible || this._trigger("beforeActivate", event, eventData) === false) {
                return;
            }
            options.active = collapsing ? false : this.tabs.index(tab);
            this.active = clickedIsActive ? $() : tab;
            if (this.xhr) {
                this.xhr.abort();
            }
            if (!toHide.length && !toShow.length) {
                $.error("jQuery UI Tabs: Mismatching fragment identifier.");
            }
            if (toShow.length) {
                this.load(this.tabs.index(tab), event);
            }
            this._toggle(event, eventData);
        },
        _toggle: function(event, eventData) {
            var that = this, toShow = eventData.newPanel, toHide = eventData.oldPanel;
            this.running = true;
            function complete() {
                that.running = false;
                that._trigger("activate", event, eventData);
            }
            function show() {
                that._addClass(eventData.newTab.closest("li"), "ui-tabs-active", "ui-state-active");
                if (toShow.length && that.options.show) {
                    that._show(toShow, that.options.show, complete);
                } else {
                    toShow.show();
                    complete();
                }
            }
            if (toHide.length && this.options.hide) {
                this._hide(toHide, this.options.hide, function() {
                    that._removeClass(eventData.oldTab.closest("li"), "ui-tabs-active", "ui-state-active");
                    show();
                });
            } else {
                this._removeClass(eventData.oldTab.closest("li"), "ui-tabs-active", "ui-state-active");
                toHide.hide();
                show();
            }
            toHide.attr("aria-hidden", "true");
            eventData.oldTab.attr({
                "aria-selected": "false",
                "aria-expanded": "false"
            });
            if (toShow.length && toHide.length) {
                eventData.oldTab.attr("tabIndex", -1);
            } else if (toShow.length) {
                this.tabs.filter(function() {
                    return $(this).attr("tabIndex") === 0;
                }).attr("tabIndex", -1);
            }
            toShow.attr("aria-hidden", "false");
            eventData.newTab.attr({
                "aria-selected": "true",
                "aria-expanded": "true",
                tabIndex: 0
            });
        },
        _activate: function(index) {
            var anchor, active = this._findActive(index);
            if (active[0] === this.active[0]) {
                return;
            }
            if (!active.length) {
                active = this.active;
            }
            anchor = active.find(".ui-tabs-anchor")[0];
            this._eventHandler({
                target: anchor,
                currentTarget: anchor,
                preventDefault: $.noop
            });
        },
        _findActive: function(index) {
            return index === false ? $() : this.tabs.eq(index);
        },
        _getIndex: function(index) {
            if (typeof index === "string") {
                index = this.anchors.index(this.anchors.filter("[href$='" + $.ui.escapeSelector(index) + "']"));
            }
            return index;
        },
        _destroy: function() {
            if (this.xhr) {
                this.xhr.abort();
            }
            this.tablist.removeAttr("role").off(this.eventNamespace);
            this.anchors.removeAttr("role tabIndex").removeUniqueId();
            this.tabs.add(this.panels).each(function() {
                if ($.data(this, "ui-tabs-destroy")) {
                    $(this).remove();
                } else {
                    $(this).removeAttr("role tabIndex " + "aria-live aria-busy aria-selected aria-labelledby aria-hidden aria-expanded");
                }
            });
            this.tabs.each(function() {
                var li = $(this), prev = li.data("ui-tabs-aria-controls");
                if (prev) {
                    li.attr("aria-controls", prev).removeData("ui-tabs-aria-controls");
                } else {
                    li.removeAttr("aria-controls");
                }
            });
            this.panels.show();
            if (this.options.heightStyle !== "content") {
                this.panels.css("height", "");
            }
        },
        enable: function(index) {
            var disabled = this.options.disabled;
            if (disabled === false) {
                return;
            }
            if (index === undefined) {
                disabled = false;
            } else {
                index = this._getIndex(index);
                if ($.isArray(disabled)) {
                    disabled = $.map(disabled, function(num) {
                        return num !== index ? num : null;
                    });
                } else {
                    disabled = $.map(this.tabs, function(li, num) {
                        return num !== index ? num : null;
                    });
                }
            }
            this._setOptionDisabled(disabled);
        },
        disable: function(index) {
            var disabled = this.options.disabled;
            if (disabled === true) {
                return;
            }
            if (index === undefined) {
                disabled = true;
            } else {
                index = this._getIndex(index);
                if ($.inArray(index, disabled) !== -1) {
                    return;
                }
                if ($.isArray(disabled)) {
                    disabled = $.merge([ index ], disabled).sort();
                } else {
                    disabled = [ index ];
                }
            }
            this._setOptionDisabled(disabled);
        },
        load: function(index, event) {
            index = this._getIndex(index);
            var that = this, tab = this.tabs.eq(index), anchor = tab.find(".ui-tabs-anchor"), panel = this._getPanelForTab(tab), eventData = {
                tab: tab,
                panel: panel
            }, complete = function(jqXHR, status) {
                if (status === "abort") {
                    that.panels.stop(false, true);
                }
                that._removeClass(tab, "ui-tabs-loading");
                panel.removeAttr("aria-busy");
                if (jqXHR === that.xhr) {
                    delete that.xhr;
                }
            };
            if (this._isLocal(anchor[0])) {
                return;
            }
            this.xhr = $.ajax(this._ajaxSettings(anchor, event, eventData));
            if (this.xhr && this.xhr.statusText !== "canceled") {
                this._addClass(tab, "ui-tabs-loading");
                panel.attr("aria-busy", "true");
                this.xhr.done(function(response, status, jqXHR) {
                    setTimeout(function() {
                        panel.html(response);
                        that._trigger("load", event, eventData);
                        complete(jqXHR, status);
                    }, 1);
                }).fail(function(jqXHR, status) {
                    setTimeout(function() {
                        complete(jqXHR, status);
                    }, 1);
                });
            }
        },
        _ajaxSettings: function(anchor, event, eventData) {
            var that = this;
            return {
                url: anchor.attr("href").replace(/#.*$/, ""),
                beforeSend: function(jqXHR, settings) {
                    return that._trigger("beforeLoad", event, $.extend({
                        jqXHR: jqXHR,
                        ajaxSettings: settings
                    }, eventData));
                }
            };
        },
        _getPanelForTab: function(tab) {
            var id = $(tab).attr("aria-controls");
            return this.element.find(this._sanitizeSelector("#" + id));
        }
    });
    if ($.uiBackCompat !== false) {
        $.widget("ui.tabs", $.ui.tabs, {
            _processTabs: function() {
                this._superApply(arguments);
                this._addClass(this.tabs, "ui-tab");
            }
        });
    }
    var widgetsTabs = $.ui.tabs;
    $.widget("ui.tooltip", {
        version: "1.12.1",
        options: {
            classes: {
                "ui-tooltip": "ui-corner-all ui-widget-shadow"
            },
            content: function() {
                var title = $(this).attr("title") || "";
                return $("<a>").text(title).html();
            },
            hide: true,
            items: "[title]:not([disabled])",
            position: {
                my: "left top+15",
                at: "left bottom",
                collision: "flipfit flip"
            },
            show: true,
            track: false,
            close: null,
            open: null
        },
        _addDescribedBy: function(elem, id) {
            var describedby = (elem.attr("aria-describedby") || "").split(/\s+/);
            describedby.push(id);
            elem.data("ui-tooltip-id", id).attr("aria-describedby", $.trim(describedby.join(" ")));
        },
        _removeDescribedBy: function(elem) {
            var id = elem.data("ui-tooltip-id"), describedby = (elem.attr("aria-describedby") || "").split(/\s+/), index = $.inArray(id, describedby);
            if (index !== -1) {
                describedby.splice(index, 1);
            }
            elem.removeData("ui-tooltip-id");
            describedby = $.trim(describedby.join(" "));
            if (describedby) {
                elem.attr("aria-describedby", describedby);
            } else {
                elem.removeAttr("aria-describedby");
            }
        },
        _create: function() {
            this._on({
                mouseover: "open",
                focusin: "open"
            });
            this.tooltips = {};
            this.parents = {};
            this.liveRegion = $("<div>").attr({
                role: "log",
                "aria-live": "assertive",
                "aria-relevant": "additions"
            }).appendTo(this.document[0].body);
            this._addClass(this.liveRegion, null, "ui-helper-hidden-accessible");
            this.disabledTitles = $([]);
        },
        _setOption: function(key, value) {
            var that = this;
            this._super(key, value);
            if (key === "content") {
                $.each(this.tooltips, function(id, tooltipData) {
                    that._updateContent(tooltipData.element);
                });
            }
        },
        _setOptionDisabled: function(value) {
            this[value ? "_disable" : "_enable"]();
        },
        _disable: function() {
            var that = this;
            $.each(this.tooltips, function(id, tooltipData) {
                var event = $.Event("blur");
                event.target = event.currentTarget = tooltipData.element[0];
                that.close(event, true);
            });
            this.disabledTitles = this.disabledTitles.add(this.element.find(this.options.items).addBack().filter(function() {
                var element = $(this);
                if (element.is("[title]")) {
                    return element.data("ui-tooltip-title", element.attr("title")).removeAttr("title");
                }
            }));
        },
        _enable: function() {
            this.disabledTitles.each(function() {
                var element = $(this);
                if (element.data("ui-tooltip-title")) {
                    element.attr("title", element.data("ui-tooltip-title"));
                }
            });
            this.disabledTitles = $([]);
        },
        open: function(event) {
            var that = this, target = $(event ? event.target : this.element).closest(this.options.items);
            if (!target.length || target.data("ui-tooltip-id")) {
                return;
            }
            if (target.attr("title")) {
                target.data("ui-tooltip-title", target.attr("title"));
            }
            target.data("ui-tooltip-open", true);
            if (event && event.type === "mouseover") {
                target.parents().each(function() {
                    var parent = $(this), blurEvent;
                    if (parent.data("ui-tooltip-open")) {
                        blurEvent = $.Event("blur");
                        blurEvent.target = blurEvent.currentTarget = this;
                        that.close(blurEvent, true);
                    }
                    if (parent.attr("title")) {
                        parent.uniqueId();
                        that.parents[this.id] = {
                            element: this,
                            title: parent.attr("title")
                        };
                        parent.attr("title", "");
                    }
                });
            }
            this._registerCloseHandlers(event, target);
            this._updateContent(target, event);
        },
        _updateContent: function(target, event) {
            var content, contentOption = this.options.content, that = this, eventType = event ? event.type : null;
            if (typeof contentOption === "string" || contentOption.nodeType || contentOption.jquery) {
                return this._open(event, target, contentOption);
            }
            content = contentOption.call(target[0], function(response) {
                that._delay(function() {
                    if (!target.data("ui-tooltip-open")) {
                        return;
                    }
                    if (event) {
                        event.type = eventType;
                    }
                    this._open(event, target, response);
                });
            });
            if (content) {
                this._open(event, target, content);
            }
        },
        _open: function(event, target, content) {
            var tooltipData, tooltip, delayedShow, a11yContent, positionOption = $.extend({}, this.options.position);
            if (!content) {
                return;
            }
            tooltipData = this._find(target);
            if (tooltipData) {
                tooltipData.tooltip.find(".ui-tooltip-content").html(content);
                return;
            }
            if (target.is("[title]")) {
                if (event && event.type === "mouseover") {
                    target.attr("title", "");
                } else {
                    target.removeAttr("title");
                }
            }
            tooltipData = this._tooltip(target);
            tooltip = tooltipData.tooltip;
            this._addDescribedBy(target, tooltip.attr("id"));
            tooltip.find(".ui-tooltip-content").html(content);
            this.liveRegion.children().hide();
            a11yContent = $("<div>").html(tooltip.find(".ui-tooltip-content").html());
            a11yContent.removeAttr("name").find("[name]").removeAttr("name");
            a11yContent.removeAttr("id").find("[id]").removeAttr("id");
            a11yContent.appendTo(this.liveRegion);
            function position(event) {
                positionOption.of = event;
                if (tooltip.is(":hidden")) {
                    return;
                }
                tooltip.position(positionOption);
            }
            if (this.options.track && event && /^mouse/.test(event.type)) {
                this._on(this.document, {
                    mousemove: position
                });
                position(event);
            } else {
                tooltip.position($.extend({
                    of: target
                }, this.options.position));
            }
            tooltip.hide();
            this._show(tooltip, this.options.show);
            if (this.options.track && this.options.show && this.options.show.delay) {
                delayedShow = this.delayedShow = setInterval(function() {
                    if (tooltip.is(":visible")) {
                        position(positionOption.of);
                        clearInterval(delayedShow);
                    }
                }, $.fx.interval);
            }
            this._trigger("open", event, {
                tooltip: tooltip
            });
        },
        _registerCloseHandlers: function(event, target) {
            var events = {
                keyup: function(event) {
                    if (event.keyCode === $.ui.keyCode.ESCAPE) {
                        var fakeEvent = $.Event(event);
                        fakeEvent.currentTarget = target[0];
                        this.close(fakeEvent, true);
                    }
                }
            };
            if (target[0] !== this.element[0]) {
                events.remove = function() {
                    this._removeTooltip(this._find(target).tooltip);
                };
            }
            if (!event || event.type === "mouseover") {
                events.mouseleave = "close";
            }
            if (!event || event.type === "focusin") {
                events.focusout = "close";
            }
            this._on(true, target, events);
        },
        close: function(event) {
            var tooltip, that = this, target = $(event ? event.currentTarget : this.element), tooltipData = this._find(target);
            if (!tooltipData) {
                target.removeData("ui-tooltip-open");
                return;
            }
            tooltip = tooltipData.tooltip;
            if (tooltipData.closing) {
                return;
            }
            clearInterval(this.delayedShow);
            if (target.data("ui-tooltip-title") && !target.attr("title")) {
                target.attr("title", target.data("ui-tooltip-title"));
            }
            this._removeDescribedBy(target);
            tooltipData.hiding = true;
            tooltip.stop(true);
            this._hide(tooltip, this.options.hide, function() {
                that._removeTooltip($(this));
            });
            target.removeData("ui-tooltip-open");
            this._off(target, "mouseleave focusout keyup");
            if (target[0] !== this.element[0]) {
                this._off(target, "remove");
            }
            this._off(this.document, "mousemove");
            if (event && event.type === "mouseleave") {
                $.each(this.parents, function(id, parent) {
                    $(parent.element).attr("title", parent.title);
                    delete that.parents[id];
                });
            }
            tooltipData.closing = true;
            this._trigger("close", event, {
                tooltip: tooltip
            });
            if (!tooltipData.hiding) {
                tooltipData.closing = false;
            }
        },
        _tooltip: function(element) {
            var tooltip = $("<div>").attr("role", "tooltip"), content = $("<div>").appendTo(tooltip), id = tooltip.uniqueId().attr("id");
            this._addClass(content, "ui-tooltip-content");
            this._addClass(tooltip, "ui-tooltip", "ui-widget ui-widget-content");
            tooltip.appendTo(this._appendTo(element));
            return this.tooltips[id] = {
                element: element,
                tooltip: tooltip
            };
        },
        _find: function(target) {
            var id = target.data("ui-tooltip-id");
            return id ? this.tooltips[id] : null;
        },
        _removeTooltip: function(tooltip) {
            tooltip.remove();
            delete this.tooltips[tooltip.attr("id")];
        },
        _appendTo: function(target) {
            var element = target.closest(".ui-front, dialog");
            if (!element.length) {
                element = this.document[0].body;
            }
            return element;
        },
        _destroy: function() {
            var that = this;
            $.each(this.tooltips, function(id, tooltipData) {
                var event = $.Event("blur"), element = tooltipData.element;
                event.target = event.currentTarget = element[0];
                that.close(event, true);
                $("#" + id).remove();
                if (element.data("ui-tooltip-title")) {
                    if (!element.attr("title")) {
                        element.attr("title", element.data("ui-tooltip-title"));
                    }
                    element.removeData("ui-tooltip-title");
                }
            });
            this.liveRegion.remove();
        }
    });
    if ($.uiBackCompat !== false) {
        $.widget("ui.tooltip", $.ui.tooltip, {
            options: {
                tooltipClass: null
            },
            _tooltip: function() {
                var tooltipData = this._superApply(arguments);
                if (this.options.tooltipClass) {
                    tooltipData.tooltip.addClass(this.options.tooltipClass);
                }
                return tooltipData;
            }
        });
    }
    var widgetsTooltip = $.ui.tooltip;
});

(function(root, factory) {
    if (typeof define === "function" && define.amd) {
        define(factory);
    } else if (typeof exports === "object") {
        module.exports = factory(require, exports, module);
    } else {
        root.CountUp = factory();
    }
})(this, function(require, exports, module) {
    var CountUp = function(target, startVal, endVal, decimals, duration, options) {
        var self = this;
        self.version = function() {
            return "1.9.3";
        };
        self.options = {
            useEasing: true,
            useGrouping: true,
            separator: ",",
            decimal: ".",
            easingFn: easeOutExpo,
            formattingFn: formatNumber,
            prefix: "",
            suffix: "",
            numerals: []
        };
        if (options && typeof options === "object") {
            for (var key in self.options) {
                if (options.hasOwnProperty(key) && options[key] !== null) {
                    self.options[key] = options[key];
                }
            }
        }
        if (self.options.separator === "") {
            self.options.useGrouping = false;
        } else {
            self.options.separator = "" + self.options.separator;
        }
        var lastTime = 0;
        var vendors = [ "webkit", "moz", "ms", "o" ];
        for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
            window.requestAnimationFrame = window[vendors[x] + "RequestAnimationFrame"];
            window.cancelAnimationFrame = window[vendors[x] + "CancelAnimationFrame"] || window[vendors[x] + "CancelRequestAnimationFrame"];
        }
        if (!window.requestAnimationFrame) {
            window.requestAnimationFrame = function(callback, element) {
                var currTime = new Date().getTime();
                var timeToCall = Math.max(0, 16 - (currTime - lastTime));
                var id = window.setTimeout(function() {
                    callback(currTime + timeToCall);
                }, timeToCall);
                lastTime = currTime + timeToCall;
                return id;
            };
        }
        if (!window.cancelAnimationFrame) {
            window.cancelAnimationFrame = function(id) {
                clearTimeout(id);
            };
        }
        function formatNumber(num) {
            var neg = num < 0, x, x1, x2, x3, i, len;
            num = Math.abs(num).toFixed(self.decimals);
            num += "";
            x = num.split(".");
            x1 = x[0];
            x2 = x.length > 1 ? self.options.decimal + x[1] : "";
            if (self.options.useGrouping) {
                x3 = "";
                for (i = 0, len = x1.length; i < len; ++i) {
                    if (i !== 0 && i % 3 === 0) {
                        x3 = self.options.separator + x3;
                    }
                    x3 = x1[len - i - 1] + x3;
                }
                x1 = x3;
            }
            if (self.options.numerals.length) {
                x1 = x1.replace(/[0-9]/g, function(w) {
                    return self.options.numerals[+w];
                });
                x2 = x2.replace(/[0-9]/g, function(w) {
                    return self.options.numerals[+w];
                });
            }
            return (neg ? "-" : "") + self.options.prefix + x1 + x2 + self.options.suffix;
        }
        function easeOutExpo(t, b, c, d) {
            return c * (-Math.pow(2, -10 * t / d) + 1) * 1024 / 1023 + b;
        }
        function ensureNumber(n) {
            return typeof n === "number" && !isNaN(n);
        }
        self.initialize = function() {
            if (self.initialized) return true;
            self.error = "";
            self.d = typeof target === "string" ? document.getElementById(target) : target;
            if (!self.d) {
                self.error = "[CountUp] target is null or undefined";
                return false;
            }
            self.startVal = Number(startVal);
            self.endVal = Number(endVal);
            if (ensureNumber(self.startVal) && ensureNumber(self.endVal)) {
                self.decimals = Math.max(0, decimals || 0);
                self.dec = Math.pow(10, self.decimals);
                self.duration = Number(duration) * 1e3 || 2e3;
                self.countDown = self.startVal > self.endVal;
                self.frameVal = self.startVal;
                self.initialized = true;
                return true;
            } else {
                self.error = "[CountUp] startVal (" + startVal + ") or endVal (" + endVal + ") is not a number";
                return false;
            }
        };
        self.printValue = function(value) {
            var result = self.options.formattingFn(value);
            if (self.d.tagName === "INPUT") {
                this.d.value = result;
            } else if (self.d.tagName === "text" || self.d.tagName === "tspan") {
                this.d.textContent = result;
            } else {
                this.d.innerHTML = result;
            }
        };
        self.count = function(timestamp) {
            if (!self.startTime) {
                self.startTime = timestamp;
            }
            self.timestamp = timestamp;
            var progress = timestamp - self.startTime;
            self.remaining = self.duration - progress;
            if (self.options.useEasing) {
                if (self.countDown) {
                    self.frameVal = self.startVal - self.options.easingFn(progress, 0, self.startVal - self.endVal, self.duration);
                } else {
                    self.frameVal = self.options.easingFn(progress, self.startVal, self.endVal - self.startVal, self.duration);
                }
            } else {
                if (self.countDown) {
                    self.frameVal = self.startVal - (self.startVal - self.endVal) * (progress / self.duration);
                } else {
                    self.frameVal = self.startVal + (self.endVal - self.startVal) * (progress / self.duration);
                }
            }
            if (self.countDown) {
                self.frameVal = self.frameVal < self.endVal ? self.endVal : self.frameVal;
            } else {
                self.frameVal = self.frameVal > self.endVal ? self.endVal : self.frameVal;
            }
            self.frameVal = Math.round(self.frameVal * self.dec) / self.dec;
            self.printValue(self.frameVal);
            if (progress < self.duration) {
                self.rAF = requestAnimationFrame(self.count);
            } else {
                if (self.callback) self.callback();
            }
        };
        self.start = function(callback) {
            if (!self.initialize()) return;
            self.callback = callback;
            self.rAF = requestAnimationFrame(self.count);
        };
        self.pauseResume = function() {
            if (!self.paused) {
                self.paused = true;
                cancelAnimationFrame(self.rAF);
            } else {
                self.paused = false;
                delete self.startTime;
                self.duration = self.remaining;
                self.startVal = self.frameVal;
                requestAnimationFrame(self.count);
            }
        };
        self.reset = function() {
            self.paused = false;
            delete self.startTime;
            self.initialized = false;
            if (self.initialize()) {
                cancelAnimationFrame(self.rAF);
                self.printValue(self.startVal);
            }
        };
        self.update = function(newEndVal) {
            if (!self.initialize()) return;
            newEndVal = Number(newEndVal);
            if (!ensureNumber(newEndVal)) {
                self.error = "[CountUp] update() - new endVal is not a number: " + newEndVal;
                return;
            }
            self.error = "";
            if (newEndVal === self.frameVal) return;
            cancelAnimationFrame(self.rAF);
            self.paused = false;
            delete self.startTime;
            self.startVal = self.frameVal;
            self.endVal = newEndVal;
            self.countDown = self.startVal > self.endVal;
            self.rAF = requestAnimationFrame(self.count);
        };
        if (self.initialize()) self.printValue(self.startVal);
    };
    return CountUp;
});

(function() {
    "use strict";
    function scaleImageMap() {
        function resizeMap() {
            function resizeAreaTag(cachedAreaCoords, idx) {
                function scale(coord) {
                    var dimension = 1 === (isWidth = 1 - isWidth) ? "width" : "height";
                    return padding[dimension] + Math.floor(Number(coord) * scalingFactor[dimension]);
                }
                var isWidth = 0;
                areas[idx].coords = cachedAreaCoords.split(",").map(scale).join(",");
            }
            var scalingFactor = {
                width: image.width / image.naturalWidth,
                height: image.height / image.naturalHeight
            };
            var padding = {
                width: parseInt(window.getComputedStyle(image, null).getPropertyValue("padding-left"), 10),
                height: parseInt(window.getComputedStyle(image, null).getPropertyValue("padding-top"), 10)
            };
            cachedAreaCoordsArray.forEach(resizeAreaTag);
        }
        function getCoords(e) {
            return e.coords.replace(/ *, */g, ",").replace(/ +/g, ",");
        }
        function debounce() {
            clearTimeout(timer);
            timer = setTimeout(resizeMap, 250);
        }
        function start() {
            if (image.width !== image.naturalWidth || image.height !== image.naturalHeight) {
                resizeMap();
            }
        }
        function addEventListeners() {
            image.addEventListener("load", resizeMap, false);
            window.addEventListener("focus", resizeMap, false);
            window.addEventListener("resize", debounce, false);
            window.addEventListener("readystatechange", resizeMap, false);
            document.addEventListener("fullscreenchange", resizeMap, false);
        }
        function beenHere() {
            return "function" === typeof map._resize;
        }
        function getImg(name) {
            return document.querySelector('img[usemap="' + name + '"]');
        }
        function setup() {
            areas = map.getElementsByTagName("area");
            cachedAreaCoordsArray = Array.prototype.map.call(areas, getCoords);
            image = getImg("#" + map.name) || getImg(map.name);
            map._resize = resizeMap;
        }
        var map = this, areas = null, cachedAreaCoordsArray = null, image = null, timer = null;
        if (!beenHere()) {
            setup();
            addEventListeners();
            start();
        } else {
            map._resize();
        }
    }
    function factory() {
        function chkMap(element) {
            if (!element.tagName) {
                throw new TypeError("Object is not a valid DOM element");
            } else if ("MAP" !== element.tagName.toUpperCase()) {
                throw new TypeError("Expected <MAP> tag, found <" + element.tagName + ">.");
            }
        }
        function init(element) {
            if (element) {
                chkMap(element);
                scaleImageMap.call(element);
                maps.push(element);
            }
        }
        var maps;
        return function imageMapResizeF(target) {
            maps = [];
            switch (typeof target) {
              case "undefined":
              case "string":
                Array.prototype.forEach.call(document.querySelectorAll(target || "map"), init);
                break;

              case "object":
                init(target);
                break;

              default:
                throw new TypeError("Unexpected data type (" + typeof target + ").");
            }
            return maps;
        };
    }
    if (typeof define === "function" && define.amd) {
        define([], factory);
    } else if (typeof module === "object" && typeof module.exports === "object") {
        module.exports = factory();
    } else {
        window.imageMapResize = factory();
    }
    if ("jQuery" in window) {
        window.jQuery.fn.imageMapResize = function $imageMapResizeF() {
            return this.filter("map").each(scaleImageMap).end();
        };
    }
})();

$(function() {
    var $el = $("#mastersliderhome");
    if ($el.length) {
        var slider = new MasterSlider();
        setTimeout(function() {
            SetUpSlider(slider);
        }, 200);
        slider.control("arrows");
    }
});

function SetUpSlider(slider) {
    slider.setup("mastersliderhome", {
        width: 1500,
        height: 500,
        space: 1,
        layout: "fullwidth",
        loop: true,
        preload: 0,
        instantStartLayers: true,
        autoplay: true,
        autoHeight: true,
        overPause: false
    });
}

$(function() {
    $("#language_select").on("change", function() {
        var url = $(this).val();
        if (url) {
            window.location.href = url;
        }
        return false;
    });
});

var a_ebook = "978-1-64274-041-7";

var a_basic = "BDL2-A1-BSC";

var a_deluxe = "BDL2-A1-DLX";

var a_premier = "BDL2-A1-PRM";

var a_1101_voucher = "APL-11C-TSTV-22-C";

var a_1101_cmlearn = "APL-111-CMLI-22-C";

var a_1101_cmlearncmlabs = "APL-111-CLLO-22-C";

var a_1101_cmpractice = "APL-111-CMPI-22-C";

var a_1101_labs = "APL-111-CMLB-22-CC";

var a_1101_ebook = "APL-111-SPDB-22-C";

var a_1101_basic = "APL-111-BDBA-22A-C";

var a_1101_examprep = "APL-111-BDEP-22A-C";

var a_1101_elearning = "APL-111-BDEL-22A-C";

var a_1101_complete = "APL-111-BDCO-22A-C";

var a_1102_voucher = "APL-11C-TSTV-22-C";

var a_1102_ebook = "APL-112-SPDB-22-C";

var a_1102_cmlearncmlabs = "APL-112-CLLO-22-C";

var a_1102_cmlearn = "APL-112-CMLI-22-C";

var a_1102_cmpractice = "APL-112-CMPI-22-C";

var a_1102_labs = "APL-112-CMLB-22-CC";

var a_1102_basic = "APL-112-BDBA-22A-C";

var a_1102_examprep = "APL-112-BDEP-22A-C";

var a_1102_elearning = "APL-112-BDEL-22A-C";

var a_1102_complete = "APL-112-BDCO-22A-C";

var a_11011102_ebook = "APL-11C-SPDB-22-C";

var a_11011102_cmlearncmlabs = "APL-11C-CLLO-22-C";

var a_11011102_cmlearn = "APL-11C-CMLI-22-C";

var a_11011102_cmpractice = "APL-11C-CMPI-22-C";

var a_11011102_labs = "APL-11C-CMLB-22-CC";

var a_11011102_basic = "APL-11C-BDBA-22A-C";

var a_11011102_examprep = "APL-11C-BDEP-22A-C";

var a_11011102_elearning = "APL-11C-BDEL-22A-C";

var a_11011102_complete = "APL-11C-BDCO-22A-C";

var a_examdetails = "APL-11C-TSTV-22-C";

var casp_voucher = "COMPTIACASP";

var casp_004_voucher = "CAS-004-TSTV-21-C";

var casp_004_ebook = "CAS-004-SPDB-21-C";

var casp_004_basic = "CAS-004-BDBA-22-C";

var casp_004_examprep = "CAS-004-BDEP-22-C";

var casp_004_elearning = "CAS-004-BDEL-22-C";

var casp_004_complete = "CAS-004-BDCO-22-C";

var casp_004_labs = "CAS-004-CMLB-21-C";

var casp_004_cmpractice = "CAS-004-CMPI-21-C";

var casp_004_cmlearn = "CAS-004-CMLI-21-C";

var casp_examdetails = "CAS-004-TSTV-21-C";

var ce_002_voucher = "CompTIACLOUD";

var ce_002_ebook = "CLE-002-SPDB-20-C";

var ce_002_basic = "CLE-002-BDBA-22-C";

var ce_002_examprep = "CLE-002-BDEP-22-C";

var ce_002_elearning = "CLE-002-BDEL-22-C";

var ce_002_complete = "CLE-002-BDCO-22-C";

var ce_002_cmpractice = "CLE-002-CMPI-2019";

var ce_002_cmlearn = "CLE-002-CMLR-2019";

var ce_examdetails = "CompTIACLOUD";

var cloud_003_voucher = "CLD-003-TSTV-21-C";

var cloud_003_cmlearn = "CLD-003-CMLI-21-C";

var cloud_003_labs = "CLD-003-CMLB-21-C";

var cloud_003_cmpractice = "CLD-003-CMPI-21-C";

var cloud_003_ebook = "CLD-003-SPDB-21-C";

var cloud_003_basic = "CLD-003-BDBA-22-C";

var cloud_003_examprep = "CLD-003-BDEP-22-C";

var cloud_003_elearning = "CLD-003-BDEL-22-C";

var cloud_003_complete = "CLD-003-BDCO-22-C";

var cloud_examdetails = "CLD-003-TSTV-21-C";

var ctt_evoucher = "CompTIACTT";

var ctt_ctvoucher = "CompTIACTTTK0CLRM";

var ctt_vctvoucher = "CompTIACTTTK0VCLRM";

var ctt_examdetails = "CompTIACTT";

var ctt_202_examdetails = "CompTIACTTTK0CLRM";

var cysa_ebook = "978-1-64274-003-5";

var cysa_cmlearn = "CYS-002-CMLI-20-C";

var cysa_labs = "CYS-002-CLBI-20-C";

var cysa_basic = "CYS-002-BDBA-22-C";

var cysa_deluxe = "CYS-002-BDDL-20-C";

var cysa_premier = "CYS-002-BDPL-20-C";

var cysa_examprep = "CYS-002-BDEP-22-C";

var cysa_002_voucher = "CompTIACSA";

var cysa_002_ebook = "CYS-002-SPDB-20A-C";

var cysa_002_cmlearn = "CYS-002-CMLI-20-C";

var cysa_002_cmpractice = "CYS-002-CMPI-20-C";

var cysa_002_labs = "CYS-002-CLBI-20-C";

var cysa_002_basic = "CYS-002-BDBA-22-C";

var cysa_002_examprep = "CYS-002-BDEP-22-C";

var cysa_002_elearning = "CYS-002-BDEL-22-C";

var cysa_002_complete = "CYS-002-BDCO-22-C";

var cysa_examdetails = "CompTIACSA";

var data_voucher = "DAT-001-TSTV-22-C";

var data_cmlearn = "DAT-001-CMLI-22-C";

var data_cmpractice = "DAT-001-CMPI-22-C";

var data_labs = "DAT-001-CMLB-22-C";

var data_basic = "DAT-001-BDBA-22A-C";

var data_examprep = "DAT-001-BDEP-22A-C";

var data_elearning = "DAT-001-BDEL-22A-C";

var data_complete = "DAT-001-BDCO-22A-C";

var data_001_voucher = "DAT-001-TSTV-22-C";

var data_001_cmlearn = "DAT-001-CMLI-22-C";

var data_001_cmpractice = "DAT-001-CMPI-22-C";

var data_001_ebook = "DAT-001-SPDB-22-C";

var data_001_basic = "DAT-001-BDBA-22A-C";

var data_001_examprep = "DAT-001-BDEP-22A-C";

var data_001_elearning = "DAT-001-BDEL-22A-C";

var data_001_complete = "DAT-001-BDCO-22A-C";

var data_001_labs = "DAT-001-CMLB-22-C";

var data_examdetails = "DAT-001-TSTV-22-C";

var itf_voucher = "CompTIAITFplus";

var itf_ebook = "ITF-U61-SPDB-20-C";

var itf_labs = "ITF-U61-CLBI-20-C";

var itf_cmlearn = "ITF-U61-CMLR-2018";

var itf_cmpractice = "ITF-U61-CMPI-2019";

var itf_basic = "ITF-U61-BDBA-22-C";

var itf_examprep = "ITF-U61-BDEP-22-C";

var itf_elearning = "ITF-U61-BDEL-22-C";

var itf_complete = "ITF-U61-BDCO-22-C";

var itf_deluxelabs = "ITF-U61-BDDL-20-C";

var itf_premierlabs = "ITF-U61-BDPL-20-C";

var itf_examdetails = "CompTIAITFplus";

var linux_voucher = "CompTIALNX";

var linux_ebook = "LIN-004-SPDB-20-C";

var linux_cmpractice = "LIN-004-CMPI-2019";

var linux_cmlearn = "LIN-004-CMLR-2019";

var linux_labs = "LIN-004-CLBI-20-C";

var linux_basic = "LIN-004-BDBA-22-C";

var linux_examprep = "LIN-004-BDEP-22-C";

var linux_elearning = "LIN-004-BDEL-22-C";

var linux_deluxe = "LIN-004-BDDL-20-C";

var linux_premier = "LIN-004-BDPL-20-C";

var linux_complete = "LIN-004-BDCO-22-C";

var linux_004_voucher = "CompTIALNX";

var linux_004_ebook = "LIN-004-SPDB-20-C";

var linux_004_basic = "LIN-004-BDBA-22-C";

var linux_004_examprep = "LIN-004-BDEP-22-C";

var linux_004_elearning = "LIN-004-BDEL-22-C";

var linux_004_cmpractice = "LIN-004-CMPI-2019";

var linux_004_cmlearn = "LIN-004-CMLR-2019";

var linux_004_labs = "LIN-004-CLBI-20-C";

var linux_004_complete = "LIN-004-BDCO-22-C";

var linux_004_deluxe = "LIN-004-BDDL-20-C";

var linux_004_premier = "LIN-004-BDPL-20-C";

var linux_005_voucher = "LIN-005-TSTV-22-C";

var linux_005_ebook = "LIN-005-SPDB-22-C";

var linux_005_basic = "LIN-005-BDBA-22A-C";

var linux_005_examprep = "LIN-005-BDEP-22A-C";

var linux_005_elearning = "LIN-005-BDEL-22A-C";

var linux_005_cmlearn = "LIN-005-CMLI-22-C";

var linux_005_labs = "LIN-005-CMLB-22-C";

var linux_005_cmpractice = "LIN-005-CMPI-22-C";

var linux_005_complete = "LIN-005-BDCO-22A-C";

var linux_examdetails = "LIN-005-TSTV-22-C";

var network_voucher = "NET-008-TSTV-21-C";

var network_008_voucher = "NET-008-TSTV-21-C";

var network_008_cmlearn = "NET-008-CMLI-21-C";

var network_008_cmlearnlabs = "NET-008-CLLV-21-C";

var network_008_labs = "NET-008-CMLB-21-C";

var network_008_cmpractice = "NET-008-CMPI-21-C";

var network_008_ebook = "NET-008-SPPB-21-C";

var network_008_basic = "NET-008-BDBA-22-C";

var network_008_examprep = "NET-008-BDEP-22-C";

var network_008_elearning = "NET-008-BDEL-22-C";

var network_008_complete = "NET-008-BDCO-22-C";

var network_examdetails = "NET-008-TSTV-21-C";

var pentest_002_voucher = "PEN-002-TSTV-21-C";

var pentest_002_ebook = "PEN-002-SPPB-21-C";

var pentest_002_cmlearn = "PEN-002-CMLI-21-C";

var pentest_002_cmpractice = "PEN-002-CMPI-21-C";

var pentest_002_basic = "PEN-002-BDBA-22-C";

var pentest_002_examprep = "PEN-002-BDEP-22-C";

var pentest_002_elearning = "PEN-002-BDEL-22-C";

var pentest_002_complete = "PEN-002-BDCO-22-C";

var pentest_002_labs = "PEN-002-CMLB-21-C";

var pentest_examdetails = "PEN-002-TSTV-21-C";

var project_004_voucher = "CompTIAPJT";

var project_004_ebook = "PRO-004-SPDB-20-C";

var project_004_cmpractice = "CMPK0";

var project_004_basic = "PRO-004-BDBA-22-C";

var project_004_examprep = "PRO-004-BDEP-22-C";

var project_005_voucher = "PRO-005-TSTV-22-C";

var project_005_ebook = "PRO-005-SPDB-22-C";

var project_005_basic = "PRO-005-BDBA-22-C";

var project_005_examprep = "PRO-005-BDEP-22-C";

var project_005_elearning = "PRO-005-BDEL-22-C";

var project_005_cmlearn = "PRO-005-CMLI-22-C";

var project_005_labs = "PRO-005-CMLB-22-C";

var project_005_cmpractice = "PRO-005-CMPI-22-C";

var project_005_complete = "PRO-005-BDCO-22-C";

var project_examdetails = "PRO-005-TSTV-22-C";

var security_601_voucher = "SEC-601-TSTV-20-C";

var security_601_ebook = "SEC-601-SPDB-20-C";

var security_601_cmpractice = "SEC-601-CMPI-20-C";

var security_601_cmlearn = "SEC-601-CMLI-20-C";

var security_601_labs = "SEC-601-CMLB-20-C";

var security_601_basic = "SEC-601-BDBA-22-C";

var security_601_examprep = "SEC-601-BDEP-22-C";

var security_601_elearning = "SEC-601-BDEL-22-C";

var security_601_complete = "SEC-601-BDCO-22-C";

var security_voucher = "SEC-601-TSTV-20-C";

var security_ebook = "SEC-601-SPDB-20-C";

var security_cmpractice = "SEC-601-CMPI-20-C";

var security_cmlearn = "SEC-601-CMLI-20-C";

var security_labs = "SEC-601-CMLB-20-C";

var security_basic = "SEC-601-BDBA-22-C";

var security_examprep = "SEC-601-BDEP-22-C";

var security_elearning = "SEC-601-BDEL-22-C";

var security_complete = "SEC-601-BDCO-22-C";

var security_examdetails = "SEC-601-TSTV-20-C";

var server_005_voucher = "SER-005-TSTV-21-C";

var server_005_basic = "SER-005-BDBA-22-C";

var server_005_examprep = "SER-005-BDEP-22-C";

var server_005_elearning = "SER-005-BDEL-22-C";

var server_005_complete = "SER-005-BDCO-22-C";

var server_005_ebook = "SER-005-SPDB-21-C";

var server_005_labs = "SER-005-CMLB-21-C";

var server_005_cmpractice = "SER-005-CMPI-21-C";

var server_005_cmlearn = "SER-005-CMLI-21-C";

var server_examdetails = "SER-005-TSTV-21-C";

var a_footer_en = "<p style=\"text-align:center;margin-top:20px;\">* CompTIA A+ certification consists of 2 separate exams, 220-1001 and 220-1002 or 220-1101 and 220-1102. In order to take both exams, you need to purchase 2 vouchers. Vouchers can be used for any of the exams.</p><p style=\"text-align:center;margin-top:20px;\">Don't see a bundle you like, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-a%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">click here</a> to see all our bundle offers. Shown prices apply to US store only. Prices in other regions may vary.</p>";

var a_footer_de = "<p style=\"text-align:center;margin-top:20px;\">* Die CompTIA A + -Zertifizierung besteht aus 2 separaten Prüfungen, 220-1001 und 220-1002 oder 220-1101 und 220-1102. Um beide Prüfungen ablegen zu können, müssen Sie 2 Gutscheine erwerben. Gutscheine können für alle Prüfungen verwendet werden.</p><p style=\"text-align:center;margin-top:20px;\">Sie sehen kein Paket, das Ihnen gefällt, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-a%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">klicken Sie hier</a>, um -all unsere Paketangebote zu sehen.click here. Die angegebenen Preise gelten nur für den US-Shop. Die Preise in anderen Regionen können variieren.</p>";

var a_footer_es = "<p style=\"text-align:center;margin-top:20px;\">* La certificación CompTIA A + consta de 2 exámenes separados, 220-1001 y 220-1002 o 220-1101 y 220-1102. Para tomar ambos exámenes, necesitas comprar 2 cupones. Los vales se pueden utilizar para cualquiera de los exámenes.</p><p style=\"text-align:center;margin-top:20px;\">Si no ve un paquete que le guste, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-a%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">haga clic aquí</a> para ver todas nuestras ofertas de paquetes. Los precios mostrados solo se aplican a las tiendas de EE.UU. Los precios en otras regiones pueden variar.</p>";

var a_footer_pt = "<p style=\"text-align:center;margin-top:20px;\">* A certificação CompTIA A + consiste em dois exames separados, 220-1001 e 220-1002 ou 220-1101 e 220-1102. Para fazer os dois exames, você precisa adquirir dois vouchers. Vouchers podem ser usados para qualquer um dos exames.</p><p style=\"text-align:center;margin-top:20px;\">Se não vê um pacote que te agrada, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-a%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">clique aqui</a> para ver todas os nossos pacotes. Preços exibidos se aplicam somente à loja dos EUA. Preços em outras regiões podem variar.</p>";

var casp_footer_en = "<p style=\"text-align:center;margin-top:20px;\">Don't see a bundle you like, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-casp%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">click here</a> to see all our bundle offers. Shown prices apply to US store only. Prices in other regions may vary.</p>";

var casp_footer_de = "<p style=\"text-align:center;margin-top:20px;\">Sie sehen kein Paket, das Ihnen gefällt, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-casp%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">klicken Sie hier</a>, um -all unsere Paketangebote zu sehen. Die angegebenen Preise gelten nur für den US-Shop. Die Preise in anderen Regionen können variieren.</p>";

var casp_footer_es = "<p style=\"text-align:center;margin-top:20px;\">Si no ve un paquete que le guste, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-casp%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">haga clic aquí</a> para ver todas nuestras ofertas de paquetes. Los precios mostrados solo se aplican a las tiendas de EE.UU. Los precios en otras regiones pueden variar.</p>";

var casp_footer_pt = "<p style=\"text-align:center;margin-top:20px;\">Se não vê um pacote que te agrada, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-casp%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">clique aqui</a> para ver todas os nossos pacotes. Preços exibidos se aplicam somente à loja dos EUA. Preços em outras regiões podem variar.</p>";

var ce_footer_en = "<p style=\"text-align:center;margin-top:20px;\">Don't see a bundle you like, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-cloud-essentials%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">click here</a> to see all our bundle offers. Shown prices apply to US store only. Prices in other regions may vary.</p>";

var ce_footer_de = "<p style=\"text-align:center;margin-top:20px;\">Sie sehen kein Paket, das Ihnen gefällt, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-cloud-essentials%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">klicken Sie hier</a>, um -all unsere Paketangebote zu sehen. Die angegebenen Preise gelten nur für den US-Shop. Die Preise in anderen Regionen können variieren.</p>";

var ce_footer_es = "<p style=\"text-align:center;margin-top:20px;\">Si no ve un paquete que le guste, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-cloud-essentials%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">haga clic aquí</a> para ver todas nuestras ofertas de paquetes. Los precios mostrados solo se aplican a las tiendas de EE.UU. Los precios en otras regiones pueden variar.</p>";

var ce_footer_pt = "<p style=\"text-align:center;margin-top:20px;\">Se não vê um pacote que te agrada, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-cloud-essentials%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">clique aqui</a> para ver todas os nossos pacotes. Preços exibidos se aplicam somente à loja dos EUA. Preços em outras regiões podem variar.</p>";

var cloud_footer_en = "<p style=\"text-align:center;margin-top:20px;\">Don't see a bundle you like, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-cloud%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">click here</a> to see all our bundle offers. Shown prices apply to US store only. Prices in other regions may vary.</p>";

var cloud_footer_de = "<p style=\"text-align:center;margin-top:20px;\">Sie sehen kein Paket, das Ihnen gefällt, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-cloud%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">klicken Sie hier</a>, um -all unsere Paketangebote zu sehen. Die angegebenen Preise gelten nur für den US-Shop. Die Preise in anderen Regionen können variieren.</p>";

var cloud_footer_es = "<p style=\"text-align:center;margin-top:20px;\">Si no ve un paquete que le guste, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-cloud%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">haga clic aquí</a> para ver todas nuestras ofertas de paquetes. Los precios mostrados solo se aplican a las tiendas de EE.UU. Los precios en otras regiones pueden variar.</p>";

var cloud_footer_pt = "<p style=\"text-align:center;margin-top:20px;\">Se não vê um pacote que te agrada, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-cloud%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">clique aqui</a> para ver todas os nossos pacotes. Preços exibidos se aplicam somente à loja dos EUA. Preços em outras regiões podem variar.</p>";

var ctt_footer_en = "<p style=\"text-align:center;margin-top:20px;\">Don't see a bundle you like, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-ctt%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">click here</a> to see all our bundle offers. Shown prices apply to US store only. Prices in other regions may vary.</p>";

var ctt_footer_de = "<p style=\"text-align:center;margin-top:20px;\">Sie sehen kein Paket, das Ihnen gefällt, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-ctt%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">klicken Sie hier</a>, um -all unsere Paketangebote zu sehen. Die angegebenen Preise gelten nur für den US-Shop. Die Preise in anderen Regionen können variieren.</p>";

var ctt_footer_es = "<p style=\"text-align:center;margin-top:20px;\">Si no ve un paquete que le guste, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-ctt%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">haga clic aquí</a> para ver todas nuestras ofertas de paquetes. Los precios mostrados solo se aplican a las tiendas de EE.UU. Los precios en otras regiones pueden variar.</p>";

var ctt_footer_pt = "<p style=\"text-align:center;margin-top:20px;\">Se não vê um pacote que te agrada, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-ctt%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">clique aqui</a> para ver todas os nossos pacotes. Preços exibidos se aplicam somente à loja dos EUA. Preços em outras regiões podem variar.</p>";

var cysa_footer_en = "<p style=\"text-align:center;margin-top:20px;\">Don't see a bundle you like, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-csa%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">click here</a> to see all our bundle offers. Shown prices apply to US store only. Prices in other regions may vary.</p>";

var cysa_footer_de = "<p style=\"text-align:center;margin-top:20px;\">Sie sehen kein Paket, das Ihnen gefällt, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-csa%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">klicken Sie hier</a>, um -all unsere Paketangebote zu sehen. Die angegebenen Preise gelten nur für den US-Shop. Die Preise in anderen Regionen können variieren.</p>";

var cysa_footer_es = "<p style=\"text-align:center;margin-top:20px;\">Si no ve un paquete que le guste, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-csa%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">haga clic aquí</a> para ver todas nuestras ofertas de paquetes. Los precios mostrados solo se aplican a las tiendas de EE.UU. Los precios en otras regiones pueden variar.</p>";

var cysa_footer_pt = "<p style=\"text-align:center;margin-top:20px;\">Se não vê um pacote que te agrada, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-csa%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">clique aqui</a> para ver todas os nossos pacotes. Preços exibidos se aplicam somente à loja dos EUA. Preços em outras regiões podem variar.</p>";

var data_footer_en = "<p style=\"text-align:center;margin-top:20px;\">Don't see a bundle you like, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-data%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">click here</a> to see all our bundle offers. Shown prices apply to US store only. Prices in other regions may vary.</p>";

var data_footer_de = "<p style=\"text-align:center;margin-top:20px;\">Sie sehen kein Paket, das Ihnen gefällt, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-data%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">klicken Sie hier</a>, um -all unsere Paketangebote zu sehen. Die angegebenen Preise gelten nur für den US-Shop. Die Preise in anderen Regionen können variieren.</p>";

var data_footer_es = "<p style=\"text-align:center;margin-top:20px;\">Si no ve un paquete que le guste, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-data%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">haga clic aquí</a> para ver todas nuestras ofertas de paquetes. Los precios mostrados solo se aplican a las tiendas de EE.UU. Los precios en otras regiones pueden variar.</p>";

var data_footer_pt = "<p style=\"text-align:center;margin-top:20px;\">Se não vê um pacote que te agrada, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-data%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">clique aqui</a> para ver todas os nossos pacotes. Preços exibidos se aplicam somente à loja dos EUA. Preços em outras regiões podem variar.</p>";

var itf_footer_en = "<p style=\"text-align:center;margin-top:20px;\">Don't see a bundle you like, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-it-fundamentals%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">click here</a> to see all our bundle offers. Shown prices apply to US store only. Prices in other regions may vary.</p>";

var itf_footer_de = "<p style=\"text-align:center;margin-top:20px;\">Sie sehen kein Paket, das Ihnen gefällt, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-it-fundamentals%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">klicken Sie hier</a>, um -all unsere Paketangebote zu sehen. Die angegebenen Preise gelten nur für den US-Shop. Die Preise in anderen Regionen können variieren.</p>";

var itf_footer_es = "<p style=\"text-align:center;margin-top:20px;\">Si no ve un paquete que le guste, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-it-fundamentals%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">haga clic aquí</a> para ver todas nuestras ofertas de paquetes. Los precios mostrados solo se aplican a las tiendas de EE.UU. Los precios en otras regiones pueden variar.</p>";

var itf_footer_pt = "<p style=\"text-align:center;margin-top:20px;\">Se não vê um pacote que te agrada, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-it-fundamentals%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">clique aqui</a> para ver todas os nossos pacotes. Preços exibidos se aplicam somente à loja dos EUA. Preços em outras regiões podem variar.</p>";

var linux_footer_en = "<p style=\"text-align:center;margin-top:20px;\">Don't see a bundle you like, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-linux%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">click here</a> to see all our bundle offers. Shown prices apply to US store only. Prices in other regions may vary.</p>";

var linux_footer_de = "<p style=\"text-align:center;margin-top:20px;\">Sie sehen kein Paket, das Ihnen gefällt, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-linux%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">klicken Sie hier</a>, um -all unsere Paketangebote zu sehen. Die angegebenen Preise gelten nur für den US-Shop. Die Preise in anderen Regionen können variieren.</p>";

var linux_footer_es = "<p style=\"text-align:center;margin-top:20px;\">Si no ve un paquete que le guste, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-linux%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">haga clic aquí</a> para ver todas nuestras ofertas de paquetes. Los precios mostrados solo se aplican a las tiendas de EE.UU. Los precios en otras regiones pueden variar.</p>";

var linux_footer_pt = "<p style=\"text-align:center;margin-top:20px;\">Se não vê um pacote que te agrada, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-linux%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">clique aqui</a> para ver todas os nossos pacotes. Preços exibidos se aplicam somente à loja dos EUA. Preços em outras regiões podem variar.</p>";

var network_footer_en = "<p style=\"text-align:center;margin-top:20px;\">Don't see a bundle you like, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-network%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">click here</a> to see all our bundle offers. Shown prices apply to US store only. Prices in other regions may vary.</p>";

var network_footer_de = "<p style=\"text-align:center;margin-top:20px;\">Sie sehen kein Paket, das Ihnen gefällt, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-network%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">klicken Sie hier</a>, um -all unsere Paketangebote zu sehen. Die angegebenen Preise gelten nur für den US-Shop. Die Preise in anderen Regionen können variieren.</p>";

var network_footer_es = "<p style=\"text-align:center;margin-top:20px;\">Si no ve un paquete que le guste, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-network%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">haga clic aquí</a> para ver todas nuestras ofertas de paquetes. Los precios mostrados solo se aplican a las tiendas de EE.UU. Los precios en otras regiones pueden variar.</p>";

var network_footer_pt = "<p style=\"text-align:center;margin-top:20px;\">Se não vê um pacote que te agrada, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-network%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">clique aqui</a> para ver todas os nossos pacotes. Preços exibidos se aplicam somente à loja dos EUA. Preços em outras regiões podem variar.</p>";

var pentest_footer_en = "<p style=\"text-align:center;margin-top:20px;\">Don't see a bundle you like, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-pentest%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">click here</a> to see all our bundle offers. Shown prices apply to US store only. Prices in other regions may vary.</p>";

var pentest_footer_de = "<p style=\"text-align:center;margin-top:20px;\">Sie sehen kein Paket, das Ihnen gefällt, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-pentest%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">klicken Sie hier</a>, um -all unsere Paketangebote zu sehen. Die angegebenen Preise gelten nur für den US-Shop. Die Preise in anderen Regionen können variieren.</p>";

var pentest_footer_es = "<p style=\"text-align:center;margin-top:20px;\">Si no ve un paquete que le guste, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-pentest%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">haga clic aquí</a> para ver todas nuestras ofertas de paquetes. Los precios mostrados solo se aplican a las tiendas de EE.UU. Los precios en otras regiones pueden variar.</p>";

var pentest_footer_pt = "<p style=\"text-align:center;margin-top:20px;\">Se não vê um pacote que te agrada, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-pentest%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">clique aqui</a> para ver todas os nossos pacotes. Preços exibidos se aplicam somente à loja dos EUA. Preços em outras regiões podem variar.</p>";

var project_footer_en = "<p style=\"text-align:center;margin-top:20px;\">Don't see a bundle you like, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-project%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">click here</a> to see all our bundle offers. Shown prices apply to US store only. Prices in other regions may vary.</p>";

var project_footer_de = "<p style=\"text-align:center;margin-top:20px;\">Sie sehen kein Paket, das Ihnen gefällt, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-project%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">klicken Sie hier</a>, um -all unsere Paketangebote zu sehen. Die angegebenen Preise gelten nur für den US-Shop. Die Preise in anderen Regionen können variieren.</p>";

var project_footer_es = "<p style=\"text-align:center;margin-top:20px;\">Si no ve un paquete que le guste, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-project%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">haga clic aquí</a> para ver todas nuestras ofertas de paquetes. Los precios mostrados solo se aplican a las tiendas de EE.UU. Los precios en otras regiones pueden variar.</p>";

var project_footer_pt = "<p style=\"text-align:center;margin-top:20px;\">Se não vê um pacote que te agrada, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-project%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">clique aqui</a> para ver todas os nossos pacotes. Preços exibidos se aplicam somente à loja dos EUA. Preços em outras regiões podem variar.</p>";

var security_footer_en = "<p style=\"text-align:center;margin-top:20px;\">Don't see a bundle you like, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-security%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">click here</a> to see all our bundle offers. Shown prices apply to US store only. Prices in other regions may vary.</p>";

var security_footer_de = "<p style=\"text-align:center;margin-top:20px;\">Sie sehen kein Paket, das Ihnen gefällt, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-security%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">klicken Sie hier</a>, um -all unsere Paketangebote zu sehen. Die angegebenen Preise gelten nur für den US-Shop. Die Preise in anderen Regionen können variieren.</p>";

var security_footer_es = "<p style=\"text-align:center;margin-top:20px;\">Si no ve un paquete que le guste, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-security%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">haga clic aquí</a> para ver todas nuestras ofertas de paquetes. Los precios mostrados solo se aplican a las tiendas de EE.UU. Los precios en otras regiones pueden variar.</p>";

var security_footer_pt = "<p style=\"text-align:center;margin-top:20px;\">Se não vê um pacote que te agrada, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-security%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">clique aqui</a> para ver todas os nossos pacotes. Preços exibidos se aplicam somente à loja dos EUA. Preços em outras regiões podem variar.</p>";

var server_footer_en = "<p style=\"text-align:center;margin-top:20px;\">Don't see a bundle you like, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-server%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">click here</a> to see all our bundle offers. Shown prices apply to US store only. Prices in other regions may vary.</p>";

var server_footer_de = "<p style=\"text-align:center;margin-top:20px;\">Sie sehen kein Paket, das Ihnen gefällt, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-server%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">klicken Sie hier</a>, um -all unsere Paketangebote zu sehen. Die angegebenen Preise gelten nur für den US-Shop. Die Preise in anderen Regionen können variieren.</p>";

var server_footer_es = "<p style=\"text-align:center;margin-top:20px;\">Si no ve un paquete que le guste, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-server%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">haga clic aquí</a> para ver todas nuestras ofertas de paquetes. Los precios mostrados solo se aplican a las tiendas de EE.UU. Los precios en otras regiones pueden variar.</p>";

var server_footer_pt = "<p style=\"text-align:center;margin-top:20px;\">Se não vê um pacote que te agrada, <a href=\"https://store.comptia.org/bundles/c/11295?facetValueFilter=tenant~certification:comptia-server%2ctenant~user-type:individual&amp;\" onclick=\"gtag('event', 'Buy Table', { 'event_category': 'Product Buy Button', 'event_label' : 'More Bundles'});\">clique aqui</a> para ver todas os nossos pacotes. Preços exibidos se aplicam somente à loja dos EUA. Preços em outras regiões podem variar.</p>";

$(document).ready(function() {
    $(".CMCEPopuplink").on("click", function(e) {
        e.preventDefault();
        var CMCEBuylink = $(this).attr("href");
        $(".continuecmce").attr("href", CMCEBuylink);
        $.featherlight(".CMCEPopupcontent", {
            variant: "sitewide-popup CMCEPopup"
        });
    });
});

$(document).ready(function() {
    $(".modal").on("hidden.bs.modal", function() {
        var thisForm = $(this).find("form")[0];
        thisForm.reset();
        $(thisForm).find(".text-danger span").remove();
        $(thisForm).find("#verify-result").html("");
        $(thisForm).find("#verify-result").removeClass("error");
    });
    $(".CMCEVerifyPopuplink").on("click", function(e) {
        e.preventDefault();
        var CMCEBuylink = $(this).attr("href");
        $(".continuecmce").attr("href", CMCEBuylink);
        $("#Certification").val($(this).data("certification"));
        $("#ModalPopUp").modal("show");
    });
    $(".CMCEPopupcontent #CertMasterCEVerifyPopupForm").submit(function(e) {
        var thisForm = $(this);
        var button = $(this).find('input[type="submit"]');
        setTimeout(function() {
            button.attr("disabled", "disabled");
        }, 0);
        e.preventDefault();
        e.returnValue = false;
        if ($(this).valid()) {
            $.ajax({
                url: this.action,
                type: this.method,
                data: $(this).serialize(),
                success: function(result) {
                    if (!result.success) {
                        thisForm.find("#verify-result").html(result.responseText);
                        thisForm.find("#verify-result").addClass("error");
                        setTimeout(function() {
                            button.removeAttr("disabled");
                        }, 0);
                    } else {
                        window.location.href = result.responseText;
                    }
                }
            });
        } else {
            setTimeout(function() {
                button.removeAttr("disabled");
            }, 0);
            return false;
        }
        return false;
    });
});